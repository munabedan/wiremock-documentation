{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Documentation</p> <p>   WireMock is a popular open-source tool for API mock testing, with over 5   million downloads per month. It can help you to create stable test and   development environments, isolate yourself from flakey 3rd parties and   simulate APIs that don't exist yet. </p> Getting Started      Overview         Quick Start         Download         Get Help    Distributions <p>   WireMock provides the following generic distributions that allow running it as   a   standalone server   in a container or within a Java Virtual Machine. </p>      Standalone JAR         Docker         Helm (Experimental)         WireMock Cloud (commercial SaaS)         NPM    By use-case <p>   Below you can find links to the documentation for WireMock key use-cases. You   can find more documentation pages on the sidebar. </p>      Advanced request matching         Dynamic response templating         Use API Mocking in your unit tests         Fault and latency injection         Record / Playback         Use pre-defined Mock API templates         Extending WireMock    By protocol <p>   WireMock can serve all HTTP-based protocols and REST API. Through built-in   features and extensions, it provides additional capabilities for widely used   protocols. </p>      Webhooks and Callbacks         HTTPs         gRPC         GraphQL    By technology <p>   There are also solutions and guides for particular technologies and   frameworks, provided by the WireMock community and external contributors. </p>      Java and JVM         Python         Spring Boot         Node.js         Android         .NET         Golang         Rust         Groovy         Kotlin         Kubernetes         Testcontainers         Quarkus         C/C++"},{"location":"commercial/","title":"Commercial Support","text":"<p>Documentation / commercial WireMock is an open source project. In accordance with the Apache License 2.0, in general there is no support or guarantees provided for it. You can get some assistance through WireMock community channels, and contribute to helping other users too. At the same time, there are vendors that provide commercial support for WireMock.</p>"},{"location":"commercial/#products-with-commercial-support","title":"Products with commercial support","text":""},{"location":"commercial/#wiremock-cloud-priority-support","title":"WireMock Cloud - Priority Support","text":"<p>Built on WireMock, WireMock Cloud offers a hosted experience including a self-service UI, enterprise support, and unlimited scale. Key features, in addition to all WireMock capabilities, include support for manual and automated testing, importing APIs from OpenAPI and Swagger, and Chaos Engineering.</p> <p>For users of the WireMock Cloud service, WireMock Inc offers priority support with a guaranteed SLA as part the Enterprise subscription plan. You can find more info about WireMock Cloud support plans here.</p> <p>Get in touch with our team to discuss options or get a demo.</p>"},{"location":"commercial/#wiremocha-integration-for-jetbrains-ides","title":"WireMocha - Integration for JetBrains IDEs","text":"<p>WireMocha is a plugin for IntelliJ based IDEs, and has tools for WireMock specific static code analysis (in the Java and JSON DSLs), code generation, stubbing, and many others to overall simplify the work with WireMock.</p> <p>Two prominent code generation features, beside a handful of smaller ones, can help you: - generate a scenario's Java and JSON stub implementations by simply modeling its states and transitions in a dedicated tool window, - generate and preview the Java version of JSON stub mappings on-the-fly during editing JSON mapping files. It can speed up migration from JSON to Java implementation.</p> <p>JSON schemas are also associated to JSON mapping files, and are joined with various language injections. They provide additional syntax highlighting (e.g. Handlebars, XPath, ...) and validation, as well as code completion that can greatly speed up the implementation and maintenance of JSON mapping files.</p> <p>The plugin is available on the JetBrains Marketplace for a 30-day trial and for purchase. You can raise your questions, feature requests or bug reports on GitHub, and browse its documentation here.</p>"},{"location":"commercial/#trainings-and-workshops","title":"Trainings and Workshops","text":""},{"location":"commercial/#trainings-and-workshops-by-bas-dijkstra","title":"Trainings and Workshops by Bas Dijkstra","text":"<p>Bas Dijkstra is an independent consultant providing in-company training and workshops in WireMock, both on-site and online. You can find more information about his services and get in touch with him on his website. If you're looking for material to help you practice using WireMock on your own machine, in your own time, Bas Dijkstra also maintains an open source workshop on WireMock that is free for all to use: https://github.com/basdijkstra/wiremock-workshop</p>"},{"location":"commercial/#other-commercial-options-add-yours","title":"Other commercial options / Add yours","text":"<p>Any other company or individual consultant are welcome to submit a pull request and to extend information on this page.</p>"},{"location":"support/","title":"Support","text":"<p>Documentation / support WireMock is an open source project. In accordance with the Apache License 2.0, in general there is no support or guarantees provided for it. At the same time, you can get some assistance through WireMock community channels, and contribute to helping other users too. There are also vendors that provide commercial support for WireMock.</p>"},{"location":"support/#wiremock-community","title":"WireMock Community","text":"<p>If you\u2019re looking for help or advice, you can find a community of users and contributors on the WireMock community Slack channels. Stack Overflow also has many good WireMock questions and answers.</p> <p>Note that all the community channels are maintained without any guarantees or a Service Level Agreement (SLA). All responses are provided by community members, and it is a best effort. Every community member is welcome to participate, help to triage and answer the questions.</p> <ul> <li>WireMock Community Slack provides the <code>#help</code> channel for Q&amp;A</li> <li>As a question on StackOverflow, use the <code>wiremock</code> tag</li> </ul>"},{"location":"support/#commercial-support-trainings-and-consulting","title":"Commercial support, trainings and consulting","text":"<p>See this page.</p>"},{"location":"advanced_use_cases/deploying_into_a_servlet_container/","title":"Deploying into a servlet container","text":"<p>Documentation / advanced_use_cases / deploying_into_a_servlet_container WireMock can be packaged up as a WAR and deployed into a servlet container, with some caveats: fault injection and browser proxying won't work, <code>\\_\\_</code>files won't be treated as a docroot as with standalone, the server cannot be remotely shutdown, and the container must be configured to explode the WAR on deployment. This has only really been tested in Tomcat 6 and Jetty, so YMMV. Running standalone is definitely the preferred option.</p> <p>The easiest way to create a WireMock WAR project is to clone the sample app.</p>"},{"location":"advanced_use_cases/deploying_into_a_servlet_container/#deploying-under-a-sub-path-of-the-context-root","title":"Deploying under a sub-path of the context root","text":"<p>If you want WireMock's servlet to have a non-root path, the additional init param <code>mappedUnder</code> must be set with the sub-path web.xml (in addition to configuring the servlet mapping appropriately).</p> <p>See the custom mapped WAR example for details.</p>"},{"location":"advanced_use_cases/multidomain_mocking/","title":"Multi-domain Mocking","text":"<p>Documentation / advanced_use_cases / multidomain_mocking A typical usage pattern is to run a WireMock instance per API you need to mock and configure your app to treat these instances as endpoints.</p> <p>However, it's also possible to mock multiple APIs in a single instance via the use of the proxying and hostname matching features. There are two advantages of this approach - lower overhead (memory, startup/shutdown time), and no need to modify each base URL in your app's configuration. It can also avoid some of the headaches associated with binding to random ports.</p> <p>The key steps to enabling this configuration are:</p> <ol> <li>Enable browser (forward) proxying via <code>.enableBrowserProxying(true)</code> in the startup options.</li> <li>Configure the JVM's proxy settings to point to the WireMock instance using <code>JvmProxyConfigurer</code>.</li> </ol> <p>The following sections detail how to achieve this in various deployment contexts.</p>"},{"location":"advanced_use_cases/multidomain_mocking/#configuring-for-junit-jupiter","title":"Configuring for JUnit Jupiter","text":"<p>The simplest way to enable this mode if you're using JUnit Jupiter it to toggle it on via the <code>WireMockExtension</code>. See the Junit Jupiter Proxy Mode for details.</p>"},{"location":"advanced_use_cases/multidomain_mocking/#configuring-for-junit-4x","title":"Configuring for JUnit 4.x","text":"<p>To use this mode with the JUnit 4.x rule we:</p> <ol> <li>Create the rule as usual with browser proxying enabled.</li> <li>Ensure our HTTP client (the one used by our app to talk to the API we're mocking) honours the system properties relating to proxy servers.</li> <li>Set the proxy properties using <code>JvmProxyConfigurer</code> before each test case and unset them afterwards.</li> <li>Specify the host name we're targeting when creating stubs.</li> </ol> Java<pre><code>public class MultiDomainJUnit4Test {\n\n  @Rule\n  public WireMockRule wm = new WireMockRule(options()\n        .dynamicPort()\n        .enableBrowserProxying(true)\n  );\n\n  HttpClient httpClient = HttpClientBuilder.create()\n    .useSystemProperties() // This must be enabled for auto proxy config\n    .build();\n\n  @Before\n  public void init() {\n    JvmProxyConfigurer.configureFor(wm);\n  }\n\n  @After\n  public void cleanup() {\n    JvmProxyConfigurer.restorePrevious();\n  }\n\n  @Test\n  public void testViaProxy() throws Exception {\n      wm.stubFor(get(\"/things\")\n        .withHost(equalTo(\"my.first.domain\"))\n        .willReturn(ok(\"Domain 1\")));\n\n      wm.stubFor(get(\"/things\")\n        .withHost(equalTo(\"my.second.domain\"))\n        .willReturn(ok(\"Domain 2\")));\n\n      HttpResponse response = httpClient.execute(new HttpGet(\"http://my.first.domain/things\"));\n      String responseBody = EntityUtils.toString(response.getEntity());\n      assertEquals(\"Domain 1\", responseBody);\n\n      response = httpClient.execute(new HttpGet(\"http://my.second.domain/things\"));\n      responseBody = EntityUtils.toString(response.getEntity());\n      assertEquals(\"Domain 2\", responseBody);\n  }\n}\n</code></pre>"},{"location":"advanced_use_cases/multidomain_mocking/#configuring-for-other-java","title":"Configuring for other Java","text":"<p>To use this mode from Java code we:</p> <ol> <li>Create and start a <code>WireMockServer</code> instance with browser proxying enabled.</li> <li>Ensure our HTTP client (the one used by our app to talk to the API we're mocking) honours the system properties relating to proxy servers</li> <li>Set the proxy properties using <code>JvmProxyConfigurer</code> before each bit of work and unset them afterwards.</li> <li>Specify the host name we're targeting when creating stubs.</li> </ol> Java<pre><code>public void testViaProxyUsingServer() throws Exception {\n  WireMockServer wireMockServer = new WireMockServer(options()\n    .dynamicPort()\n    .enableBrowserProxying(true)\n  );\n  wireMockServer.start();\n\n  HttpClient httpClient = HttpClientBuilder.create()\n    .useSystemProperties() // This must be enabled for auto proxy config\n    .build();\n\n  JvmProxyConfigurer.configureFor(wireMockServer);\n\n  wireMockServer.stubFor(get(\"/things\")\n    .withHost(equalTo(\"my.first.domain\"))\n    .willReturn(ok(\"Domain 1\")));\n\n  wireMockServer.stubFor(get(\"/things\")\n    .withHost(equalTo(\"my.second.domain\"))\n    .willReturn(ok(\"Domain 2\")));\n\n  HttpResponse response = httpClient.execute(new HttpGet(\"http://my.first.domain/things\"));\n  String responseBody = EntityUtils.toString(response.getEntity()); // Should == Domain 1\n\n  response = httpClient.execute(new HttpGet(\"http://my.second.domain/things\"));\n  responseBody = EntityUtils.toString(response.getEntity()); // Should == Domain 2\n\n  wireMockServer.stop();\n  JvmProxyConfigurer.restorePrevious();\n}\n</code></pre>"},{"location":"advanced_use_cases/wiremock_on_java/","title":"WireMock on Java 1.7","text":"<p>Documentation / advanced_use_cases / wiremock_on_java</p> <p>WARNING: Recent WireMock versions do not support Java 1.7, but you can run older versions to achieve that. The Java 7 version was deprecated in the 2.x line and version 2.27.2 is the last release available. There will be no bugfixes and security patches provided. Make sure to update as soon as possible to Java 11 or above.</p> <p>The Java 7 distribution is aimed primarily at Android developers and enterprise Java teams still using Java Runtime Environment (JRE) 1.7. Some of its dependencies are not set to the latest versions e.g. Jetty 9.2.x is used, as this is the last minor version to retain Java 7 compatibility.</p>"},{"location":"advanced_use_cases/wiremock_on_java/#maven-dependencies","title":"Maven dependencies","text":"<p>JUnit:</p> XML<pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;com.github.tomakehurst&lt;/groupId&gt;\n    &lt;artifactId&gt;wiremock&lt;/artifactId&gt;\n    &lt;version&gt;2.27.2&lt;/version&gt;\n    &lt;scope&gt;test&lt;/scope&gt;\n&lt;/dependency&gt;\n</code></pre> <p>Standalone JAR:</p> XML<pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;com.github.tomakehurst&lt;/groupId&gt;\n    &lt;artifactId&gt;wiremock-standalone&lt;/artifactId&gt;\n    &lt;version&gt;2.27.2&lt;/version&gt;\n    &lt;scope&gt;test&lt;/scope&gt;\n&lt;/dependency&gt;\n</code></pre>"},{"location":"advanced_use_cases/wiremock_on_java/#gradle-dependencies","title":"Gradle dependencies","text":"<p>JUnit:</p> Groovy<pre><code>testImplementation \"com.github.tomakehurst:wiremock:2.27.2\"\n</code></pre> <p>Standalone JAR:</p> Groovy<pre><code>testImplementation \"com.github.tomakehurst:wiremock-standalone:2.27.2\"\n</code></pre>"},{"location":"dotnet/","title":"Index","text":"<p>Documentation / dotnet</p>"},{"location":"dotnet/#welcome-to-the-wiremocknet-wiki","title":"Welcome to the WireMock.Net wiki","text":""},{"location":"dotnet/Admin-API-Reference/","title":"Admin API Reference","text":"<p>Documentation / dotnet / Admin-API-Reference</p>"},{"location":"dotnet/Admin-API-Reference/#admin-api-reference","title":"Admin API Reference","text":"<p>The WireMock admin API provides functionality to define the mappings via a http/https interface. To use this interface, you need to enable the admin interface in code: C#<pre><code>var server = WireMockServer.StartWithAdminInterface();\n</code></pre></p>"},{"location":"dotnet/Admin-API-Reference/#api-definition","title":"API definition","text":"<p>A Swagger 2.0 definition can be found on Swagger hub.</p>"},{"location":"dotnet/Admin-API-Reference/#client-api","title":"Client API","text":"<p>You can use a predefined interface API (WireMock.Net.RestClient) to access all the methods described on this page. C#<pre><code>// Create an implementation of the IWireMockAdminApi and pass in the base URL for the API.\nvar api = RestClient.For&lt;IWireMockAdminApi&gt;(\"http://localhost:9091\");\n\n// Set BASIC Authorization\napi.Authorization = new AuthenticationHeaderValue(\"Basic\", Convert.ToBase64String(Encoding.ASCII.GetBytes(\"foo:bar\")));\n\n// OR\n\n// Set Azure AD Authentication\napi.Authorization = new AuthenticationHeaderValue(\"Bearer\", \"eyJ0eXAiOiJKV1QiLCJ...\");\n\n// Call API\nvar settings = await api.GetSettingsAsync();\n</code></pre></p>"},{"location":"dotnet/Admin-API-Reference/#azure-ad-authentication-information","title":"Azure AD Authentication - Information","text":"<p>To get v2.0 AAD token you need to modify the <code>Manifest</code> of your AAD app registration by following the instructions here https://docs.azure.cn/en-us/entra/identity-platform/scenario-protected-web-api-app-registration#accepted-token-version</p> <p>You can then get the token using this CURL command</p> Bash<pre><code># replace AadClientId, AadApplicationURI, AadClientSecret, AadTenantId with the AAD details from the azure portal.\n\ncurl -X POST -H \"Content-Type: application/x-www-form-urlencoded\" -d 'client_id={AadClientId}&amp;scope={AadApplication Uri}/.default&amp;client_secret={AadClientSecret}&amp;grant_type=client_credentials' 'https://login.microsoftonline.com/{AadTenantId}/oauth2/v2.0/token'\n</code></pre> <p>Once obtaining the token, start the WireMock.Net server, e.g. the <code>WireMock.Net.StandAlone</code> package.</p> C#<pre><code>using WireMock.Logging;\nusing WireMock.Net.StandAlone;\nusing WireMock.Settings;\n\nvar settings = new WireMockServerSettings\n{\n    AllowPartialMapping=true,\n    Logger = new WireMockConsoleLogger(),\n    UseSSL = true,\n    AdminAzureADTenant = \"AadTennatId\",\n    AdminAzureADAudience = \"AadAudience\",\n    StartAdminInterface=true\n};\n\nStandAloneApp.Start(settings);\n\nConsole.WriteLine(\"Press any key to stop the server\");\nConsole.ReadKey();\n</code></pre> <p>Make a <code>GET</code> request to <code>{WiremockServerURL}/__admin/requests</code> with the <code>Bearer AadToken</code> set in the <code>Authorization</code> header and 200 for success 401 for authentication errors.</p>"},{"location":"dotnet/Admin-API-Reference/#fluentbuilder","title":"FluentBuilder","text":"<p>All Admin API Model classes are annotated with FluentBuilder which makes it easy to build a mapping in a fluent way.</p> <p>Example code: C#<pre><code>var mappingBuilder = api.GetMappingBuilder();\n    mappingBuilder.Given(m =&gt; m\n        .WithTitle(\"This is my title 1\")\n        .WithRequest(req =&gt; req\n            .UsingGet()\n            .WithPath(\"/bla1\")\n        )\n        .WithResponse(rsp =&gt; rsp\n            .WithBody(\"x1\")\n            .WithHeaders(h =&gt; h.Add(\"h1\", \"v1\"))\n        )\n    );\n</code></pre></p>"},{"location":"dotnet/Admin-API-Reference/#supported-interfaces","title":"Supported interfaces","text":"<p>The following interfaces are supported:</p>"},{"location":"dotnet/Admin-API-Reference/#__adminsettings","title":"/__admin/settings","text":"<p>The global settings from the mock service. * <code>GET    /__admin/settings</code> --&gt; Gets the current global settings * <code>POST   /__admin/settings</code> --&gt; Updates the current global settings</p>"},{"location":"dotnet/Admin-API-Reference/#__adminhealth","title":"/__admin/health","text":"<p>Get health status. * <code>GET    /__admin/health</code> --&gt; Get health status. Returns HttpStatusCode 200 with a value Healthy to indicate that WireMock.Net is healthy. In case it's not healthy, it returns HttpStatusCode 404.</p>"},{"location":"dotnet/Admin-API-Reference/#__adminmappings","title":"/__admin/mappings","text":"<p>The mappings defined in the mock service. * <code>GET    /__admin/mappings</code> --&gt; Gets all defined mappings * <code>POST   /__admin/mappings</code> --&gt; Create a new single stub mapping or an array from mappings * <code>POST   /__admin/mappings/wiremock.org</code> --&gt; Create a new single WireMock.org stub mapping or an array WireMock.org mappings * <code>DELETE /__admin/mappings</code> or <code>POST /__admin/mappings/reset</code> --&gt; Delete all stub mappings * <code>DELETE /__admin/mappings</code> with array of json mappings/GUIDs in body --&gt; Delete stub mappings matching the specified GUIDs. * <code>GET    /__admin/mappings/{guid}</code> --&gt; Get a single stub mapping * <code>PUT    /__admin/mappings/{guid}</code> --&gt; Update a stub mapping * <code>DELETE /__admin/mappings/{guid}</code> --&gt; Delete a single stub mapping * <code>POST   /__admin/mappings/save</code> --&gt; Save all persistent stub mappings to the disk   (by default this is \\bin{x}_admin\\mappings. Where {x} is the platform + build configuration)</p>"},{"location":"dotnet/Admin-API-Reference/#adminfiles","title":"/admin/files","text":"<p>The files which can be used in the mappings. * <code>HEAD   /__admin/files/{filename.ext}</code> --&gt; Checks if the file named {filename.ext} does exist. * <code>POST   /__admin/files/{filename.ext}</code> --&gt; Creates a new file named {filename.ext} in the mappings folder on disk. * <code>PUT    /__admin/files/{filename.ext}</code> --&gt; Updates an existing file named {filename.ext} in the mappings folder on disk. * <code>GET    /__admin/files/{filename.ext}</code> --&gt; Get the content from the file named {filename.ext} in the mappings folder on disk. * <code>DELETE /__admin/files/{filename.ext}</code> --&gt; Deletes a new file named {filename.ext} from the mappings folder on disk.</p>"},{"location":"dotnet/Admin-API-Reference/#__adminrequests","title":"/__admin/requests","text":"<p>Logged requests and responses received by the mock service. * <code>GET    /__admin/requests</code> --&gt; Get received requests * <code>DELETE /__admin/requests</code> or <code>POST /__admin/requests/reset</code> --&gt; Delete all received requests * <code>GET    /__admin/requests/{guid}</code> --&gt; Get a single request * <code>POST   /__admin/requests/count</code> --&gt; TODO * <code>POST   /__admin/requests/find</code> --&gt; Find requests * <code>GET    /__admin/requests/unmatched</code> --&gt; TODO * <code>GET    /__admin/requests/unmatched/near-misses</code> --&gt; TODO</p>"},{"location":"dotnet/Admin-API-Reference/#post-__adminrequestsfind","title":"<code>POST   /__admin/requests/find</code>","text":"<p>For example, this will return all requests that were performed to this specific path. Text Only<pre><code>curl --location --request POST 'http://localhost:9999/__admin/requests/find' \\\n--header 'Content-Type: application/json' \\\n--data-raw '{\n    \"path\": \"/path/to/search/for\"\n}\n</code></pre></p> <p>For some example requests, see this PostMan Collection</p>"},{"location":"dotnet/Admin-API-Reference/#__adminmappings_1","title":"/__admin/mappings","text":"<p>The mappings defined in the mock service.</p>"},{"location":"dotnet/Admin-API-Reference/#get-__adminmappings","title":"<code>GET    /__admin/mappings</code>","text":"<p>Gets all defined mappings.</p> <p>Example request: <code>GET http://localhost/__admin/mappings</code></p> <p>Example response: JavaScript<pre><code>[\n  {\n    \"Guid\": \"be6e1db8-cb95-4a15-a836-dcd0092b34a0\",\n    \"Request\": {\n      \"Path\": {\n        \"Matchers\": [\n          {\n            \"Name\": \"WildcardMatcher\",\n            \"Pattern\": \"/data\"\n          }\n        ]\n      },\n      \"Methods\": [\n        \"get\"\n      ],\n      \"Headers\": [\n        {\n          \"Name\": \"Content-Type\",\n          \"Matchers\": [\n            {\n              \"Name\": \"WildcardMatcher\",\n              \"Pattern\": \"application/*\"\n            }\n          ]\n        }\n      ],\n      \"Cookies\": [],\n      \"Params\": [\n        {\n          \"Name\": \"start\",\n          \"Values\": [ \"1000\", \"1001\" ]\n        }\n      ],\n      \"Body\": {}\n    },\n    \"Response\": {\n      \"StatusCode\": 200,\n      \"Body\": \"{ \\\"result\\\": \\\"Contains x with FUNC 200\\\"}\",\n      \"UseTransformer\": false,\n      \"Headers\": {\n        \"Content-Type\": \"application/json\"\n      }\n    }\n  },\n  {\n    \"Guid\": \"90356dba-b36c-469a-a17e-669cd84f1f05\",\n    \"Request\": {\n      \"Path\": {\n        \"Matchers\": [\n          {\n            \"Name\": \"WildcardMatcher\",\n            \"Pattern\": \"/*\"\n          }\n        ]\n      },\n      \"Methods\": [\n        \"get\"\n      ],\n      \"Headers\": [],\n      \"Cookies\": [],\n      \"Params\": [\n        {\n          \"Name\": \"start\",\n          \"Values\": []\n        }\n      ],\n      \"Body\": {}\n    },\n    \"Response\": {\n      \"StatusCode\": 200,\n      \"Body\": \"{\\\"msg\\\": \\\"Hello world, {{request.path}}\\\"\",\n      \"UseTransformer\": true,\n      \"Headers\": {\n        \"Transformed-Postman-Token\": \"token is {{request.headers.Postman-Token}}\",\n        \"Content-Type\": \"application/json\"\n      },\n      \"Delay\": 10\n    }\n  }\n]\n</code></pre></p>"},{"location":"dotnet/Admin-API-Reference/#post-__adminmappings","title":"<code>POST   /__admin/mappings</code>","text":"<p>Create a new stub mapping</p> <p>Example request: JavaScript<pre><code>{\n    \"Guid\": \"dae02a0d-8a33-46ed-aab0-afbecc8643e3\",\n    \"Request\": {\n      \"Path\": \"/testabc\",\n      \"Methods\": [\n        \"put\"\n      ],\n      \"Headers\": [\n        {\n          \"Name\": \"Content-Type\",\n          \"Matchers\": [\n            {\n              \"Name\": \"WildcardMatcher\",\n              \"Pattern\": \"application/*\"\n            }\n          ]\n        }\n      ],\n      \"Cookies\": [],\n      \"Params\": [\n        {\n          \"Name\": \"start\",\n          \"Values\": [ \"1000\", \"1001\" ]\n        }\n      ],\n       \"Body\": {\n        \"Matcher\": {\n          \"Name\": \"JsonPathMatcher\",\n          \"Pattern\": \"$.things[?(@.name == 'RequiredThing')]\"\n        }\n      }\n    },\n    \"Response\": {\n      \"UseTransformer\": true,\n      \"StatusCode\": 205,\n      \"BodyAsJson\": { \"result\": \"test - {{request.path}}\" },\n      \"Headers\": {\n        \"Content-Type\": \"application/json\", \"a\" : \"b\"\n      },\n      \"Delay\": 10\n    }\n  }\n</code></pre></p> <p>Create a new stub mapping and save this to disk. Example request: JavaScript<pre><code>{\n    \"Guid\": \"dae02a0d-8a33-46ed-aab0-afbecc864344\",\n    \"SaveToFile\": true,\n    \"Title\": \"the_filename\",\n    \"Request\": {\n      \"Url\": \"/example\",\n      \"Methods\": [\n        \"get\"\n      ]\n    },\n    \"Response\": {\n      \"BodyAsJson\": { \"result\": \"ok\" }\n    }\n  }\n</code></pre></p> <p>Note : It's also possible to pre-load Mappings. This can be done by putting a file named <code>{guid}.json</code> in the <code>__admin\\mapping</code> directory.</p> <p>Example : <code>11111110-a633-40e8-a244-5cb80bc0ab66.json</code> JSON<pre><code>{\n    \"Request\": {\n        \"Path\": {\n            \"Matchers\": [\n                {\n                    \"Name\": \"WildcardMatcher\",\n                    \"Pattern\": \"/static/mapping\"\n                }\n            ]\n        },\n        \"Methods\": [\n            \"get\"\n        ]\n    },\n    \"Response\": {\n        \"BodyAsJson\": { \"body\": \"static mapping\" },\n        \"Headers\": {\n            \"Content-Type\": \"application/json\"\n        }\n    }\n}\n</code></pre></p>"},{"location":"dotnet/Admin-API-Reference/#delete-__adminmappings","title":"<code>DELETE /__admin/mappings</code>","text":"<p>Delete all stub mappings. (If there is no request body).</p>"},{"location":"dotnet/Admin-API-Reference/#delete-__adminmappings_1","title":"<code>DELETE /__admin/mappings</code>","text":"<p>Delete the stub mappings matched to the GUIDs in the request body.</p> <p>Example request: JavaScript<pre><code>{\n    \"Guid\": \"dae02a0d-8a33-46ed-aab0-afbecc8643e3\",\n    \"Request\": {\n      \"Url\": \"/testabc\",\n      \"Methods\": [\n        \"put\"\n      ]\n    },\n    \"Response\": {\n      \"Body\": \"Response Body\",\n      \"Headers\": {\n        \"Content-Type\": \"application/json\"\n      }\n    }\n}\n</code></pre> The only truly necessary piece of the body json is the Guid. So this is also valid syntax for the request (demonstrates multi-delete): JavaScript<pre><code>[{\n    \"Guid\": \"dae02a0d-8a33-46ed-aab0-afbecc8643e3\"\n},\n{\n    \"Guid\": \"c181c4f6-fe48-4712-8390-e1a4b358e278\"\n}]\n</code></pre> The most obvious application of DELETE with request body will be the ability to send identical requests to the __admin/mappings endpoint using POST and DELETE interchangeably. Additionally, this provides a useful \"multi-delete\" feature.</p>"},{"location":"dotnet/Admin-API-Reference/#get-__adminmappingsguid","title":"<code>GET    /__admin/mappings/{guid}</code>","text":"<p>Get a single stub mapping</p>"},{"location":"dotnet/Admin-API-Reference/#put-__adminmappingsguid","title":"<code>PUT    /__admin/mappings/{guid}</code>","text":"<p>Update a single stub mapping</p> <p>Example request JavaScript<pre><code>{\n  \"Request\": {\n    \"Path\": {\n      \"Matchers\": []\n    },\n    \"Methods\": [\n      \"get\"\n    ],\n    \"Headers\": [],\n    \"Cookies\": [],\n    \"Params\": [\n      {\n        \"Name\": \"start\",\n        \"Values\": []\n      }\n    ],\n    \"Body\": {}\n  },\n  \"Response\": {\n    \"StatusCode\": 205,\n    \"BodyAsJson\": { \"msg\": \"Hello world!!\" },\n    \"BodyAsJsonIndented\": true,\n    \"UseTransformer\": true,\n    \"Headers\": {\n      \"Transformed-Postman-Token\": \"token is {{request.headers.Postman-Token}}\",\n      \"Content-Type\": \"application/json\"\n    }\n  }\n}\n</code></pre></p>"},{"location":"dotnet/Admin-API-Reference/#delete-__adminmappingsguid","title":"<code>DELETE /__admin/mappings/{guid}</code>","text":"<p>Delete a single stub mapping.</p>"},{"location":"dotnet/Admin-API-Reference/#post-__adminmappingssave","title":"<code>POST /__admin/mappings/save</code>","text":"<p>Save all persistent stub mappings to the backing store</p>"},{"location":"dotnet/Admin-API-Reference/#__adminrequests_1","title":"/__admin/requests","text":"<p>Logged requests and responses received by the mock service.</p>"},{"location":"dotnet/Admin-API-Reference/#get-__adminrequests","title":"<code>GET /__admin/requests</code>","text":"<p>Get received requests</p>"},{"location":"dotnet/Admin-API-Reference/#delete-__adminrequests","title":"<code>DELETE /__admin/requests</code>","text":"<p>Delete all received requests</p>"},{"location":"dotnet/Admin-API-Reference/#get-__adminrequestsguid","title":"<code>GET /__admin/requests/{guid}</code>","text":"<p>Get a single request.</p>"},{"location":"dotnet/Admin-API-Reference/#post-__adminrequestscount-todo","title":"<code>POST /__admin/requests/count</code> --&gt; TODO","text":""},{"location":"dotnet/Admin-API-Reference/#post-__adminrequestsfind_1","title":"<code>POST /__admin/requests/find</code>","text":"<p>Find requests based on a criteria.</p> <p>Example request: JavaScript<pre><code>{\n  \"Path\": {\n        \"Matchers\": [\n          {\n            \"Name\": \"WildcardMatcher\",\n            \"Pattern\": \"/testjson\"\n          }\n        ]\n      }\n}\n</code></pre></p>"},{"location":"dotnet/Admin-API-Reference/#get-__adminrequestsunmatched-todo","title":"<code>GET /__admin/requests/unmatched</code> --&gt; TODO","text":""},{"location":"dotnet/Admin-API-Reference/#get-__adminrequestsunmatchednear-misses-todo","title":"<code>GET /__admin/requests/unmatched/near-misses</code> --&gt; TODO","text":""},{"location":"dotnet/Compatibility-WireMock.org/","title":"Compatibility WireMock.org","text":"<p>Documentation / dotnet / Compatibility-WireMock.org</p>"},{"location":"dotnet/Compatibility-WireMock.org/#compatibility","title":"Compatibility","text":"<p>The mappings used by WireMock.net are not compatible with the Java version from WireMock.org The idea is the same, however the syntax does differ.</p> <p>See also this youtube video: https://youtu.be/IJa6DyJOxzk?t=434</p>"},{"location":"dotnet/Conflict-on-Microsoft.CodeAnalysis.CSharp/","title":"Conflict-on-Microsoft.CodeAnalysis.CSharp","text":"<p>Documentation / dotnet / Conflict-on-Microsoft.CodeAnalysis.CSharp</p>"},{"location":"dotnet/Conflict-on-Microsoft.CodeAnalysis.CSharp/#info","title":"Info","text":"<p>In case you install WireMock.Net in a project which also uses another dependency which uses <code>Microsoft.CodeAnalysis.CSharp</code>, you get an error.</p>"},{"location":"dotnet/Conflict-on-Microsoft.CodeAnalysis.CSharp/#error","title":"Error","text":"Text Only<pre><code>NU1608: Detected package version outside of dependency constraint: Microsoft.CodeAnalysis.CSharp.Workspaces 3.3.1 requires Microsoft.CodeAnalysis.CSharp (= 3.3.1) but version Microsoft.CodeAnalysis.CSharp 3.4.0 was resolved.\nNU1107: Version conflict detected for Microsoft.CodeAnalysis.Common. Install/reference Microsoft.CodeAnalysis.Common 3.4.0 directly to project ConsoleApp1x to resolve this issue. \n ConsoleApp1x -&gt; CS-Script.Core 1.3.1 -&gt; Microsoft.CodeAnalysis.Scripting.Common 3.4.0 -&gt; Microsoft.CodeAnalysis.Common (= 3.4.0) \n ConsoleApp1x -&gt; Microsoft.VisualStudio.Web.CodeGeneration.Design 3.1.1 -&gt; Microsoft.VisualStudio.Web.CodeGenerators.Mvc 3.1.1 -&gt; Microsoft.VisualStudio.Web.CodeGeneration 3.1.1 -&gt; Microsoft.VisualStudio.Web.CodeGeneration.EntityFrameworkCore 3.1.1 -&gt; Microsoft.VisualStudio.Web.CodeGeneration.Core 3.1.1 -&gt; Microsoft.VisualStudio.Web.CodeGeneration.Templating 3.1.1 -&gt; Microsoft.VisualStudio.Web.CodeGeneration.Utils 3.1.1 -&gt; Microsoft.CodeAnalysis.CSharp.Workspaces 3.3.1 -&gt; Microsoft.CodeAnalysis.Common (= 3.3.1).\nPackage restore failed. Rolling back package changes for '***'.\n</code></pre>"},{"location":"dotnet/Conflict-on-Microsoft.CodeAnalysis.CSharp/#analysis","title":"Analysis","text":"<p>The problem is that the last dependency (Microsoft.CodeAnalysis.Common) uses a different FIXED version.</p>"},{"location":"dotnet/Conflict-on-Microsoft.CodeAnalysis.CSharp/#solution","title":"Solution","text":"<p>In order to fix this, you need to find out the dependency which uses <code>Microsoft.CodeAnalysis.Common</code>, in this example it's <code>Microsoft.CodeAnalysis.CSharp.Workspaces</code>.</p> <p>So you need to reference the 3.4.0 version from <code>Microsoft.CodeAnalysis.CSharp.Workspaces</code> in your main project.</p> <p>When that's done, you can use CS-Script.Core and that other library.</p>"},{"location":"dotnet/Cors/","title":"Cors","text":"<p>Documentation / dotnet / Cors</p>"},{"location":"dotnet/Cors/#issue","title":"Issue","text":"<p>When calling WireMock.Net Server from a frontend applicatie (React / Angular), a CORS error is returned:</p> Text Only<pre><code>Cross-Origin Request Blocked: \nThe Same Origin Policy disallows reading the remote resource at http://localhost:9091/__admin/mappings.\n(Reason: CORS header \u2018Access-Control-Allow-Origin\u2019 missing). Status code: 200.\n</code></pre>"},{"location":"dotnet/Cors/#solution","title":"Solution","text":"<p>Cors support is not enabled by default, you can enable it when configuring WireMock.Net Server.</p>"},{"location":"dotnet/Cors/#option-1","title":"Option 1","text":"C#<pre><code>var settings = new WireMockServerSettings\n{\n   CorsPolicyOptions = CorsPolicyOptions.AllowAll\n};\n\nNote that these options are only available when running in .NET Core (3.1, 5.0 or higher)\n\n## Option 2\nConfigure it manually:\n\n``` c#\nvar settings = new WireMockServerSettings\n{\n   // Other settings\n};\n\n/* Enable Cors */\nvar policyName = \"MyPolicy\";\nsettings.AdditionalServiceRegistration = services =&gt;\n{\n    services.AddCors(corsOptions =&gt;\n        corsOptions.AddPolicy(policyName, // \u25c0\ufe0f MyPolicy\n            corsPolicyBuilder =&gt;\n            {\n                corsPolicyBuilder\n                    .AllowAnyHeader()\n                    .AllowAnyMethod()\n                    .AllowAnyOrigin();\n            }));\n\n    settings.Logger.Debug(\"Enable Cors\");\n};\n\n/* Use Cors */\nsettings.PreWireMockMiddlewareInit = app =&gt;\n{\n    var appBuilder = (IApplicationBuilder)app;\n    appBuilder.UseCors(policyName); // \u25c0\ufe0f MyPolicy\n\n    settings.Logger.Debug(\"Use Cors\");\n};\n\n// Start Server\nvar server = WireMockServer.Start(settings);\n</code></pre> <p>See also WireMock.Net.StandAlone.NETCoreApp/Program.cs.</p>"},{"location":"dotnet/Cors/#books-references","title":":books: References","text":"<ul> <li>https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS/Errors/CORSMissingAllowOrigin</li> <li>https://stackoverflow.com/questions/31942037/how-to-enable-cors-in-asp-net-core</li> </ul>"},{"location":"dotnet/Could-not-load-file-or-assembly-RestEase/","title":"Could not load file or assembly RestEase","text":"<p>Documentation / dotnet / Could-not-load-file-or-assembly-RestEase</p>"},{"location":"dotnet/Could-not-load-file-or-assembly-RestEase/#issue","title":"Issue","text":"<p>When creating a .NET framework console app targeting .NET 4.7.2 and referencing the WireMock.Net.RestClient NuGet you get this exception when running the application:</p> <p><code>Unhandled Exception: System.IO.FileLoadException: Could not load file or assembly 'RestEase, Version=1.4.10.0, Culture=neutral, PublicKeyToken=null' or one of its dependencies. A strongly-named assembly is required. (Exception from HRESULT: 0x80131044)</code></p> <p>This is because the WireMock.Net assemblies are signed, and RestEase is not signed.</p>"},{"location":"dotnet/Could-not-load-file-or-assembly-RestEase/#solution","title":"Solution","text":"<p>The solution is to add the NuGet Brutal.Dev.StrongNameSigner to your .NET framework console app.</p> <p>In case the WireMock.RestClient.dll is not found anymore: remove and add again the reference to the WireMock.RestClient.dll in the project after installing the Brutal.Dev.StrongNameSigner nuget.</p>"},{"location":"dotnet/Could-not-load-file-or-assembly-RestEase/#example","title":"Example","text":"<p>For a full working example, see : https://github.com/WireMock-Net/WireMock.Net/tree/master/examples/WireMock.Net.Client.Net472.</p>"},{"location":"dotnet/Development-Information/","title":"Development Information","text":"<p>Documentation / dotnet / Development-Information</p>"},{"location":"dotnet/Development-Information/#development-information","title":"Development Information","text":"<p>This page described some more details about the supported .NET frameworks and some build information.</p>"},{"location":"dotnet/Development-Information/#frameworks","title":"Frameworks","text":"<p>The following frameworks are supported: - net 4.5.1 and up (Microsoft.AspNet.WebApi.OwinSelfHost version 5.2.6) - net 4.6.1 and up (Microsoft.AspNetCore version 2.1.2) - netstandard 1.3 (Microsoft.AspNetCore version 1.1.7) - netstandard 2.0 (Microsoft.AspNetCore version 2.1.2)</p>"},{"location":"dotnet/Development-Information/#build-info","title":"Build info","text":"<p>To building on Windows you need: - Microsoft .NET Framework 4.5.1 Developer Pack - Microsoft .NET Framework 4.5.2 Developer Pack - Microsoft .NET Framework 4.6 Targeting Pack - Microsoft .NET Framework 4.6.1 Developer Pack - .NET Core 1.1 (https://www.microsoft.com/net/download/dotnet-core/1.1) - .NET Core 2.0 (https://www.microsoft.com/net/download/dotnet-core/2.0)</p> <p>To build on Linux (not tested yet...) you need: - Mono ? - .NET Core 1.1 (https://www.microsoft.com/net/download/dotnet-core/1.1) - .NET Core 2.0 (https://www.microsoft.com/net/download/dotnet-core/2.0)</p>"},{"location":"dotnet/Development-Information/#build-info-vscode","title":"Build info VSCode","text":"<p>For building and running all code in VSCode:</p> <ul> <li>download nuget.exe from https://www.nuget.org/downloads</li> <li>copy nuget.exe to a folder which is listed in the path or just in c:\\Windows</li> <li>go to the root from this project and run <code>nuget restore</code></li> <li>all packages are now restored into the <code>WireMock.Net\\packages</code> folder</li> </ul>"},{"location":"dotnet/Development-Information/#note","title":"Note","text":"<p>An example project like <code>WireMock.Net.Console.Net452.Classic</code> still shows some red errors in VSCode, but you can just run <code>dotnet build</code>. But you can just execute <code>.\\bin\\Debug\\WireMock.Net.ConsoleApplication.exe</code> to run the application</p>"},{"location":"dotnet/Development-Information/#coding-guidelines","title":"Coding Guidelines","text":"<p>todo</p>"},{"location":"dotnet/Faults/","title":"Faults","text":"<p>Documentation / dotnet / Faults</p>"},{"location":"dotnet/Faults/#faults","title":"Faults","text":"<p>WireMock.Net has some limited support for simulating random faults / corrupted responses.</p>"},{"location":"dotnet/Faults/#fault-types","title":"Fault types","text":"<p>These faults are currently supported - EMPTY_RESPONSE: Return a completely empty response. - MALFORMED_RESPONSE_CHUNK: Send an OK status header, then garbage, then close the connection.</p>"},{"location":"dotnet/Faults/#percentage","title":"Percentage","text":"<p>It's also possible to define a percentage (value between 0 and 1) when this fault should occur.</p>"},{"location":"dotnet/Faults/#examples","title":"Examples","text":""},{"location":"dotnet/Faults/#c-example","title":"C# Example","text":"C#<pre><code>var server = WireMockServer.Start();\n\nserver\n    .Given(Request.Create().WithPath(\"/fault\").UsingGet())\n    .RespondWith(Response.Create()\n        .WithStatusCode(201)\n        .WithHeader(\"Content-Type\", \"application/json\")\n        .WithBody(@\"{ \"\"result\"\": 100 }\")\n        .WithFault(FaultType.MALFORMED_RESPONSE_CHUNK, 0.5));\n</code></pre>"},{"location":"dotnet/Faults/#json-mapping-admin-interface","title":"JSON Mapping Admin interface","text":"JavaScript<pre><code>{\n    \"Guid\": \"a51b78ac-1300-4125-aa97-d48953deef77\",\n    \"Request\": {\n        \"Path\": {\n            \"Matchers\": [\n                {\n                    \"Name\": \"WildcardMatcher\",\n                    \"Pattern\": \"/fault\"\n                }\n            ]\n        }\n    },\n    \"Response\": {\n        \"StatusCode\": 201,\n        \"BodyAsJson\": {\n            \"result\": 100\n        },\n        \"Fault\": { \"Type\": \"MALFORMED_RESPONSE_CHUNK\", \"Percentage\": 0.5},\n        \"Headers\": {\n            \"Content-Type\": \"application/json\"\n        }\n    }\n}\n</code></pre>"},{"location":"dotnet/FluentAssertions/","title":"FluentAssertions","text":"<p>Documentation / dotnet / FluentAssertions</p>"},{"location":"dotnet/FluentAssertions/#fluentassertions-awesomeassertions","title":"FluentAssertions / AwesomeAssertions","text":"<p>With the NuGet Package WireMock.Net.FluentAssertions / WireMock.Net.AwesomeAssertions, it's possible to verify if certain calls are made.</p>"},{"location":"dotnet/FluentAssertions/#example","title":"Example","text":"<p>The example below checks if a specific call to an url is actually made by the HttpClient.</p> <p>C#<pre><code>[Fact]\npublic async Task AtUrl_WhenACallWasMadeToUrl_Should_BeOK()\n{\n  await _httpClient.GetAsync(\"anyurl\").ConfigureAwait(false);\n\n  _server.Should()\n    .HaveReceivedACall()\n    .AtUrl($\"http://localhost:{_portUsed}/anyurl\");\n}\n</code></pre> snippet</p>"},{"location":"dotnet/FluentAssertions/#logentries","title":"LogEntries","text":"<p>In addition to the Fluent Assertions interface, you can also get information about the calls being made to the WireMock.Net server.</p>"},{"location":"dotnet/FluentAssertions/#example_1","title":"Example","text":"<p>Use the code below in a unit-test to check if the HttpClient actually did send these specific headers.</p> <p>C#<pre><code>var sentHeaders = _server.LogEntries.SelectMany(x =&gt; x.RequestMessage.Headers)\n  .ToDictionary(x =&gt; x.Key, x =&gt; x.Value)[\"Accept\"]\n  .Select(x =&gt; $\"\\\"{x}\\\"\")\n  .ToList();\n</code></pre> snippet</p>"},{"location":"dotnet/KestrelServerOptions/","title":"KestrelServerOptions","text":"<p>Documentation / dotnet / KestrelServerOptions</p>"},{"location":"dotnet/KestrelServerOptions/#overriding-kestrelserveroptions","title":"Overriding KestrelServerOptions","text":""},{"location":"dotnet/KestrelServerOptions/#default-wiremocknet-kestrelserveroptions","title":"Default WireMock.Net KestrelServerOptions","text":"<p>These are all available Kestrel server options and you can read here all available Kestrel server options limits and their default values.</p> <p>WireMock.Net overrides some of those Kestrel server options limits, i.e.</p> <ul> <li><code>KestrelServerOptions.Limits.MaxRequestBodySize</code>: unlimited.</li> <li><code>KestrelServerOptions.Limits.MaxRequestBufferSize</code>: unlimited.</li> </ul> <p>You can check the variables that WireMock.Net overrides by default here for .NET Standard 1.3 and here for .NET Standard &gt; 1.3.</p>"},{"location":"dotnet/KestrelServerOptions/#overriding-kestrel-server-options-yourself","title":"Overriding Kestrel server options yourself","text":"<p>WireMock.Net also allows you to override those Kestrel server options and limits.</p> <p><code>KestrelServerOptions</code> can generally be overridden using a configuration provider, which expects them to follow the following structure:</p> JSON<pre><code>{\n  \"Kestrel\": {\n    \"Limits\": {\n      \"MaxRequestBodySize\": 30000000,\n      \"MaxRequestHeadersTotalSize\": 32768\n    },\n    \"DisableStringReuse\": true\n  }\n}\n</code></pre> <p>The recommended, multi-platform way of defining nested environment variables is using <code>__</code>.</p> <p>Examples:</p> <ul> <li>You can override <code>KestrelServerOptions.Limits.MaxRequestHeadersTotalSize</code> by setting <code>Kestrel__Limits__MaxRequestHeadersTotalSize</code> environment variable to 65536.</li> <li>You can override <code>KestrelServerLimits.Http2.MaxRequestHeaderFieldSize</code> by setting <code>Kestrel__Limits__Http2__MaxRequestHeaderFieldSize</code> environment variable to 16384.</li> </ul> <p>Please bear in mind that:</p> <ul> <li>Environment variable values take precedence over WireMock default overrides.</li> <li>You can only override WireMock Kestrel options using environment variables, not configuration files.</li> </ul> <p>You can find more information about Kestrel options and their configuration here.</p>"},{"location":"dotnet/Mapping/","title":"Mapping","text":"<p>Documentation / dotnet / Mapping</p>"},{"location":"dotnet/Mapping/#mapping","title":"Mapping","text":"<p>WireMock.Net is controlled by mappings which define the Request and how this should be matched. And the Response is defined; what response should be returned.</p>"},{"location":"dotnet/Mapping/#adding-or-updating-mappings","title":"Adding or updating mappings","text":"<p>Adding or updating mappings can be done via the </p> <ul> <li>REST Admin interface </li> <li>Via C# code</li> <li>Static Mappings</li> </ul>"},{"location":"dotnet/Mapping/#static-mappings","title":"Static Mappings","text":"<p>It's also possible to copy the mapping files in a folder so that these will be picked up when starting the WireMock.Net server.</p> <p>Place the .json mappings files in <code>__admin\\mappings</code> folder.</p> <p>For example, see this location.</p> <p>See also the settings for more information about how to define the settings.</p>"},{"location":"dotnet/MimeKit-and-MimeKitLite/","title":"MimeKit and MimeKitLite","text":"<p>Documentation / dotnet / MimeKit-and-MimeKitLite</p>"},{"location":"dotnet/MimeKit-and-MimeKitLite/#info","title":"Info","text":"<p>Because WireMock.Net uses MimeKitLite for multipart parsing, this can introduce errors when your project uses MimeKit:</p>"},{"location":"dotnet/MimeKit-and-MimeKitLite/#issue","title":"Issue","text":"<p><code>error CS0433: The type 'MimeMessage' exists in both 'MimeKit, Version=4.1.0.0, Culture=neutral, PublicKeyToken=bede1c8a46c66814' and 'MimeKitLite, Version=4.1.0.0, Culture=neutral, PublicKeyToken=bede1c8a46c66814'</code></p>"},{"location":"dotnet/MimeKit-and-MimeKitLite/#solution","title":"Solution","text":"<p>The only solution for this is to apply the following changes to your project:</p> XML<pre><code> &lt;PackageReference Include=\"MailKit\" Version=\"4.1.0\" /&gt;\n\n &lt;!-- \u2b50 Add an Alias for the MimeKit NuGet --&gt;\n &lt;PackageReference Include=\"MimeKit\" Version=\"4.1.0\"&gt;\n   &lt;Aliases&gt;MimeKitAlias&lt;/Aliases&gt;\n &lt;/PackageReference&gt;\n\n &lt;PackageReference Include=\"WireMock.Net\" Version=\"1.5.35\" /&gt;\n</code></pre> <p>In your C# code change this:</p> C#<pre><code>extern alias MimeKitAlias; // \u2b50 Add this\n\nnamespace MyNamespace\n{\n    public class MyClass\n    {\n        public void MyMethod()\n        {\n            var mail = new MimeKitAlias::MimeKit.MimeMessage(); // \u2b50 Use this\n        }\n    } \n}\n</code></pre> <p>The code should build now without getting the error.</p>"},{"location":"dotnet/MimeKit-and-MimeKitLite/#books-references","title":":books: References","text":"<ul> <li>https://github.com/WireMock-Net/WireMock.Net/issues/990</li> </ul>"},{"location":"dotnet/MyGet-preview-versions/","title":"MyGet preview versions","text":"<p>Documentation / dotnet / MyGet-preview-versions</p>"},{"location":"dotnet/MyGet-preview-versions/#myget","title":"MyGet","text":"<p>CI builds for <code>WireMock.Net</code> and <code>WireMock.Net.Standalone</code> are available at this feed: https://www.myget.org/F/wiremock-net/api/v3/index.json </p>"},{"location":"dotnet/MyGet-preview-versions/#configuration-in-visual-studio","title":"Configuration in Visual Studio","text":""},{"location":"dotnet/MyGet-preview-versions/#add-feed","title":"Add Feed","text":"<ol> <li>Click the wheel</li> <li>Add a new feed</li> <li>Give it a name and choose the feed (https://www.myget.org/F/wiremock-net/api/v3/index.json)</li> <li>Click update</li> </ol>"},{"location":"dotnet/MyGet-preview-versions/#use-feed-to-select-nuget","title":"Use Feed to select NuGet","text":"<p>Now you can use the preview NuGet in your application</p> <p></p> <ol> <li>Switch the feed</li> <li>Tick <code>Include prerelease</code> checkbox</li> <li>Select the version you want to use</li> </ol>"},{"location":"dotnet/Pact/","title":"Pact","text":"<p>Documentation / dotnet / Pact</p>"},{"location":"dotnet/Pact/#pactflow","title":"Pact(flow)","text":"<p>Pactflow. Contract testing for teams. Make the most of your contract testing initiative. Now you can run, maintain and fix integration issues with more ease than ever before. Pactflow is compatible with the Pact consumer driven contract testing framework and now also supports you to put your favourite tools to work with our Bi-Directional Contract Testing feature.</p> <p>https://pactflow.io/</p>"},{"location":"dotnet/Pact/#wiremocknet-support","title":"WireMock.Net support","text":"<p>WireMock.Net has some support for Pact:</p>"},{"location":"dotnet/Pact/#save-the-existing-mappings-to-a-pact-v2-json-file","title":"Save the existing mappings to a Pact V2 json file:","text":"C#<pre><code>var server = WireMockServer.Start();\nserver\n  .WithConsumer(\"Something API Consumer Get\")\n  .WithProvider(\"Something API\")\n\n  .Given(Request.Create()\n    .UsingGet()\n    .WithPath(\"/tester\")\n    .WithParam(\"q1\", \"test\")\n    .WithParam(\"q2\", \"ok\")\n    .WithHeader(\"Accept\", \"application/json\")\n  )\n  .WithTitle(\"A GET request to retrieve the something\")\n  .RespondWith(\n    Response.Create()\n      .WithStatusCode(HttpStatusCode.OK)\n      .WithHeader(\"Content-Type\", \"application/json; charset=utf-8\")\n      .WithBodyAsJson(new\n      {\n        Id = \"tester\",\n        FirstName = \"Totally\",\n        LastName = \"Awesome\"\n      })\n  );\n\nserver.SavePact(Path.Combine(\"../../../\", \"Pact\", \"files\"), \"pact-get.json\");\n</code></pre> <p>Will produce this Pact Json file: JSON<pre><code>{\n  \"Consumer\": {\n    \"Name\": \"Something API Consumer Get\"\n  },\n  \"Interactions\": [\n    {\n      \"ProviderState\": \"A GET request to retrieve the something\",\n      \"Request\": {\n        \"Headers\": {\n          \"Accept\": \"application/json\"\n        },\n        \"Method\": \"GET\",\n        \"Path\": \"/tester\",\n        \"Query\": \"q1=test&amp;q2=ok\"\n      },\n      \"Response\": {\n        \"Body\": {\n          \"Id\": \"tester\",\n          \"FirstName\": \"Totally\",\n          \"LastName\": \"Awesome\"\n        },\n        \"Headers\": {\n          \"Content-Type\": \"application/json; charset=utf-8\"\n        },\n        \"Status\": 200\n      }\n    }\n  ],\n  \"Provider\": {\n    \"Name\": \"Something API\"\n  }\n}\n</code></pre></p>"},{"location":"dotnet/Pact/#examples","title":"Examples","text":"<ul> <li>https://github.com/StefH/PactExample</li> </ul>"},{"location":"dotnet/Proxying/","title":"Proxying","text":"<p>Documentation / dotnet / Proxying</p>"},{"location":"dotnet/Proxying/#global-proxy","title":"Global Proxy","text":"<p>It's possible to start the WireMockk server in Proxy mode, this means that all requests are proxied to the real URL. And the mappings can be recorded and saved.</p>"},{"location":"dotnet/Proxying/#example","title":"Example","text":"<p>Setup a proxy to <code>samples.openweathermap.org</code></p> C#<pre><code>var settings = new WireMockServerSettings\n{\n    Urls = new[] { \"https://localhost:9095/\" },\n    StartAdminInterface = true,\n    ProxyAndRecordSettings = new ProxyAndRecordSettings\n    {\n        Url = \"https://samples.openweathermap.org\",\n        SaveMapping = true,\n        SaveMappingToFile = true,\n        SaveMappingForStatusCodePattern = \"2xx\"\n    }\n};\n\nvar server = WireMockServer.Start(settings);\n</code></pre> <p>You can now call (via an httpclient or just in browser) this URL: <code>https://localhost:9095/data/2.5/find?q=London&amp;units=metric&amp;appid=b6907d289e10d714a6e88b30761fae22</code></p> <p>See also this page for more information on the ProxyAndRecordSettings</p>"},{"location":"dotnet/Proxying/#proxy-stub-mappings","title":"Proxy stub mappings","text":"<p>Proxy responses are defined in exactly the same manner as stubs, meaning that the same request matching criteria can be used.</p> <p>The following code will proxy all GET requests made to http://:/other/service/.* to http://otherservice.com/approot, e.g. when running WireMock.NET locally a request to http://localhost:9000/other/service/doc/123 would be forwarded to http://otherservice.com/approot/other/service/doc/123. C#<pre><code>server\n  .Given(\n    Request.Create()\n      .WithPath(\"/google\")\n  )\n  .RespondWith(\n    Response.Create()\n      .WithProxy(\"http://www.google.com\")\n  );\n</code></pre> <p>The JSON equivalent would be: JavaScript<pre><code>{\n    \"Request\": {\n      \"Path\": {\n        \"Matchers\": [\n          {\n            \"Name\": \"WildcardMatcher\",\n            \"Pattern\": \"/google\"\n          }\n        ]\n      },\n      \"Methods\": [\n        \"get\"\n      ]\n    },\n    \"Response\": {\n      \"UseTransformer\": false,\n      \"ProxyUrl\": \"http://www.google.com\"\n    }\n}\n</code></pre></p>"},{"location":"dotnet/Proxying/#proxyintercept","title":"Proxy/intercept","text":"<p>The proxy/intercept pattern described above is achieved by adding a low priority proxy mapping with a broad URL match and any number of higher priority stub mappings e.g.</p> C#<pre><code>// Low priority catch-all proxies to otherhost.com by default\nserver\n  .Given(\n    Request.Create()\n      .WithPath(\"/*\")\n  )\n  .AtPriority(10)\n  .RespondWith(\n    Response.Create()\n      .WithProxy(\"http://otherhost.com\")\n  );\n\n// High priority stub will send a Service Unavailable response if the specified URL is requested:\nserver\n  .Given(\n    Request.Create()\n      .WithPath(\"/api/override/123\")\n  )\n  .AtPriority(1)\n  .RespondWith(\n    Response.Create()\n      .WithStatusCode(503)\n      .WithBody(\"ERROR\")\n  );\n</code></pre>"},{"location":"dotnet/References/","title":"References","text":"<p>Documentation / dotnet / References</p>"},{"location":"dotnet/References/#youtube-videos","title":"YouTube Videos","text":"<ul> <li>End-to-End Testing ASP.NET Core APIs (Part 2) by Hassan Habib</li> <li>Writing robust integration tests in .NET with WireMock.NET by Nick Chapsas</li> <li>Wiremock .NET - .NET Meetup Vienna Feburary 2020 by DotNetDevs Austria</li> </ul>"},{"location":"dotnet/References/#execute-automation","title":"Execute Automation","text":"<ul> <li>Execute Automation  #1 - Introduction to WireMock.NET</li> <li>Execute Automation  #2 - Initialising WireMock.NET server with GET request Stub</li> <li>Execute Automation  #3 - WireMock.NET with Multiple Headers and Stubs with different Response Types</li> <li>Execute Automation  #4 - Understanding Request Matchers in WireMock.NET</li> <li>Execute Automation  #5 - Mocking Bearer Token Authentication using WireMock.NET</li> <li>Execute Automation  #6 - Get JSON body response from WireMock.NET</li> <li>Execute Automation  #7 - WireMock.NET Admin Interface to debug tests efficiently !</li> <li>Execute Automation  #8 - Generating Static Mappings for Stubs in WireMock.NET</li> <li>Execute Automation  #9 - Running WireMock as a .NET Tool in CommandLine</li> <li>Execute Automation #10 - Understanding Proxying with WireMock.NET</li> <li>Execute Automation #11 - Excluding specific header from Proxy capture in WireMock.NET</li> </ul>"},{"location":"dotnet/References/#blog-from-bas-dijkstra","title":"Blog from Bas Dijkstra","text":"<ul> <li>API mocking in C# with WireMock.Net</li> </ul>"},{"location":"dotnet/References/#blogs-from-peter-daugaard-rasmussen","title":"Blogs from Peter Daugaard Rasmussen","text":"<ul> <li>How to get started with WireMock and stub a simple request</li> <li>a-simple-wiremock-setup</li> <li>how-to-match-a-path-with-a-wildcard-using-wiremock/</li> <li>how-to-match-a-specific-header-using-wiremock</li> <li>how-to-set-up-scenarios-with-wiremock</li> <li>How to set priority for request matching in Wiremock.Net</li> </ul>"},{"location":"dotnet/References/#blogs","title":"Blogs","text":"<ul> <li>https://code-maze.com/integration-testing-wiremock-dotnet/</li> <li>https://azurecodingarchitect.com/posts/wiremock_net/</li> <li>https://xpirit.com/real-world-mocking-http-services-testing-in-c-using-wiremock-net/</li> <li>https://dev.to/jsdevelopermano/api-mocking-with-wiremock-net-akj</li> <li>https://www.alexhyett.com/using-wiremock-net-integration-tests/</li> <li>https://ambertests.com/2018/12/13/c-advent-wiremock-net/</li> <li>https://alastaircrabtree.com/stubbing-your-way-to-automated-e2e-testing-api-first-with-wiremock/</li> <li>https://pcholko.com/posts/2021-04-05/wiremock-integration-test/</li> <li>https://angela-evans.com/wiremock-net-for-better-integration-tests/</li> <li>https://www.aschommer.de/blog/api-mocking-with-wiremocknet.html</li> <li>https://blog.imagicle.com/imagicle-open-source-gui/</li> <li>https://www.codeproject.com/Articles/5267354/How-WireMock-NET-Can-Help-in-Doing-Integration-Tes</li> <li>https://blog.stackademic.com/integration-testing-in-net-api-simulate-external-api-calls-49eb21e6f8bd</li> </ul>"},{"location":"dotnet/RegexExtended/","title":"RegexExtended","text":"<p>Documentation / dotnet / RegexExtended</p>"},{"location":"dotnet/RegexExtended/#info","title":"Info","text":"<p>The RegexMatcher can use: - RegexExtended (default) - Regex</p>"},{"location":"dotnet/RegexExtended/#regexextended","title":"RegexExtended","text":"<p>Extension to the Regex object, adding support for GUID tokens for matching on. Example: When using this <code>\\guidb</code> as regular expression, you can match on a GUID(B).</p>"},{"location":"dotnet/Request-Matcher-FormUrlEncodedMatcher/","title":"Request Matcher FormUrlEncodedMatcher","text":"<p>Documentation / dotnet / Request-Matcher-FormUrlEncodedMatcher</p>"},{"location":"dotnet/Request-Matcher-FormUrlEncodedMatcher/#formurlencodedmatcher","title":"FormUrlEncodedMatcher","text":"<p>Can be used to check if a Form Url Encoded body contains the key-value pairs.</p>"},{"location":"dotnet/Request-Matcher-FormUrlEncodedMatcher/#c-option","title":"C# option","text":"C#<pre><code>var server = WireMockServer.Start();\nserver.Given(\n    Request.Create()\n        .UsingPost()\n        .WithPath(\"/foo\")\n        .WithHeader(\"Content-Type\", \"application/x-www-form-urlencoded\")\n        .WithBody(new FormUrlEncodedMatcher([\"name=John Snow\", \"email=john_snow@example.com\"]))\n    )\n    .RespondWith(\n        Response.Create()\n    );\n</code></pre>"},{"location":"dotnet/Request-Matcher-FormUrlEncodedMatcher/#json-mapping-option","title":"JSON Mapping option","text":"JSON<pre><code>{\n  \"Request\": {\n    \"Path\": {\n      \"Matchers\": [\n        {\n          \"Name\": \"WildcardMatcher\",\n          \"Pattern\": \"/foo\"\n        }\n      ]\n    },\n    \"Methods\": [\n      \"POST\"\n    ],\n    \"Headers\": [\n      {\n        \"Name\": \"Content-Type\",\n        \"Matchers\": [\n          {\n            \"Name\": \"WildcardMatcher\",\n            \"Pattern\": \"application/x-www-form-urlencoded\",\n            \"IgnoreCase\": true\n          }\n        ]\n      }\n    ],\n    \"Body\": {\n      \"Matcher\": {\n        \"Name\": \"FormUrlEncodedMatcher\",\n        \"Patterns\": [\n           \"name=John Snow\",\n           \"email=john_snow@example.com\"\n         ],\n        \"IgnoreCase\": true\n      }\n    }\n  },\n  \"Response\": {\n    \"StatusCode\": 200\n  }\n}\n</code></pre>"},{"location":"dotnet/Request-Matcher-FormUrlEncodedMatcher/#memo-notes","title":":memo: Notes","text":"<ul> <li>You can also use <code>IgnoreCase</code></li> <li>And you can also use wildcards like: <code>name=John*</code></li> </ul>"},{"location":"dotnet/Request-Matchers/","title":"Request Matchers","text":"<p>Documentation / dotnet / Request-Matchers</p>"},{"location":"dotnet/Request-Matchers/#matchers","title":"Matchers","text":"<p>WireMock.Net supports matching of requests to stubs and verification queries using the following matchers:</p> <p>At this moment these matchers are supported: * ExactMatcher * LinqMatcher * CSharpCodeMatcher * FormUrlEncodedMatcher * GraphQLMatcher * JsonMatcher * JsonPartialMatcher * JsonPartialWildcardMatcher * JsonPathMatcher * JmesPathMatcher * MimePartMatcher * XPathMatcher * RegexMatcher * SimMetricsMatcher * WildcardMatcher * ContentTypeMatcher(\ud83d\udea7) * NotNullOrEmptyMatcher * CustomMatcher * ProtoBufMatcher</p>"},{"location":"dotnet/Request-Matchers/#exact-matcher-exactmatcher","title":"Exact matcher (ExactMatcher)","text":"<p>Can be used to exactly match a string or object.</p>"},{"location":"dotnet/Request-Matchers/#c-option","title":"C# option","text":"C#<pre><code>var server = WireMockServer.Start();\nserver\n    .Given(Request.Create().WithPath(\"/exact\")\n        .WithParam(\"from\", new ExactMatcher(\"abc\")))\n    .RespondWith(Response.Create()\n        .WithBody(\"Exact match\")\n    );\n</code></pre>"},{"location":"dotnet/Request-Matchers/#json-mapping-option","title":"JSON Mapping option","text":"JavaScript<pre><code>{\n    \"Guid\": \"67ae335b-5d79-42dc-8ca7-236280ab9111\",\n    \"Request\": {\n        \"Path\": {\n            \"Matchers\": [\n                {\n                    \"Name\": \"WildcardMatcher\",\n                    \"Pattern\": \"/exact\"\n                }\n            ]\n        },\n        \"Params\": [\n            {\n                \"Name\": \"from\",\n                \"Matchers\": [\n                    {\n                        \"Name\": \"ExactMatcher\",\n                        \"Pattern\": \"abc\"\n                    }\n                ]\n            }\n        ]\n    },\n    \"Response\": {\n        \"Body\": \"Exact match\"\n    }\n}\n</code></pre>"},{"location":"dotnet/Request-Matchers/#dynamic-linq-linqmatcher","title":"Dynamic Linq (LinqMatcher)","text":"<p>Can be used to match an object using Dynamic Linq (https://github.com/StefH/System.Linq.Dynamic.Core)</p>"},{"location":"dotnet/Request-Matchers/#c-option_1","title":"C# option","text":"C#<pre><code>var server = WireMockServer.Start();\nserver\n    .Given(Request.Create().WithPath(\"/linq\")\n        .WithParam(\"from\", new LinqMatcher(\"DateTime.Parse(it) &gt; \\\"2018-03-01 00:00:00\\\"\")))\n    .RespondWith(Response.Create()\n        .WithBody(\"linq match !!!\")\n    );\n</code></pre>"},{"location":"dotnet/Request-Matchers/#json-mapping-option_1","title":"JSON Mapping option","text":"JavaScript<pre><code>{\n    \"Guid\": \"67ae335b-5d79-42dc-8ca7-236280ab91ec\",\n    \"Priority\": 0,\n    \"Request\": {\n        \"Path\": {\n            \"Matchers\": [\n                {\n                    \"Name\": \"WildcardMatcher\",\n                    \"Pattern\": \"/linq\"\n                }\n            ]\n        },\n        \"Params\": [\n            {\n                \"Name\": \"from\",\n                \"Matchers\": [\n                    {\n                        \"Name\": \"LinqMatcher\",\n                        \"Pattern\": \"DateTime.Parse(it) &gt; \\\"2018-03-01 00:00:00\\\"\"\n                    }\n                ]\n            }\n        ],\n        \"Body\": {}\n    },\n    \"Response\": {\n        \"Body\": \"linq match !!!\"\n    }\n}\n</code></pre>"},{"location":"dotnet/Request-Matchers/#json-mapping","title":"JSON Mapping","text":"JavaScript<pre><code>{\n    \"Guid\": \"55a600b8-9d6f-453f-90c6-3db2b0885ddb\",\n    \"Request\": {\n        \"Path\": {\n            \"Matchers\": [\n                {\n                    \"Name\": \"WildcardMatcher\",\n                    \"Pattern\": \"/jmespath_example\",\n                    \"IgnoreCase\": false\n                }\n            ]\n        },\n        \"Methods\": [\n            \"put\"\n        ],\n        \"Body\": {\n            \"Matcher\": {\n                \"Name\": \"JmesPathMatcher\",\n                \"Pattern\": \"things.name == 'RequiredThing'\"\n            }\n        }\n    },\n    \"Response\": {\n        \"StatusCode\": 200,\n        \"Body\": \"{ \\\"result\\\": \\\"JmesPathMatcher !!!\\\"}\",\n        \"UseTransformer\": false\n    }\n}\n</code></pre> Text Only<pre><code>// matching\n{ \"things\": { \"name\": \"RequiredThing\" } }\n{ \"things\": [ { \"name\": \"RequiredThing\" }, { \"name\": \"Wiremock\" } ] }\n// not matching\n{ \"price\": 15 }\n{ \"things\": { \"name\": \"Wiremock\" } }\n</code></pre>"},{"location":"dotnet/Request-Matchers/#jmes-path-jmespathmatcher","title":"Jmes Path (JmesPathMatcher)","text":"<p>The JMESPath language is described in an ABNF grammar with a complete specification. A JSON body will be considered to match a path expression if the expression returns either a non-null single value (string, integer etc.), or a non-empty object or array.</p>"},{"location":"dotnet/Request-Matchers/#c","title":"C","text":"C#<pre><code>var server = WireMockServer.Start();\nserver\n  .Given(\n    Request.Create().WithPath(\"/jmespath_example\").UsingGet()\n      .WithBody(new JmesPathMatcher(\"things.name == 'RequiredThing\"));\n  )\n  .RespondWith(Response.Create().WithBody(\"Hello\"));\n</code></pre>"},{"location":"dotnet/Request-Matchers/#xpathmatcher","title":"XPathMatcher","text":"<p>Deems a match if the attribute value is valid XML and matches the XPath expression supplied. An XML document will be considered to match if any elements are returned by the XPath evaluation. WireMock delegates to XPath2.Net, therefore it support up to XPath version 2.0.</p>"},{"location":"dotnet/Request-Matchers/#c_1","title":"C","text":"C#<pre><code>var server = WireMockServer.Start();\nserver\n    .Given(Request.Create()\n        .WithPath(\"/xpath\").UsingPost()\n        .WithBody(new XPathMatcher(\"/todo-list[count(todo-item) = 3]\"))\n    )\n    .RespondWith(Response.Create().WithBody(\"XPathMatcher!\"));\n</code></pre>"},{"location":"dotnet/Request-Matchers/#json-mapping_1","title":"JSON Mapping","text":"JavaScript<pre><code>{\n    \"Guid\": \"abc5848e-cedd-42ad-8f58-4ba6df01180f\",\n    \"Priority\": 0,\n    \"Request\": {\n        \"Path\": {\n            \"Matchers\": [\n                {\n                    \"Name\": \"WildcardMatcher\",\n                    \"Pattern\": \"/xpath\",\n                    \"IgnoreCase\": false\n                }\n            ]\n        },\n        \"Methods\": [\n            \"post\"\n        ],\n        \"Body\": {\n            \"Matcher\": {\n                \"Name\": \"XPathMatcher\",\n                \"Pattern\": \"/todo-list[count(todo-item) = 3]\"\n            }\n        }\n    },\n    \"Response\": {\n        \"StatusCode\": 200,\n        \"BodyDestination\": \"SameAsSource\",\n        \"Body\": \"XPathMatcher!\",\n        \"UseTransformer\": false\n    }\n}\n</code></pre> <p>Will match xml below: XML<pre><code>&lt;todo-list&gt;\n  &lt;todo-item id='a1'&gt;abc&lt;/todo-item&gt;\n  &lt;todo-item id='a2'&gt;def&lt;/todo-item&gt;\n  &lt;todo-item id='a3'&gt;xyz&lt;/todo-item&gt;\n&lt;/todo-list&gt;\n</code></pre></p>"},{"location":"dotnet/Request-Matchers/#regular-expression-matching-regexmatcher","title":"Regular Expression Matching (RegexMatcher)","text":"<p>The RegexMatcher can be used to match using a regular expression.</p> C#<pre><code>var server = WireMockServer.Start();\nserver\n  .Given(\n    Request.Create().WithPath(\"/reg\").UsingPost()\n      .WithBody(new RegexMatcher(\"H.*o\"));\n  )\n  .RespondWith(Response.Create().WithBody(\"Hello matched with RegexMatcher\"));\n</code></pre> Text Only<pre><code>// matching\nHello World\n\n// not matching\nHi WM\n</code></pre>"},{"location":"dotnet/Request-Matchers/#similarity-metric-matching-simmetricsmatcher","title":"Similarity Metric Matching (SimMetricsMatcher)","text":"<p>SimMetrics.Net is used as a Similarity Metric Library, e.g. from edit distance's (Levenshtein, Gotoh, Jaro etc) to other metrics, (e.g Soundex, Chapman).</p> C#<pre><code>var server = WireMockServer.Start();\nserver\n  .Given(\n    Request.Create().WithPath(\"/reg\").UsingGet()\n      .WithBody(new SimMetricsMatcher(\"The cat walks in the street.\"));\n  )\n  .RespondWith(Response.Create().WithBody(\"Matched with SimMetricsMatcher\"));\n</code></pre> Text Only<pre><code>// matching with distance 0.793\nThe car drives in the street.\n\n// matching with distance 0.071\nHello\n</code></pre>"},{"location":"dotnet/Request-Matchers/#wildcardmatching-wildcardmatcher","title":"WildcardMatching (WildcardMatcher)","text":"<p>WildcardMatching is mostly used for Path and Url matching. This matcher allows a ? for a single character and * for any characters.</p>"},{"location":"dotnet/Request-Matchers/#option-1","title":"Option 1","text":"C#<pre><code>var server = WireMockServer.Start();\nserver\n  .Given(Request.Create().WithPath(\"/some*\").UsingGet())\n  .RespondWith(Response.Create().WithBody(\"Hello\"));\n</code></pre>"},{"location":"dotnet/Request-Matchers/#option-2","title":"Option 2","text":"C#<pre><code>var server = FluentMockServer.Start();\nserver\n  .Given(\n    Request.Create().WithPath(\"/wc\").UsingGet()\n      .WithBody(new WildcardMatcher(\"x.\"));\n  )\n  .RespondWith(Response.Create().WithBody(\"Matched with *\"));\n</code></pre>"},{"location":"dotnet/Request-Matchers/#notnulloremptymatcher","title":"NotNullOrEmptyMatcher","text":"<p>NotNullOrEmptyMatcher is used for Body matching. This matcher will return a match of the body is not null (BodyAsBytes, BodyAsJson, BodyAsString) or empty (BodyAsBytes, BodyAsString).</p>"},{"location":"dotnet/Request-Matchers/#custommatcher","title":"CustomMatcher","text":"<p>It's also possible to use a custom mapper with your own name.</p>"},{"location":"dotnet/Request-Matchers/#json-mapping-option_2","title":"JSON Mapping Option","text":"JavaScript<pre><code>{\n    \"Guid\": \"67ae335b-5d79-42dc-8ca7-236280ab9211\",\n    \"Priority\": 0,\n    \"Request\": {\n        \"Path\": {\n            \"Matchers\": [\n                {\n                    \"Name\": \"MyCustomMatcher\",\n                    \"Pattern\": \"abc\"\n                }\n            ]\n        }\n        \"Body\": {}\n    },\n    \"Response\": {\n        \"Body\": \"custom match\"\n    }\n}\n</code></pre>"},{"location":"dotnet/Request-Matchers/#reversing-the-match-behaviour-with-matchbehaviourrejectonmatch","title":"Reversing the match behaviour with <code>MatchBehaviour.RejectOnMatch</code>","text":"<p>The default behaviour for Matchers is MatchBehaviour.AcceptOnMatch so that when the matcher processes a request that corresponds with the matcher, the stubbed response is returned. In some scenarios you might want to reverse this behaviour so that the stubbed response is returned with the absence of a match.</p> <p>e.g. You want to return <code>401 Unauthorised</code> if the caller does not provide a header containing the API Key:</p> C#<pre><code>server\n   .Given(Request.Create()\n             .WithPath(\"/needs-a-key\")\n             .UsingGet()\n             .WithHeader(\"api-key\", \"*\", MatchBehaviour.RejectOnMatch)\n             .UsingAnyMethod())\n   .RespondWith(Response.Create()\n             .WithStatusCode(HttpStatusCode.Unauthorized)\n             .WithBody(@\"{ \"\"result\"\": \"\"api-key missing\"\"}\"));\n</code></pre> <p>A JSON Mapping example looks like: JSON<pre><code>{\n  \"Guid\": \"29971ff8-4adb-4ec7-8b7d-a2ce6e5ca630\",\n  \"Request\": {\n    \"Path\": {\n      \"Matchers\": [\n        {\n          \"Name\": \"WildcardMatcher\",\n          \"Pattern\": \"/needs-a-key\"\n        }\n      ]\n    },\n    \"Headers\": [\n      {\n        \"Name\": \"api-key\",\n        \"Matchers\": [\n          {\n            \"Name\": \"WildcardMatcher\",\n            \"Pattern\": \"*\",\n            \"IgnoreCase\": true,\n            \"RejectOnMatch\": true\n          }\n        ]\n      }\n    ]\n  },\n  \"Response\": {\n    \"StatusCode\": 401,\n    \"BodyDestination\": \"SameAsSource\",\n    \"Body\": \"{ \\\"result\\\": \\\"api-key missing\\\"}\",\n    \"Headers\": {}\n  }\n}\n</code></pre></p>"},{"location":"dotnet/Request-Matching-CSharpCode/","title":"Request Matching CSharpCode","text":"<p>Documentation / dotnet / Request-Matching-CSharpCode</p>"},{"location":"dotnet/Request-Matching-CSharpCode/#csharp-code-csharpcodematcher","title":"CSharp Code (CSharpCodeMatcher)","text":"<p>Advanced! With this matcher you can use complex C# code to match an JObject or string value. * You need to include the NuGet package WireMock.Net.Matchers.CSharpCode * Note that this functionality will only work if enabled in the settings (<code>AllowCSharpCodeMatcher = true</code>). * The argument-name from the string or JObject to match will be <code>it</code>.</p>"},{"location":"dotnet/Request-Matching-CSharpCode/#c-option","title":"C# option","text":"C#<pre><code>var server = WireMockServer.Start();\nserver\n    .Given(Request.Create().WithPath(\"/cs\")\n        .WithParam(\"from\", new CSharpCodeMatcher(\"return it == \\\"x\\\";\")))\n    .RespondWith(Response.Create()\n        .WithBody(\"cs match\")\n    );\n</code></pre>"},{"location":"dotnet/Request-Matching-CSharpCode/#json-mapping-option","title":"JSON Mapping option","text":"JavaScript<pre><code>{\n    \"Guid\": \"67ae335b-5d79-42dc-8ca7-236280ab9211\",\n    \"Priority\": 0,\n    \"Request\": {\n        \"Path\": {\n            \"Matchers\": [\n                {\n                    \"Name\": \"WildcardMatcher\",\n                    \"Pattern\": \"/cs\"\n                }\n            ]\n        },\n        \"Params\": [\n            {\n                \"Name\": \"from\",\n                \"Matchers\": [\n                    {\n                        \"Name\": \"CSharpCodeMatcher\",\n                        \"Pattern\": \"return it == \\\"x\\\";\"\n                    }\n                ]\n            }\n        ],\n        \"Body\": {}\n    },\n    \"Response\": {\n        \"Body\": \"cs match\"\n    }\n}\n</code></pre>"},{"location":"dotnet/Request-Matching-GraphQLMatcher/","title":"Request Matching GraphQLMatcher","text":"<p>Documentation / dotnet / Request-Matching-GraphQLMatcher</p>"},{"location":"dotnet/Request-Matching-GraphQLMatcher/#graphql-schema-graphqlmatcher","title":"GraphQL Schema (GraphQLMatcher)","text":"<p>Can be used to match a GraphQL <code>Query</code> using GraphQL Schema (<code>Mutation</code> is not yet supported I think...)</p>"},{"location":"dotnet/Request-Matching-GraphQLMatcher/#define-a-mappings-which-include-a-graphql-schema-which-should-be-used-for-matching-that-body","title":"Define a mappings which include a GraphQL Schema which should be used for matching that body:","text":""},{"location":"dotnet/Request-Matching-GraphQLMatcher/#c","title":"C","text":"C#<pre><code>private const string TestSchemaQueryStudents =\n    \"\"\"\n    type Query {\n        students:[Student]\n    }\n\n    type Student {\n        id:ID!\n        firstName:String\n        lastName:String\n        fullName:String \n    }\n    \"\"\";\n\nprivate const string TestSchemaQueryStudentById =\n    \"\"\"\n    type Query {\n        studentById(id:ID!):Student\n    }\n\n    type Student {\n        id:ID!\n        firstName:String\n        lastName:String\n        fullName:String \n    }\n    \"\"\";\n\nvar server = WireMockServer.Start();\nserver\n    .Given(Request.Create()\n        .WithPath(\"/graphql\")\n        .UsingPost()\n        .WithGraphQLSchema(TestSchemaQueryStudents)\n    )\n    .RespondWith(Response.Create()\n        .WithHeader(\"Content-Type\", \"application/json\")\n        .WithBody(\n            \"\"\"\n            {\n              \"data\": {\n                \"students\": [\n                  {\n                    \"id\": \"1\",\n                    \"firstName\": \"Alice\",\n                    \"lastName\": \"Johnson\",\n                    \"fullName\": \"Alice Johnson\"\n                  },\n                  {\n                    \"id\": \"2\",\n                    \"firstName\": \"Bob\",\n                    \"lastName\": \"Smith\",\n                    \"fullName\": \"Bob Smith\"\n                  }\n                ]\n              }\n            }\n            \"\"\")\n    );\n\nserver\n    .Given(Request.Create()\n        .WithPath(\"/graphql\")\n        .UsingPost()\n        .WithGraphQLSchema(TestSchemaQueryStudentById)\n        .WithBody(new JsonPartialWildcardMatcher(\"{ \\\"variables\\\": { \\\"sid\\\": \\\"1\\\" } }\"))\n    )\n    .WithTitle(\"Student found\")\n    .RespondWith(Response.Create()\n        .WithHeader(\"Content-Type\", \"application/json\")\n        .WithBody(\n            \"\"\"\n            {\n              \"data\": {\n                \"studentById\": {\n                  \"id\": \"123\",\n                  \"firstName\": \"John\",\n                  \"lastName\": \"Doe\",\n                  \"fullName\": \"John Doe\"\n                }\n              }\n            }\n            \"\"\")\n    );\n\nserver\n    .Given(Request.Create()\n        .WithPath(\"/graphql\")\n        .UsingPost()\n        .WithGraphQLSchema(TestSchemaQueryStudentById)\n    )\n    .WithTitle(\"Student not found\")\n    .RespondWith(Response.Create()\n        .WithHeader(\"Content-Type\", \"application/json\")\n        .WithBody(\n            \"\"\"\n            {\n              \"data\": null\n            }\n            \"\"\")\n    );\n</code></pre>"},{"location":"dotnet/Request-Matching-GraphQLMatcher/#use-test","title":"Use / Test","text":"<p>When WireMock.Net is started (see above) with that GraphQL Schema, a client can send GraphQL:</p>"},{"location":"dotnet/Request-Matching-GraphQLMatcher/#query-students","title":"Query Students","text":""},{"location":"dotnet/Request-Matching-GraphQLMatcher/#request","title":"Request","text":"Text Only<pre><code>curl --location 'http://localhost:9091/graphql' \\\n--header 'Content-Type: application/json' \\\n--data '{\"query\":\"{\\r\\n  students {\\r\\n    fullName\\r\\n    id\\r\\n  }\\r\\n}\",\"variables\":{}}'\n</code></pre>"},{"location":"dotnet/Request-Matching-GraphQLMatcher/#response","title":"Response","text":"JSON<pre><code>{\n    \"data\": {\n        \"students\": [\n            {\n                \"id\": \"1\",\n                \"firstName\": \"Alice\",\n                \"lastName\": \"Johnson\",\n                \"fullName\": \"Alice Johnson\"\n            },\n            {\n                \"id\": \"2\",\n                \"firstName\": \"Bob\",\n                \"lastName\": \"Smith\",\n                \"fullName\": \"Bob Smith\"\n            }\n        ]\n    }\n}\n</code></pre>"},{"location":"dotnet/Request-Matching-GraphQLMatcher/#query-student-by-id","title":"Query Student by Id","text":""},{"location":"dotnet/Request-Matching-GraphQLMatcher/#request_1","title":"Request","text":"Text Only<pre><code>curl --location 'http://localhost:9091/graphql' \\\n--header 'Content-Type: application/json' \\\n--data '{\"query\":\"query ($sid: ID!)\\r\\n{\\r\\n  studentById(id: $sid) {\\r\\n    fullName\\r\\n    id\\r\\n  }\\r\\n}\",\"variables\":{\"sid\":\"1\"}}'\n</code></pre>"},{"location":"dotnet/Request-Matching-GraphQLMatcher/#response_1","title":"Response","text":"JSON<pre><code>{\n    \"data\": {\n        \"studentById\": {\n            \"id\": \"123\",\n            \"firstName\": \"John\",\n            \"lastName\": \"Doe\",\n            \"fullName\": \"John Doe\"\n        }\n    }\n}\n</code></pre>"},{"location":"dotnet/Request-Matching-JsonMatcher/","title":"Request Matching JsonMatcher","text":"<p>Documentation / dotnet / Request-Matching-JsonMatcher</p>"},{"location":"dotnet/Request-Matching-JsonMatcher/#json-jsonmatcher","title":"JSON (JsonMatcher)","text":"<p>Checks if a JSON object (or JSON as string) is DeepEqual.</p>"},{"location":"dotnet/Request-Matching-JsonMatcher/#c-option-1","title":"C# option 1","text":"C#<pre><code>var server = WireMockServer.Start();\nserver\n    .Given(Request\n    .Create()\n    .WithPath(\"/jsonmatcher1\")\n    .WithBody(new JsonMatcher(\"{ \\\"x\\\": 42, \\\"s\\\": \\\"s\\\" }\"))\n    .UsingPost())\n    .WithGuid(\"debaf408-3b23-4c04-9d18-ef1c020e79f2\")\n    .RespondWith(Response.Create().WithBody(@\"{ \"\"result\"\": \"\"jsonbodytest1\"\" }\"));\n</code></pre>"},{"location":"dotnet/Request-Matching-JsonMatcher/#json-mapping-option-1","title":"JSON Mapping option 1","text":"JavaScript<pre><code>{\n    \"Guid\": \"debaf408-3b23-4c04-9d18-ef1c020e79f2\",\n    \"Request\": {\n        \"Path\": {\n            \"Matchers\": [\n                {\n                    \"Name\": \"JsonMatcher\",\n                    \"Pattern\": \"/jsonmatcher1\"\n                }\n            ]\n        },\n        \"Methods\": [\n            \"post\"\n        ],\n        \"Body\": {\n            \"Matcher\": {\n                \"Name\": \"JsonMatcher\",\n                \"Pattern\": \"{ \\\"x\\\": 42, \\\"s\\\": \\\"s\\\" }\"\n            }\n        }\n    },\n    \"Response\": {\n        \"StatusCode\": 200,\n        \"Body\": \"{ \\\"result\\\": \\\"jsonbodytest\\\" }\",\n        \"UseTransformer\": false\n    }\n}\n</code></pre>"},{"location":"dotnet/Request-Matching-JsonMatcher/#c-option-2","title":"C# option 2","text":"C#<pre><code>var server = WireMockServer.Start();\nserver\n    .Given(Request\n    .Create()\n    .WithPath(\"/jsonmatcher2\")\n    .WithBody(new JsonMatcher(new { x = 42, s = \"s\" }))\n    .UsingPost())\n    .WithGuid(\"debaf408-3b23-4c04-9d18-ef1c020e79f2\")\n    .RespondWith(Response.Create().WithBody(@\"{ \"\"result\"\": \"\"jsonbodytest2\"\" }\"));\n</code></pre>"},{"location":"dotnet/Request-Matching-JsonMatcher/#json-mapping-option-2","title":"JSON Mapping option 2","text":"JavaScript<pre><code>{\n    \"Guid\": \"debaf408-3b23-4c04-9d18-ef1c020e79f2\",\n    \"Request\": {\n        \"Path\": {\n            \"Matchers\": [\n                {\n                    \"Name\": \"JsonMatcher\",\n                    \"Pattern\": \"/jsonmatcher2\"\n                }\n            ]\n        },\n        \"Methods\": [\n            \"post\"\n        ],\n        \"Body\": {\n            \"Matcher\": {\n                \"Name\": \"JsonMatcher\",\n                \"Pattern\": { \"x\": 42, \"s\": \"s\" }\n            }\n        }\n    },\n    \"Response\": {\n        \"StatusCode\": 200,\n        \"Body\": \"{ \\\"result\\\": \\\"jsonbodytest2\\\" }\",\n        \"UseTransformer\": false\n    }\n}\n</code></pre> Text Only<pre><code>// matching\n{ \"x\": 42, \"s\": \"s\" }\n\n// not matching\n{ \"x\": 42, \"s\": \"?\" }\n</code></pre>"},{"location":"dotnet/Request-Matching-JsonMatcher/#c-option-3","title":"C# option 3","text":"<p>It's also possible to use set <code>IgnoreCase</code> to true, this means that the PropertNames and PropertyValues will be matced regarding any case. C#<pre><code>var server = WireMockServer.Start();\nserver\n    .Given(Request\n    .Create()\n    .WithPath(\"/jsonmatcher3\")\n    .WithBody(new JsonMatcher(\"{ \\\"x\\\": 42, \\\"s\\\": \\\"s\\\" }\"), true)\n    .UsingPost())\n    .WithGuid(\"debaf408-3b23-4c04-9d18-ef1c020e79f2\")\n    .RespondWith(Response.Create().WithBody(@\"{ \"\"result\"\": \"\"jsonmatcher3 ok\"\" }\"));\n</code></pre></p>"},{"location":"dotnet/Request-Matching-JsonMatcher/#json-mapping-option-3","title":"JSON Mapping option 3","text":"JavaScript<pre><code>{\n    \"Guid\": \"debaf408-3b23-4c04-9d18-ef1c020e79f2\",\n    \"Request\": {\n        \"Path\": {\n            \"Matchers\": [\n                {\n                    \"Name\": \"WildcardMatcher\",\n                    \"Pattern\": \"/jsonmatcher1\"\n                }\n            ]\n        },\n        \"Methods\": [\n            \"post\"\n        ],\n        \"Body\": {\n            \"Matcher\": {\n                \"Name\": \"JsonMatcher\",\n                \"IgnoreCase\": true,\n                \"Pattern\": \"{ \\\"x\\\": 42, \\\"s\\\": \\\"s\\\" }\"\n            }\n        }\n    },\n    \"Response\": {\n        \"StatusCode\": 200,\n        \"Body\": \"{ \\\"result\\\": \\\"jsonmatcher3 ok\\\" }\",\n        \"UseTransformer\": false\n    }\n}\n</code></pre> Text Only<pre><code>// matching\n{ \"X\": 42, \"s\": \"S\" }\n</code></pre>"},{"location":"dotnet/Request-Matching-JsonPartialMatcher/","title":"Request Matching JsonPartialMatcher","text":"<p>Documentation / dotnet / Request-Matching-JsonPartialMatcher</p>"},{"location":"dotnet/Request-Matching-JsonPartialMatcher/#json-jsonpartialmatcher","title":"JSON (JsonPartialMatcher)","text":"<p>Checks if a JSON object has a partial match. Example: Matcher value  <code>{\"test\":\"abc\"}</code> against input <code>{\"test\":\"abc\",\"other\":\"xyz\"}</code> is matched by this JsonPartialMatcher.</p>"},{"location":"dotnet/Request-Matching-JsonPartialMatcher/#c-option-1","title":"C# option 1","text":"C#<pre><code>var server = WireMockServer.Start();\nserver\n  .Given(Request\n    .Create()\n      .WithPath(\"/jsonpartialmatcher1\")\n      .WithBody(new JsonPartialMatcher(\"{ \\\"test\\\": \\\"abc\\\" }\"))\n      .UsingPost())\n  .WithGuid(\"debaf408-3b23-4c04-9d18-ef1c020e79f2\")\n  .RespondWith(Response.Create().WithBody(@\"{ \"\"result\"\": \"\"jsonpartialbodytest1\"\" }\"));\n</code></pre>"},{"location":"dotnet/Request-Matching-JsonPartialMatcher/#json-mapping-option-1","title":"JSON Mapping option 1","text":"JSON<pre><code>{\n    \"Guid\": \"debaf408-3b23-4c04-9d18-ef1c020e79f2\",\n    \"Request\": {\n        \"Path\": {\n            \"Matchers\": [\n                {\n                    \"Name\": \"WildcardMatcher\",\n                    \"Pattern\": \"/jsonpartialmatcher1\"\n                }\n            ]\n        },\n        \"Methods\": [\n            \"post\"\n        ],\n        \"Body\": {\n            \"Matcher\": {\n                \"Name\": \"JsonPartialMatcher\",\n                \"Pattern\": \"{ \\\"test\\\": \\\"abc\\\" }\"\n            }\n        }\n    },\n    \"Response\": {\n        \"StatusCode\": 200,\n        \"Body\": \"{ \\\"result\\\": \\\"jsonpartialbodytest1\\\" }\",\n        \"UseTransformer\": false\n    }\n}\n</code></pre> JavaScript<pre><code>// matching\n{ \"test\": \"abc\" }\n\n// also matching\n{ \"test\": \"abc\", \"extra\": \"?\" }\n</code></pre>"},{"location":"dotnet/Request-Matching-JsonPartialMatcher/#ignorecase","title":"IgnoreCase","text":"<p>It's also possible to use set <code>IgnoreCase</code> to true, this means that the PropertNames and PropertyValues will be matched regarding any case. Same logic as the normal JsonMatcher.</p>"},{"location":"dotnet/Request-Matching-JsonPartialMatcher/#use-regex","title":"Use Regex","text":"<p>It's possible to add a property <code>Regex</code> with the value <code>true</code>, with this option set, PropertyValues are matched using a specified regular expression.</p> <p>Example for C# when you want to match the <code>id</code> for any number. C#<pre><code>var server = WireMockServer.Start();\nserver\n  .Given(Request\n    .Create()\n      .WithPath(\"/jsonpartialmatcher1\")\n      .WithBody(new JsonPartialMatcher(\"{ \\\"id\\\": \\\"^\\\\d+$\\\" }\", false, false, true))\n      .UsingPost())\n  .WithGuid(\"debaf408-3b23-4c04-9d18-ef1c020e79f2\")\n  .RespondWith(Response.Create().WithBody(@\"{ \"\"result\"\": \"\"jsonpartialbodytest1\"\" }\"));\n</code></pre></p> <p>Or in JSON mapping: JSON<pre><code>{\n    \"Guid\": \"debaf408-3b23-4c04-9d18-ef1c020e79f2\",\n    \"Request\": {\n      \"Methods\": [\n          \"post\"\n      ],\n     \"Body\": {\n       \"Matcher\": {\n        \"Name\": \"JsonPartialWildcardMatcher\",\n        \"Regex\": true, // &lt;--- add this property\n        \"Pattern\": {\n          \"applicationId\": \"*\",\n          \"currency\": \"EUR\",\n          \"price\": \"^\\\\d*$\", // &lt;--- use regex\n          \"externalId\": \"*\",\n          \"transactionDescription\": \"*\",\n        },\n        \"IgnoreCase\": false\n      }\n    }\n    },\n    \"Response\": {\n        \"StatusCode\": 200,\n        \"Body\": \"{ \\\"result\\\": \\\"jsonpartialbodytest1-with-regex\\\" }\",\n        \"UseTransformer\": false\n    }\n}\n</code></pre></p>"},{"location":"dotnet/Request-Matching-JsonPartialWildcardMatcher/","title":"Request Matching JsonPartialWildcardMatcher","text":"<p>Documentation / dotnet / Request-Matching-JsonPartialWildcardMatcher</p>"},{"location":"dotnet/Request-Matching-JsonPartialWildcardMatcher/#json-jsonpartialwildcardmatcher","title":"JSON (JsonPartialWildcardMatcher)","text":"<p>Based on JsonPartialMatcher but with wildcard (<code>*</code>) support.</p> <p>Example: Matcher value  <code>{\"test\":\"*\"}</code> matches input <code>{\"test\":\"abc\" }</code>, but also input <code>{\"test\":\"test\" }</code> is matched.</p>"},{"location":"dotnet/Request-Matching-JsonPartialWildcardMatcher/#c-option-1","title":"C# option 1","text":"C#<pre><code>var server = WireMockServer.Start();\nserver\n    .Given(Request\n    .Create()\n    .WithPath(\"/jsonpartialmatcher1\")\n    .WithBody(new JsonPartialWildcardMatcher(\"{ \\\"test\\\": \\\"*\\\" }\"))\n    .UsingPost())\n    .WithGuid(\"debaf408-3b23-4c04-9d18-ef1c020e79f2\")\n    .RespondWith(Response.Create().WithBody(@\"{ \"\"result\"\": \"\"jsonpartialbodytest1\"\" }\"));\n</code></pre>"},{"location":"dotnet/Request-Matching-JsonPartialWildcardMatcher/#json-mapping-option-1","title":"JSON Mapping option 1","text":"JavaScript<pre><code>{\n    \"Guid\": \"debaf408-3b23-4c04-9d18-ef1c020e79f2\",\n    \"Request\": {\n        \"Path\": {\n            \"Matchers\": [\n                {\n                    \"Name\": \"WilcardMatcher\",\n                    \"Pattern\": \"/jsonpartialmatcher1\"\n                }\n            ]\n        },\n        \"Methods\": [\n            \"post\"\n        ],\n        \"Body\": {\n            \"Matcher\": {\n                \"Name\": \"JsonPartialWildcardMatcher\",\n                \"Pattern\": \"{ \\\"test\\\": \\\"*\\\" }\"\n            }\n        }\n    },\n    \"Response\": {\n        \"StatusCode\": 200,\n        \"Body\": \"{ \\\"result\\\": \\\"jsonpartialbodytest1\\\" }\",\n        \"UseTransformer\": false\n    }\n}\n</code></pre> JavaScript<pre><code>// matching\n{ \"test\": \"abc\" }\n\n// also matching\n{ \"test\": \"test\" }\n\n// and also matching\n{ \"test\": \"abc\", \"extra\": \"?\" }\n</code></pre>"},{"location":"dotnet/Request-Matching-JsonPartialWildcardMatcher/#ignorecase","title":"IgnoreCase","text":"<p>It's also possible to use set <code>IgnoreCase</code> to true, this means that the PropertNames and PropertyValues will be matched regarding any case. Same logic as the normal JsonMatcher.</p>"},{"location":"dotnet/Request-Matching-JsonPartialWildcardMatcher/#notes","title":"Notes","text":"<ul> <li>For now it's only possible to use this matcher to match on string-values.</li> </ul>"},{"location":"dotnet/Request-Matching-JsonPathMatcher/","title":"Request Matching JsonPathMatcher","text":"<p>Documentation / dotnet / Request-Matching-JsonPathMatcher</p>"},{"location":"dotnet/Request-Matching-JsonPathMatcher/#json-path-jsonpathmatcher","title":"JSON Path (JsonPathMatcher)","text":"<p>Deems a match if the attribute value is valid JSON and matches the JSON Path expression supplied. A JSON body will be considered to match a path expression if the expression returns either a non-null single value (string, integer etc.), or a non-empty object or array.</p>"},{"location":"dotnet/Request-Matching-JsonPathMatcher/#c","title":"C","text":"C#<pre><code>var server = WireMockServer.Start();\nserver\n  .Given(\n    Request.Create().WithPath(\"/some/thing\").UsingGet()\n      .WithBody(new JsonPathMatcher(\"$.things[?(@.name == 'RequiredThing')]\"));\n  )\n  .RespondWith(Response.Create().WithBody(\"Hello\"));\n</code></pre>"},{"location":"dotnet/Request-Matching-JsonPathMatcher/#json-mapping","title":"JSON Mapping","text":"JavaScript<pre><code>{\n    \"Guid\": \"e4a600b8-9d6f-453f-90c6-3db2b0885ddb\",\n    \"Request\": {\n        \"Path\": {\n            \"Matchers\": [\n                {\n                    \"Name\": \"WildcardMatcher\",\n                    \"Pattern\": \"/jsonpath\",\n                    \"IgnoreCase\": false\n                }\n            ]\n        },\n        \"Methods\": [\n            \"put\"\n        ],\n        \"Body\": {\n            \"Matcher\": {\n                \"Name\": \"JsonPathMatcher\",\n                \"Pattern\": \"$.things[?(@.name == 'RequiredThing')]\"\n            }\n        }\n    },\n    \"Response\": {\n        \"StatusCode\": 200,\n        \"BodyDestination\": \"SameAsSource\",\n        \"Body\": \"{ \\\"result\\\": \\\"JsonPathMatcher !!!\\\"}\",\n        \"UseTransformer\": false\n    }\n}\n</code></pre> JavaScript<pre><code>// matching\n{ \"things\": { \"name\": \"RequiredThing\" } }\n{ \"things\": [ { \"name\": \"RequiredThing\" }, { \"name\": \"Wiremock\" } ] }\n\n// not matching\n{ \"price\": 15 }\n{ \"things\": { \"name\": \"Wiremock\" } }\n</code></pre>"},{"location":"dotnet/Request-Matching-MimePartMatcher/","title":"Request Matching MimePartMatcher","text":"<p>Documentation / dotnet / Request-Matching-MimePartMatcher Use this to match a MultiPart Mime Request.</p>"},{"location":"dotnet/Request-Matching-MimePartMatcher/#c-code","title":"C# code","text":"C#<pre><code>var textPlainContentTypeMatcher = new ContentTypeMatcher(\"text/plain\");\nvar textPlainContentMatcher = new ExactMatcher(\"This is some plain text\");\nvar textPlainMatcher = new MimePartMatcher(MatchBehaviour.AcceptOnMatch, textPlainContentTypeMatcher, null, null, textPlainContentMatcher);\n\nvar partTextJsonContentTypeMatcher = new ContentTypeMatcher(\"text/json\");\nvar partTextJsonContentMatcher = new JsonMatcher(new { Key = \"Value\" }, true);\nvar partTextMatcher = new MimePartMatcher(MatchBehaviour.AcceptOnMatch, partTextJsonContentTypeMatcher, null, null, partTextJsonContentMatcher);\n\nvar imagePngContentTypeMatcher = new ContentTypeMatcher(\"image/png\");\nvar imagePngContentDispositionMatcher = new ExactMatcher(\"attachment; filename=\\\"image.png\\\"\");\nvar imagePngContentTransferEncodingMatcher = new ExactMatcher(\"base64\");\nvar imagePngContentMatcher = new ExactObjectMatcher(Convert.FromBase64String(\"iVBORw0KGgoAAAANSUhEUgAAAAIAAAACAgMAAAAP2OW3AAAADFBMVEX/tID/vpH/pWX/sHidUyjlAAAADElEQVR4XmMQYNgAAADkAMHebX3mAAAAAElFTkSuQmCC\"));\nvar imagePngMatcher = new MimePartMatcher(MatchBehaviour.AcceptOnMatch, imagePngContentTypeMatcher, imagePngContentDispositionMatcher, imagePngContentTransferEncodingMatcher, imagePngContentMatcher);\n\nvar matchers = new IMatcher[]\n{\n    textPlainMatcher,\n    partTextMatcher,\n    imagePngMatcher\n};\n\nserver\n    .Given(Request.Create()\n        .WithPath(\"/multipart\")\n        .UsingPost()\n        .WithMultiPart(matchers)\n    )\n    .WithGuid(\"b9c82182-e469-41da-bcaf-b6e3157fefdb\")\n    .RespondWith(Response.Create()\n        .WithBody(\"MultiPart is ok\")\n    );\n</code></pre>"},{"location":"dotnet/Request-Matching-MimePartMatcher/#json","title":"JSON:","text":"JSON<pre><code>{\n    \"Guid\": \"b9c82182-e469-41da-bcaf-b6e3157fefdb\",\n    \"UpdatedAt\": \"2023-07-24T18:12:55.564978Z\",\n    \"Request\": {\n        \"Path\": {\n            \"Matchers\": [\n                {\n                    \"Name\": \"WildcardMatcher\",\n                    \"Pattern\": \"/multipart\",\n                    \"IgnoreCase\": false\n                }\n            ]\n        },\n        \"Methods\": [\n            \"POST\"\n        ],\n        \"Body\": {\n            \"Matchers\": [\n                {\n                    \"ContentTypeMatcher\": {\n                        \"Name\": \"ContentTypeMatcher\",\n                        \"Pattern\": \"text/plain\",\n                        \"IgnoreCase\": false\n                    },\n                    \"ContentMatcher\": {\n                        \"Name\": \"ExactMatcher\",\n                        \"Pattern\": \"This is some plain text\",\n                        \"IgnoreCase\": false\n                    },\n                    \"Name\": \"MimePartMatcher\"\n                },\n                {\n                    \"ContentTypeMatcher\": {\n                        \"Name\": \"ContentTypeMatcher\",\n                        \"Pattern\": \"text/json\",\n                        \"IgnoreCase\": false\n                    },\n                    \"ContentMatcher\": {\n                        \"Name\": \"JsonMatcher\",\n                        \"Pattern\": {\n                            \"Key\": \"Value\"\n                        },\n                        \"IgnoreCase\": true\n                    },\n                    \"Name\": \"MimePartMatcher\"\n                },\n                {\n                    \"ContentTypeMatcher\": {\n                        \"Name\": \"ContentTypeMatcher\",\n                        \"Pattern\": \"image/png\",\n                        \"IgnoreCase\": true\n                    },\n                    \"ContentDispositionMatcher\": {\n                        \"Name\": \"ExactMatcher\",\n                        \"Pattern\": \"attachment; filename=\\\"image.png\\\"\",\n                        \"IgnoreCase\": true\n                    },\n                    \"ContentTransferEncodingMatcher\": {\n                        \"Name\": \"ExactMatcher\",\n                        \"Pattern\": \"base64\",\n                        \"IgnoreCase\": true\n                    },\n                    \"ContentMatcher\": {\n                        \"Name\": \"ExactObjectMatcher\",\n                        \"Pattern\": \"iVBORw0KGgoAAAANSUhEUgAAAAIAAAACAgMAAAAP2OW3AAAADFBMVEX/tID/vpH/pWX/sHidUyjlAAAADElEQVR4XmMQYNgAAADkAMHebX3mAAAAAElFTkSuQmCC\"\n                    },\n                    \"Name\": \"MimePartMatcher\"\n                }\n            ],\n            \"MatchOperator\": \"Or\"\n        }\n    },\n    \"Response\": {\n        \"BodyDestination\": \"SameAsSource\",\n        \"Body\": \"MultiPart is ok\"\n    }\n}\n</code></pre>"},{"location":"dotnet/Request-Matching-ProtoBuf/","title":"Request Matching ProtoBuf","text":"<p>Documentation / dotnet / Request-Matching-ProtoBuf</p>"},{"location":"dotnet/Request-Matching-ProtoBuf/#macro-rendering-error","title":"Macro Rendering Error","text":"<p>File: <code>dotnet/Request-Matching-ProtoBuf.md</code></p> <p>UndefinedError: 'request' is undefined</p> Text Only<pre><code>Traceback (most recent call last):\n  File \"/home/muna/Desktop/wiremock-documentation/venv/lib/python3.11/site-packages/mkdocs_macros/plugin.py\", line 688, in render\n    return md_template.render(**page_variables)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/home/muna/Desktop/wiremock-documentation/venv/lib/python3.11/site-packages/jinja2/environment.py\", line 1295, in render\n    self.environment.handle_exception()\n  File \"/home/muna/Desktop/wiremock-documentation/venv/lib/python3.11/site-packages/jinja2/environment.py\", line 942, in handle_exception\n    raise rewrite_traceback_stack(source=source)\n  File \"&lt;template&gt;\", line 75, in top-level template code\n  File \"/home/muna/Desktop/wiremock-documentation/venv/lib/python3.11/site-packages/jinja2/environment.py\", line 490, in getattr\n    return getattr(obj, attribute)\n           ^^^^^^^^^^^^^^^^^^^^^^^\njinja2.exceptions.UndefinedError: 'request' is undefined\n</code></pre>"},{"location":"dotnet/Request-Matching-Tips/","title":"Request Matching Tips","text":"<p>Documentation / dotnet / Request-Matching-Tips</p>"},{"location":"dotnet/Request-Matching-Tips/#request-is-not-matched","title":"Request is not matched","text":"<p>In case you get a <code>404</code> back, but you expect a valid match-response on your request, use the the following tips.</p>"},{"location":"dotnet/Request-Matching-Tips/#get-the-request-via-the-admin-interface","title":"Get the request via the admin interface","text":"<p>Do a GET call to http://{{ wm_hostname }}/__admin/requests to get information about the request you just sent.</p> <p>The example below shows: - The request is not matched and a <code>404</code> with \"No matching mapping found\" is returned - The <code>PartialMappingGuid</code>, <code>PartialMappingTitle</code> show information about the best mapping found - The <code>PartialRequestMatchResult</code> shows some details about all matching element. In this case the PathMatcher returns <code>0.0</code>, so this means that something is wrong with the matching on the Path.</p> JavaScript<pre><code>    \"Response\": {\n      \"StatusCode\": 404,\n      \"Headers\": {\n        \"Content-Type\": [\n          \"application/json\"\n        ]\n      },\n      \"BodyAsJson\": {\n        \"Status\": \"No matching mapping found\"\n      },\n      \"DetectedBodyType\": 2,\n      \"DetectedBodyTypeFromContentType\": 0\n    },\n    \"PartialMappingGuid\": \"bb4c0d1d-ef2e-4cd2-966a-850b8f1a2829\",\n    \"PartialMappingTitle\": \"Fetch_User_By_Id_66\",\n    \"PartialRequestMatchResult\": {\n      \"TotalScore\": 2.0,\n      \"TotalNumber\": 3,\n      \"IsPerfectMatch\": false,\n      \"AverageTotalScore\": 0.66666666666666663,\n      \"MatchDetails\": [\n        {\n          \"Name\": \"PathMatcher\",\n          \"Score\": 0.0\n        },\n        {\n          \"Name\": \"MethodMatcher\",\n          \"Score\": 1.0\n        },\n        {\n          \"Name\": \"BodyMatcher\",\n          \"Score\": 1.0\n        }\n      ]\n    }\n</code></pre>"},{"location":"dotnet/Request-Matching-Tips/#get-information-via-the-logging","title":"Get information via the logging","text":"<p>When you run WireMock.Net as standalone console application and logging is enabled, you see the same logging in the console.</p>"},{"location":"dotnet/Request-Matching-Tips/#get-information-via-c-code","title":"Get information via C# code","text":"C#<pre><code>var server = WireMockServer.Start();\nvar logEntries = server.LogEntries;\n</code></pre>"},{"location":"dotnet/Request-Matching/","title":"Request Matching","text":"<p>Documentation / dotnet / Request-Matching</p>"},{"location":"dotnet/Request-Matching/#one-request-matching","title":":one: Request Matching","text":"<p>WireMock.Net supports matching of requests to stubs and verification queries using the following parts:</p> <ul> <li>Path</li> <li>URL</li> <li>HTTP Method</li> <li>Query parameters</li> <li>Headers</li> <li>Cookies</li> <li>Request Body</li> </ul>"},{"location":"dotnet/Request-Matching/#generic-information-on-matchers","title":"Generic information on matchers:","text":"<p>Most matchers have 2 extra properties: - IgnoreCase = define that the matcher should match ignoring the case - RejectOnMatch = define that when the matcher does match successfully, this should be counted as a invalid (non-matching) match</p>"},{"location":"dotnet/Request-Matching/#example-matchings","title":"Example Matchings","text":""},{"location":"dotnet/Request-Matching/#path","title":"Path","text":""},{"location":"dotnet/Request-Matching/#c-example","title":"C# example","text":"C#<pre><code>server\n  .Given(Request\n    .Create()\n      .WithPath(\"/test\")\n</code></pre>"},{"location":"dotnet/Request-Matching/#json-example","title":"JSON example","text":"JSON<pre><code>{\n  \"Request\": {\n    \"Path\": {\n      \"Matchers\": [\n        {\n          \"Name\": \"WildcardMatcher\",\n          \"Pattern\": \"/path\",\n          \"IgnoreCase\": true\n        }\n      ]\n    }\n  }\n}\n````\n\n### Url\n#### C# example\n``` c#\nserver\n  .Given(Request\n    .Create()\n      .WithUrl(\"https://localhost/test\")\n</code></pre>"},{"location":"dotnet/Request-Matching/#json-example_1","title":"JSON example","text":"JSON<pre><code>{\n  \"Request\": {\n    \"Url\": {\n      \"Matchers\": [\n        {\n          \"Name\": \"RegexMatcher\",\n          \"Pattern\": \"/clients[?]\",\n          \"IgnoreCase\": true\n        }\n      ]\n    }\n  }\n}\n````\n\n### Query Parameters\n#### C# example\n``` c#\nserver\n  .Given(Request\n    .Create()\n      .WithParam(\"search\", \"abc\")\n</code></pre>"},{"location":"dotnet/Request-Matching/#json-example_2","title":"JSON example","text":"JSON<pre><code>{\n     \"Request\": {\n        \"Params\": [\n            {\n                \"Name\": \"search\",\n                \"Matchers\": [\n                    {\n                        \"Name\": \"ExactMatcher\",\n                        \"Pattern\": \"abc\"\n                    }\n                ]\n            }\n        ]\n    }\n}\n</code></pre>"},{"location":"dotnet/Request-Matching/#headers","title":"Headers","text":""},{"location":"dotnet/Request-Matching/#c","title":"C","text":"C#<pre><code>// todo\n</code></pre>"},{"location":"dotnet/Request-Matching/#json","title":"JSON","text":"JSON<pre><code>{\n  \"Request\": {\n    \"Headers\": [\n      {\n        \"Name\": \"api-key\",\n        \"Matchers\": [\n          {\n            \"Name\": \"WildcardMatcher\",\n            \"Pattern\": \"abc*\"\n            \"IgnoreCase\": true\n          }\n        ]\n      }\n    ]\n  }\n}\n</code></pre> <p>Note that when you want to match on a missing header, you need to use this mapping: JSON<pre><code>{\n  \"Request\": {\n    \"Headers\": [\n    {\n      \"Name\": \"api-key\",\n      \"IgnoreCase\": true,\n      \"RejectOnMatch\": true\n    }\n  ]\n}\n</code></pre> This means that when the header-key <code>api-key</code> (ignoring the casing) is missing the header mapping will match because <code>RejectOnMatch</code> is <code>true</code>.</p>"},{"location":"dotnet/Request-Matching/#two-matchers","title":":two: Matchers","text":"<p>Content moved to Request Matchers.</p>"},{"location":"dotnet/Response-Templating/","title":"Response Templating","text":"<p>Documentation / dotnet / Response-Templating Response headers and bodies can optionally be rendered (templated) with:</p> <ul> <li>Handlebars.Net</li> <li>Scriban/Scriban DotLiquid</li> </ul> <p>This enables attributes of the request to be used in generating the response e.g. to pass the value of a request ID header as a response header or render an identifier from part of the URL in the response body. To use this functionality, add <code>.WithTransformer()</code> to the response builder.</p>"},{"location":"dotnet/Response-Templating/#way-of-working","title":"Way-Of-Working","text":""},{"location":"dotnet/Response-Templating/#1-define-handlebars-template","title":"1. Define \"Handlebars template\"","text":"Handlebars<pre><code>Hello {{firstname}}\n</code></pre>"},{"location":"dotnet/Response-Templating/#2-data","title":"2. Data","text":"C#<pre><code>var user = new\n{\n  firstname = \"Stef\"\n}\n</code></pre>"},{"location":"dotnet/Response-Templating/#3-result","title":"3. Result","text":"C#<pre><code>Hello Stef\n</code></pre>"},{"location":"dotnet/Response-Templating/#c-example-for-using-handlebarsnet","title":"C# Example for using Handlebars.Net :","text":"C#<pre><code>var server = WireMockServer.Start();\nserver\n  .Given(\n    Request.Create().WithPath(\"/some/thing\").UsingGet()\n  )\n  .RespondWith(\n    Response.Create()\n      .WithBody(\"Hello world! Your path is {{request.path}}.\")\n      .WithTransformer()\n  );\n</code></pre>"},{"location":"dotnet/Response-Templating/#mapping-json-example-using-handlebarsnet","title":"Mapping Json Example using Handlebars.Net:","text":"JavaScript<pre><code>{\n    \"Guid\": \"fd8ca21b-db82-48bc-ae5a-fc2153c2b0db\",\n    \"Request\": {\n        \"Path\": {\n            \"Matchers\": [\n                {\n                    \"Name\": \"WildcardMatcher\",\n                    \"Pattern\": \"/bodyasfile_transform123\"\n                }\n            ]\n        },\n        \"Methods\": [\n            \"get\"\n        ]\n    },\n    \"Response\": {\n        \"Headers\": { \"Content-Type\": \"application/xml\" },\n        \"BodyAsFile\": \"c:\\\\temp-wiremock\\\\__admin\\\\mappings\\\\_{{request.query.MyUniqueNumber}}_\\\\MyXmlResponse.xml\",\n        \"UseTransformer\": true,\n        \"UseTransformerForBodyAsFile\": true // \u2b50\n    }\n}\n</code></pre>"},{"location":"dotnet/Response-Templating/#scriban","title":"Scriban","text":"<p>For using Scriban as templating engine, just provide the type:</p>"},{"location":"dotnet/Response-Templating/#c","title":"C","text":"C#<pre><code>  // . . .\n  .WithTransformer(TransformerType.Scriban) // or TransformerType.ScribanDotLiquid\n  // . . .\n</code></pre>"},{"location":"dotnet/Response-Templating/#json","title":"JSON","text":"JavaScript<pre><code>{\n    . . .\n    \"Response\": {\n        . . .\n        \"UseTransformer\": true,\n        \"TransformerType\": \"Scriban\"\n    }\n}\n</code></pre>"},{"location":"dotnet/Response-Templating/#note","title":"Note","text":"<p>Scriban and Handlebars.Net are supported, however some functionality from Scriban cannot not (yet) be used in WireMock.Net, these topics are: - DOT notation for accessing this {{request.PathSegments.[0]}} does not work - WireMockList is not supported by Scriban</p> <p>So the examples and explication below is mostly targeted to Handlebars.Net</p>"},{"location":"dotnet/Response-Templating/#the-request-model","title":"The request model","text":"<p>The model of the request is supplied to the header and body templates. The following request attributes are available:</p> <ul> <li><code>request.url</code> - URL path and query</li> <li><code>request.method</code> - The HTTP method such as GET or POST.</li> <li><code>request.protocol</code> - The scheme such as http or https.</li> <li><code>request.host</code> - The name of the host in the URL.</li> <li><code>request.origin</code> - The base URL of the request which is equivalent to <code>{Protocol}://{Host}:{Port}</code>.</li> <li><code>request.absoluteurl</code> - URL path and query (absolute)</li> <li><code>request.path</code> - URL path</li> <li><code>request.absolutepath</code> - URL path (absolute)</li> <li><code>request.PathSegments.[&lt;n&gt;]</code> - URL path segment (zero indexed) e.g. request.PathSegments.[2]</li> <li><code>request.AbsolutePathSegments.[&lt;n&gt;]</code> - URL absolute path segments  (zero indexed) e.g. request.AbsolutePathSegments.[2]</li> <li><code>request.query.&lt;key&gt;</code>- First value of a query parameter e.g. request.query.search</li> <li><code>request.query.&lt;key&gt;.[&lt;n&gt;]</code>- nth value of a query parameter (zero indexed) e.g. request.query.search.[5]</li> <li><code>request.headers.&lt;key&gt;</code> - First value of a request header e.g. request.headers.X-Request-Id</li> <li><code>request.headers.[&lt;key&gt;]</code> - Header with awkward characters e.g. request.headers.[$?blah]</li> <li><code>request.headers.&lt;key&gt;.[&lt;n&gt;]</code> - nth value of a header (zero indexed) e.g. request.headers.ManyThings.[1]</li> <li><code>request.cookies.&lt;key&gt;</code> - Value of a request cookie e.g. request.cookies.JSESSIONID</li> <li><code>request.body</code> - Request body text as string</li> <li><code>request.bodyAsJson</code> - Request body as dynamic Json Object. Note that the request must contain the header <code>Content-Type</code> with value <code>application/json</code>!</li> </ul>"},{"location":"dotnet/Response-Templating/#transform-the-content-from-a-referenced-file","title":"Transform the content from a referenced file","text":"<p>:memo: By default, only the response (headers, statuscode, body) are transformed when the  <code>.WithTransformer()</code> or <code>UseTransformer</code> are defined.</p> <p>\u2b50 In case you also want to transform the contents from a referenced file (via <code>BodyAsFile</code>), an additional parameter need to added. Like <code>.WithTransformer(bool)</code> or <code>UseTransformerForBodyAsFile = true</code>. (#386 and #1106)</p>"},{"location":"dotnet/Response-Templating/#standard-handlebars-helpers","title":"Standard Handlebars helpers","text":"<p>All of the standard helpers (template functions) provided by the C# Handlebars implementation are available.</p>"},{"location":"dotnet/Response-Templating/#additional-handlebars-helpers","title":"Additional Handlebars helpers","text":"<p>In addition to the standard helpers, also the helpers from Handlebars.Net.Helpers are supported. The following extra helpers are included in WireMock.Net: - Humanizer - JsonPath.SelectToken &amp; JsonPath.SelectTokens - Linq - Random - Regex - XPath.SelectSingleNode &amp; XPath.SelectNodes &amp; XPath.Evaluate and XPath - Xeger - Xslt</p>"},{"location":"dotnet/Response-Templating/#jsonpath","title":"JsonPath","text":"<p>JsonPath support is also present (internal logic is based on Newtonsoft.Json).</p> <p>Two functions are present: 1. JsonPath.SelectToken 2. JsonPath.SelectTokens</p>"},{"location":"dotnet/Response-Templating/#jsonpathselecttoken","title":"JsonPath.SelectToken","text":""},{"location":"dotnet/Response-Templating/#this-can-be-used-in-c-like","title":"This can be used in C# like:","text":"C#<pre><code>var server = WireMockServer.Start();\nserver\n    .Given(Request.Create().WithPath(\"/jsonpathtestToken\").UsingPost())\n    .RespondWith(Response.Create()\n        .WithHeader(\"Content-Type\", \"application/json\")\n        .WithBody(\"{{JsonPath.SelectToken request.body \\\"$.Manufacturers[?(@.Name == 'Acme Co')]\\\"}}\")\n        .WithTransformer()\n    );\n</code></pre> <p>:warning: When returning a more complex Json Body like this: JSON<pre><code>{\n  \"market\": \"{{JsonPath.SelectToken request.bodyAsJson '$.pricingContext.market'}}\",\n  \"languages\": \"en\"\n}\n</code></pre></p> <p>You need to to use single quote (<code>'</code>) instead of escaped double quotes (<code>\\\"</code>) because of some parsing error @ Handlebars.Net (see also #1108).</p>"},{"location":"dotnet/Response-Templating/#or-using-the-admin-mapping-file","title":"Or using the admin mapping file:","text":"JavaScript<pre><code>{\n    \"Request\": {\n        \"Path\": {\n            \"Matchers\": [\n                {\n                    \"Name\": \"WildcardMatcher\",\n                    \"Pattern\": \"/jsonpathtestToken\"\n                }\n            ]\n        },\n        \"Methods\": [\n            \"post\"\n        ]\n    },\n    \"Response\": {\n        \"Body\": \"{{JsonPath.SelectToken request.body \\\"$.Manufacturers[?(@.Name == 'Acme Co')]\\\"}}\",\n        \"UseTransformer\": true,\n        \"Headers\": {\n            \"Content-Type\": \"application/json\"\n        }\n    }\n}\n</code></pre> <p>Note that also replacing values in a Json Object and returning a the body as Json is supported, to use this, use a mapping file like this: JavaScript<pre><code>{\n  \"Request\": {\n    \"Path\": {\n      \"Matchers\": [\n        {\n          \"Name\": \"WildcardMatcher\",\n          \"Pattern\": \"/test\"\n        }\n      ]\n    },\n    \"Methods\": [\n      \"post\"\n    ]\n  },\n  \"Response\": {\n    \"BodyAsJson\": {\n      \"path\": \"{{request.path}}\",\n      \"result\": \"{{JsonPath.SelectToken request.bodyAsJson \\\"username\\\"}}\"\n    },\n    \"UseTransformer\": true,\n    \"Headers\": {\n      \"Content-Type\": \"application/json\"\n    }\n  }\n}\n</code></pre></p>"},{"location":"dotnet/Response-Templating/#random","title":"Random","text":"<p>It's possible to return random data using the <code>Random</code> Handlebars function.</p>"},{"location":"dotnet/Response-Templating/#random-text","title":"Random Text","text":"<p>Example: to generate a random string between 8 and 20 characters, use this code in C#: C#<pre><code>var server = WireMockServer.Start();\nserver\n    .Given(Request.Create().WithPath(\"/random\").UsingGet())\n    .RespondWith(Response.Create()\n        .WithHeader(\"Content-Type\", \"application/json\")\n        .WithBodyAsJson(\n            Text = \"{{Random Type=\\\"Text\\\" Min=8 Max=20}}\",\n        )\n        .WithTransformer()\n    );\n</code></pre></p> <p>Example: to generate a random string using a Regex pattern, use this code in C#: C#<pre><code>var server = FluentMockServer.Start();\nserver\n    .Given(Request.Create().WithPath(\"/random-regex\").UsingGet())\n    .RespondWith(Response.Create()\n        .WithHeader(\"Content-Type\", \"application/json\")\n        .WithBodyAsJson(\n            Text = \"{{Xeger \\\"[1-9][0-9]{3}[A-Z]{2}\\\"}\",\n        )\n        .WithTransformer()\n    );\n</code></pre></p>"},{"location":"dotnet/Response-Templating/#random-all-supported-randomizers","title":"Random (all supported randomizers)","text":"<p>You can use the powerful Regular Expression string generator based on Fare - Finite Automata and Regular Expressions. - Text Regex Pattern: <code>\"{{Xeger Pattern=\\\"[1-9][0-9]{3}[A-Z]{2}\"}}\"</code></p> <p>Besides a random text string, it's also possible to generate this random data: - Integer: <code>\"{{Random Type=\\\"Integer\\\" Min=100 Max=999}}\"</code> - Guid: <code>\"{{Random Type=\\\"Guid\\\"}}\"</code> - City: <code>\"{{Random Type=\\\"City\\\"}}\"</code> - Country: <code>\"{{Random Type=\\\"Country\\\"}}\"</code> - First Name: <code>\"{{Random Type=\\\"FirstName\\\" Male=false Female=true}}\"</code> - Email Address: <code>\"{{Random Type=\\\"EmailAddress\\\"}}\"</code> - Text Words: <code>\"{{Random Type=\\\"TextWords\\\" Min=10 Max=20}}\"</code> - Text Regex Pattern: <code>\"{{Random Type=\\\"TextRegex\\\" Pattern=\\\"[1-9][0-9]{3}[A-Z]{2}\"}}\"</code> - Text Lorum Ipsum: <code>\"{{Random Type=\\\"TextIpsum\\\" Paragraphs=2}}\"</code> - String List: <code>\"{{Random Type=\\\"StringList\\\" Values=[\\\"a\\\", \\\"b\\\", \\\"c\\\"]}}\"</code> - IPv4 Address: <code>\"{{Random Type=\\\"IPv4Address\\\"}}\"</code> - IPv6 Address: <code>\"{{Random Type=\\\"IPv6Address\\\" Min = \"0000:0001:0000:0000:0020:ff00:0042:8000\", Max = \"2001:0db8:0120:0000:0030:ff00:aa42:8329\"}}\"</code> - MAC Address: <code>\"{{Random Type=\\\"MACAddress\\\"}}\"</code> - For more details on the supported random data types, see RandomDataGenerator.Net;</p> <p>Note: instead of using <code>\\\"</code> in above examples, you can also use <code>'</code>.</p>"},{"location":"dotnet/Response-Templating/#xpath","title":"XPath","text":"<p>XPath support is also present</p> <p>Three functions are present: 1. XPath.SelectSingleNode 2. XPath.SelectNodes 3. XPath.Evaluate</p>"},{"location":"dotnet/Response-Templating/#xpathselectsinglenode","title":"XPath.SelectSingleNode","text":"<p>This can be used in C# like: C#<pre><code>var server = WireMockServer.Start();\nserver\n    .Given(Request.Create().WithPath(\"/xpath1\").UsingPost())\n    .RespondWith(Response.Create()\n        .WithHeader(\"Content-Type\", \"application/xml\")\n        .WithBody(\"&lt;response&gt;{{XPath.SelectSingleNode request.body \\\"/todo-list/todo-item[1]\\\"}}&lt;/response&gt;\")\n        .WithTransformer()\n    );\n</code></pre></p> <p>Or using the admin mapping file: JavaScript<pre><code>{\n    \"Request\": {\n        \"Path\": {\n            \"Matchers\": [\n                {\n                    \"Name\": \"WildcardMatcher\",\n                    \"Pattern\": \"/xpath1\"\n                }\n            ]\n        },\n        \"Methods\": [\n            \"post\"\n        ]\n    },\n    \"Response\": {\n        \"Body\": \"&lt;response&gt;{{XPath.SelectSingleNode request.body \\\"/todo-list/todo-item[1]\\\"}}&lt;/response&gt;\",\n        \"UseTransformer\": true,\n        \"Headers\": {\n            \"Content-Type\": \"application/xml\"\n        }\n    }\n}\n</code></pre></p> <p>For examples on <code>XPath.SelectNodes</code> and <code>XPath.Evaluate</code>, see https://github.com/WireMock-Net/WireMock.Net/blob/master/test/WireMock.Net.Tests/ResponseBuilders/ResponseWithHandlebarsXPathTests.cs</p>"},{"location":"dotnet/Scenarios-and-States/","title":"Scenarios and States","text":"<p>Documentation / dotnet / Scenarios-and-States</p>"},{"location":"dotnet/Scenarios-and-States/#using-scenarios","title":"Using Scenarios","text":"<p>WireMock.Net supports State via the notion of scenarios. A scenario is essentially a state machine whose states can be arbitrarily assigned. Stub mappings can be configured to match on scenario state, such that stub A can be returned initially, then stub B once the next scenario state has been triggered.</p> <p>For example, suppose we\u2019re writing a to-do list application consisting of a rich client of some kind talking to a REST service. We want to test that our UI can read the to-do list, add an item and refresh itself, showing the updated list.</p> <p>Example test code: C#<pre><code>// Assign\n_server = WireMockServer.Start();\n\n_server\n  .Given(Request.Create()\n    .WithPath(\"/todo/items\")\n    .UsingGet())\n  .InScenario(\"To do list\")\n  .WillSetStateTo(\"TodoList State Started\")\n  .RespondWith(Response.Create()\n    .WithBody(\"Buy milk\"));\n\n_server\n  .Given(Request.Create()\n    .WithPath(\"/todo/items\")\n    .UsingPost())\n  .InScenario(\"To do list\")\n  .WhenStateIs(\"TodoList State Started\")\n  .WillSetStateTo(\"Cancel newspaper item added\")\n  .RespondWith(Response.Create()\n    .WithStatusCode(201));\n\n_server\n  .Given(Request.Create()\n    .WithPath(\"/todo/items\")\n    .UsingGet())\n  .InScenario(\"To do list\")\n  .WhenStateIs(\"Cancel newspaper item added\")\n  .RespondWith(Response.Create()\n    .WithBody(\"Buy milk;Cancel newspaper subscription\"));\n\n// Act and Assert\nstring url = \"http://localhost:\" + _server.Ports[0];\nstring getResponse1 = await new HttpClient().GetStringAsync(url + \"/todo/items\");\nCheck.That(getResponse1).Equals(\"Buy milk\");\n\nvar postResponse = await new HttpClient().PostAsync(url + \"/todo/items\", new StringContent(\"Cancel newspaper subscription\"));\nCheck.That(postResponse.StatusCode).Equals(HttpStatusCode.Created);\n\nstring getResponse2 = await new HttpClient().GetStringAsync(url + \"/todo/items\");\nCheck.That(getResponse2).Equals(\"Buy milk;Cancel newspaper subscription\");\n</code></pre></p> <p>The first Scenario and State definition can also be used in the JSON Admin interface like: JSON<pre><code>[\n    {\n        \"Guid\": \"60d65393-1556-46ad-9206-8a0ab725b099\",\n        \"UpdatedAt\": \"2023-05-12T20:03:46.693747Z\",\n        \"Scenario\": \"To do list\",\n        \"SetStateTo\": \"TodoList State Started\",\n        \"Request\": {\n            \"Path\": {\n                \"Matchers\": [\n                    {\n                        \"Name\": \"WildcardMatcher\",\n                        \"Pattern\": \"/todo/items\",\n                        \"IgnoreCase\": false\n                    }\n                ]\n            },\n            \"Methods\": [\n                \"GET\"\n            ]\n        },\n        \"Response\": {\n            \"BodyDestination\": \"SameAsSource\",\n            \"Body\": \"Buy milk\"\n        }\n    },\n    {\n        \"Guid\": \"8bd98789-4b55-4084-bb5b-fba85176f3a6\",\n        \"UpdatedAt\": \"2023-05-12T20:03:46.6937938Z\",\n        \"Scenario\": \"To do list\",\n        \"WhenStateIs\": \"TodoList State Started\",\n        \"SetStateTo\": \"Cancel newspaper item added\",\n        \"Request\": {\n            \"Path\": {\n                \"Matchers\": [\n                    {\n                        \"Name\": \"WildcardMatcher\",\n                        \"Pattern\": \"/todo/items\",\n                        \"IgnoreCase\": false\n                    }\n                ]\n            },\n            \"Methods\": [\n                \"POST\"\n            ]\n        },\n        \"Response\": {\n            \"StatusCode\": 201\n        }\n    },\n    {\n        \"Guid\": \"0b818c7c-3778-4504-9baf-229aa57bf1e1\",\n        \"UpdatedAt\": \"2023-05-12T20:03:46.6938425Z\",\n        \"Scenario\": \"To do list\",\n        \"WhenStateIs\": \"Cancel newspaper item added\",\n        \"Request\": {\n            \"Path\": {\n                \"Matchers\": [\n                    {\n                        \"Name\": \"WildcardMatcher\",\n                        \"Pattern\": \"/todo/items\",\n                        \"IgnoreCase\": false\n                    }\n                ]\n            },\n            \"Methods\": [\n                \"GET\"\n            ]\n        },\n        \"Response\": {\n            \"BodyDestination\": \"SameAsSource\",\n            \"Body\": \"Buy milk;Cancel newspaper subscription\"\n        }\n    }\n]\n</code></pre></p>"},{"location":"dotnet/Scenarios-and-States/#stay-in-the-same-state-for-a-number-of-requests","title":"Stay in the same State for a number of requests","text":"<p>In case you want to match a request for a certain state multiple times before moving to the next state, you can specify this. Example code:</p> <p>In the above scenario, if you want to add more items to the ToDo list, like  - Fixing the car - Cancel newspaper</p> <p>And you want to move to the next state when these two requests are matched, set the <code>times</code> variable to <code>2</code> like this:</p> C#<pre><code>_server\n  .Given(Request.Create()\n    .WithPath(\"/todo/items\")\n    .UsingPost())\n  .InScenario(\"To do list\")\n  .WhenStateIs(\"TodoList State Started\")\n  .WillSetStateTo(\"Cancel newspaper item added\", 2) // &lt;-- The number of times this match should be matched before the state will be changed to the specified one.\n  .RespondWith(Response.Create()\n    .WithStatusCode(201));\n</code></pre>"},{"location":"dotnet/Settings/","title":"Settings","text":"<p>Documentation / dotnet / Settings</p>"},{"location":"dotnet/Settings/#wiremockserversettings","title":"WireMockServerSettings","text":"<p>The interface WireMockServerSettings.cs defines the configuration from the WireMock.Net server.</p>"},{"location":"dotnet/Settings/#port","title":"Port","text":"<p>The port to listen on.</p>"},{"location":"dotnet/Settings/#usessl","title":"UseSSL","text":"<p>Use SSL.</p>"},{"location":"dotnet/Settings/#startadmininterface","title":"StartAdminInterface","text":"<p>Defines to if the admin interface should be started.</p>"},{"location":"dotnet/Settings/#readstaticmappings","title":"ReadStaticMappings","text":"<p>Defines if the static mappings should be read at startup.</p>"},{"location":"dotnet/Settings/#watchstaticmappings","title":"WatchStaticMappings","text":"<p>Watch the static mapping files + folder for changes when running.</p>"},{"location":"dotnet/Settings/#allowcsharpcodematcher","title":"AllowCSharpCodeMatcher","text":"<p>Allow the usage of CSharpCodeMatcher, default is not allowed because it can be dangerous to execute all C# code.</p>"},{"location":"dotnet/Settings/#certificatesettings","title":"CertificateSettings","text":"<p>By default, the .NETStandard version from WireMock.Net can use the default .NET self-signed development certificate. See HTTPS-SSL for more info.</p> <p>However, it's also possible to use your own certificate by configuring appropriate values for the <code>CertificateSettings</code>. The following methods are supported: </p> <ul> <li>Using the Certificate Store  </li> <li>Loading a PFX certificate from the file system  </li> <li>Utilizing an in-memory <code>X509Certificate2</code> instance</li> </ul> <p>Note that: - X509StoreName and X509StoreLocation should be defined - OR - X509CertificateFilePath and X509CertificatePassword should be defined - OR  - X509Certificate should be defined</p>"},{"location":"dotnet/Settings/#ssl-certficate-from-certificate-store","title":"SSL Certficate from Certificate Store","text":"C#<pre><code>var server = WireMockServer.Start(new WireMockServerSettings\n{\n    Urls = new[] { \"https://localhost:8443\" },\n    CertificateSettings = new WireMockCertificateSettings\n    {\n        X509StoreName = \"My\",\n        X509StoreLocation = \"CurrentUser\",\n        // X509StoreThumbprintOrSubjectName can be a Thumbprint, SubjectName or null\n        X509StoreThumbprintOrSubjectName = \"FE16586076A8B3F3E2F1466803A6C4C7CA35455B\"\n    }\n});\n</code></pre> <p>Where * <code>X509StoreName</code> = The Certificate StoreName. One of: AddressBook, AuthRoot, CertificateAuthority, My, Root, TrustedPeople, TrustedPublisher. * <code>X509StoreLocation</code> = The Certificate StoreLocation. Can be CurrentUser or LocalMachine. * <code>X509StoreThumbprintOrSubjectName</code> = This can be the Certifcate Thumbprint, Certifcate SubjectName or null. If it's null, the first match on the hostname Certicate is used.</p>"},{"location":"dotnet/Settings/#ssl-certficate-from-the-file-system","title":"SSL Certficate from the file system","text":"C#<pre><code>var server = WireMockServer.Start(new WireMockServerSettings\n{\n    Urls = new[] { \"https://localhost:8443\" },\n    CertificateSettings = new WireMockCertificateSettings\n    {\n        X509CertificateFilePath = \"example.pfx\",\n        X509CertificatePassword = \"wiremock\"\n    }\n});\n</code></pre> <p>Where * <code>X509CertificateFilePath</code> = The full path to the X509Certificate2 <code>.pfx</code> or <code>.pem</code> file * <code>X509CertificatePassword</code> = The password or key for the X509Certificate2 file. This can be null if the certificate does not require a password.</p>"},{"location":"dotnet/Settings/#ssl-certificate-from-in-memory-x509certificate2","title":"SSL Certificate from in-memory X509Certificate2","text":"C#<pre><code>// GetSSLCertificate is used to represent any way to load a certificate, for example from Azure KeyVault.\nX509Certificate2 sslCertificate = GetSSLCertificate();\n\nvar server = WireMockServer.Start(new WireMockServerSettings\n{\n    Urls = new[] { \"https://localhost:8443\" },\n    CertificateSettings = new WireMockCertificateSettings\n    {\n        X509Certificate = sslCertificate\n    }\n});\n</code></pre>"},{"location":"dotnet/Settings/#additional-ssl-certificate-resources","title":"Additional SSL Certificate Resources","text":"<p>\ud83d\udcdd  See also these links on how to generate a EC or RSA - https://www.scottbrady91.com/openssl/creating-elliptical-curve-keys-using-openssl  - https://www.scottbrady91.com/openssl/creating-rsa-keys-using-openssl - https://github.com/WireMock-Net/WireMock.Net/tree/master/examples/WireMock.Net.Console.NET6.WithCertificate  </p>"},{"location":"dotnet/Settings/#proxyandrecordsettings","title":"ProxyAndRecordSettings","text":"<p>You can enable ProxyAndRecord functionality by defining the ProxyAndRecordSettings and by specifying an Url. See code example below. C#<pre><code>var server = WireMockServer.Start(new FluentMockServerSettings\n{\n    Urls = new[] { \"http://localhost:9095/\" },\n    StartAdminInterface = true,\n    ProxyAndRecordSettings = new ProxyAndRecordSettings\n    {\n        Url = \"http://www.bbc.com\",\n        SaveMapping = true,\n        SaveMappingToFile = true,\n        BlackListedHeaders = new [] { \"dnt\", \"Content-Length\" },\n        BlackListedCookies = new [] { \"c1\", \"c2\" },\n        SaveMappingForStatusCodePattern = \"2xx\",\n        AllowAutoRedirect = true,\n        WebProxySettings = new WebProxySettings\n        {\n            UserName = \"test\",\n            Password = \"pwd\",\n            Address = \"http://company.proxy\"\n        },\n        UseDefinedRequestMatchers = false,\n        AppendGuidToSavedMappingFile = true,\n        ReplaceSettings = new ProxyUrlReplaceSettings\n        {\n            \"OldValue\" = \"old\",\n            \"NewValue\" = \"new\"\n        }\n    }\n});\n</code></pre></p> <p>Where * <code>Url</code> = The url to proxy to * <code>SaveMapping</code> = Save the mapping for each request/response to the internal Mappings * <code>SaveMappingToFile</code> = Save the mapping for each request/response to also file. * <code>SaveMappingForStatusCodePattern</code> = Only save request/response to the internal Mappings if the status code is included in this pattern. (Note that SaveMapping must also be set to true.) The pattern can contain a single value like \"200\", but also ranges like \"2xx\", \"100,300,600\" or \"100-299,6xx\" are supported. * <code>BlackListedHeaders</code> = Defines a list from headers which will excluded from the saved mappings. * <code>ClientX509Certificate2ThumbprintOrSubjectName</code> = The clientCertificate thumbprint or subject name fragment to use. * <code>WebProxySettings</code> = Defines the WebProxySettings. * <code>AllowAutoRedirect</code> = Proxy requests should follow redirection (30x). Default null / false. * <code>UseDefinedRequestMatchers</code> = When SaveMapping is set to true, this setting can be used to control the behavior of the generated request matchers for the new mapping. * <code>AppendGuidToSavedMappingFile</code> = Append an unique GUID to the filename from the saved mapping file. * <code>ReplaceSettings</code> = Defines the ProxyUrlReplaceSettings.</p>"},{"location":"dotnet/Settings/#webproxysettings","title":"WebProxySettings","text":"<ul> <li><code>Address</code> = Contains the address of the proxy server.</li> <li><code>UserName</code> = The user name associated with the credentials.</li> <li><code>Password</code> = The password for the user name associated with the credentials.</li> </ul>"},{"location":"dotnet/Settings/#proxyurlreplacesettings","title":"ProxyUrlReplaceSettings","text":"<p>This setting defines an old path param and a new path param to be replaced in the Url when proxying.</p> <ul> <li><code>OldValue</code> = The old path value to be replaced.</li> <li><code>NewValue</code> = The new path value to use.</li> <li><code>IgnoreCase</code> = Defines if the case should be ignore when replacing.</li> </ul>"},{"location":"dotnet/Settings/#example","title":"Example:","text":"<p>When you a request like <code>localhost:9095/earth/story/20170510-terrifying-20m-tall-rogue-waves-are-actually-real</code>, this request is proxied to the <code>bbc.com</code> and the mapping definition is saved to <code>__admin\\mappings\\ab38efae-4e4d-4f20-8afe-635533ec2535.json</code>.</p>"},{"location":"dotnet/Settings/#urls","title":"Urls","text":"<p>The URLs to listen on, if this is defined the port setting is not used.</p>"},{"location":"dotnet/Settings/#starttimeout","title":"StartTimeout","text":"<p>The StartTimeout from WireMock.Net, default 10 seconds.</p>"},{"location":"dotnet/Settings/#allowpartialmapping","title":"AllowPartialMapping","text":"<p>Defines if the matching should be done with exact matching or partial matching. Partial matching means that the best matching mapping is used for a input request. In case this setting is set to null or false, only Exact matching is done. This means that only when an exact 100% match is found for an input request, the response is handled. Else you get a error (404). This setting is default set to false.</p>"},{"location":"dotnet/Settings/#allowcsharpcodematcher_1","title":"AllowCSharpCodeMatcher","text":"<p>Allow the usage of CSharpCodeMatcher (default is not allowed).</p>"},{"location":"dotnet/Settings/#allowbodyforallhttpmethods","title":"AllowBodyForAllHttpMethods","text":"<p>Allow a Body for all HTTP Methods. (default set to false).</p>"},{"location":"dotnet/Settings/#allowanyhttpstatuscodeinresponse","title":"AllowAnyHttpStatusCodeInResponse","text":"<p>Allow any HttpStatusCode in the response. Also null, 0, empty or invalid. (default set to false). Note : this will not work when hosting a Docker container in Azure</p>"},{"location":"dotnet/Settings/#allowedcustomhandlebarhelpers","title":"AllowedCustomHandlebarHelpers","text":"<p>Defines the allowed custom HandlebarHelpers which can be used. Possible values are <code>None</code>, <code>File</code> and <code>All</code>. By default it's <code>None</code>.</p>"},{"location":"dotnet/Settings/#adminusername","title":"AdminUsername","text":"<p>The username needed for __admin access.</p>"},{"location":"dotnet/Settings/#adminpassword","title":"AdminPassword","text":"<p>The password needed for __admin access.</p>"},{"location":"dotnet/Settings/#adminazureadtenant","title":"AdminAzureADTenant","text":"<p>The AzureAD Tenant needed for __admin access.</p>"},{"location":"dotnet/Settings/#adminazureadtenant_1","title":"AdminAzureADTenant","text":"<p>The AzureAD Audience / Resource for __admin access.</p>"},{"location":"dotnet/Settings/#requestlogexpirationduration","title":"RequestLogExpirationDuration","text":"<p>The RequestLog expiration in hours (optional).</p>"},{"location":"dotnet/Settings/#maxrequestlogcount","title":"MaxRequestLogCount","text":"<p>The MaxRequestLog count (optional).</p>"},{"location":"dotnet/Settings/#disablejsonbodyparsing","title":"DisableJsonBodyParsing","text":"<p>Set to true to disable Json deserialization when processing requests. (default set to false).</p>"},{"location":"dotnet/Settings/#disablerequestbodydecompressing","title":"DisableRequestBodyDecompressing","text":"<p>Disable support for GZip and Deflate request body decompression. (default set to false).</p>"},{"location":"dotnet/Settings/#handlerequestssynchronously","title":"HandleRequestsSynchronously","text":"<p>Handle all requests synchronously. This could solve some issues when running multiple unit tests using 1 WireMock.Net instance. (default set to false).</p>"},{"location":"dotnet/Settings/#throwexceptionwhenmatcherfails","title":"ThrowExceptionWhenMatcherFails","text":"<p>Throw an exception when a Matcher fails because of invalid input. (default set to false).</p>"},{"location":"dotnet/Settings/#prewiremockmiddlewareinit","title":"PreWireMockMiddlewareInit","text":"<p>Action which is called (with the IAppBuilder or IApplicationBuilder) before the internal WireMockMiddleware is initialized. [Optional]</p>"},{"location":"dotnet/Settings/#postwiremockmiddlewareinit","title":"PostWireMockMiddlewareInit","text":"<p>Action which is called (with the IAppBuilder or IApplicationBuilder) after the internal WireMockMiddleware is initialized. [Optional]</p>"},{"location":"dotnet/Settings/#additionalserviceregistration","title":"AdditionalServiceRegistration","text":"<p>Action which is called with IServiceCollection when ASP.NET Core DI is being configured. [Optional]</p>"},{"location":"dotnet/Settings/#useregexextended","title":"UseRegexExtended","text":"<p>Use the RegexExtended instead of the default Regex.</p>"},{"location":"dotnet/Settings/#logger","title":"Logger","text":"<p>The IWireMockLogger interface which logs Debug, Info, Warning or Error.</p> <p>By default this is implemented by a default console logger WireMockConsoleLogger.cs.</p> <p>But also a Null logger is available WireMockNullLogger.cs.</p> <p>And you can implement your own logger, like WireMockLog4NetLogger.cs.</p>"},{"location":"dotnet/Settings/#filesystemhandler","title":"FileSystemHandler","text":"<p>Handler to interact with the file system to read and write static mapping files.</p> <p>By default this is implemented by the LocalFileSystemHandler.cs, however you can implement your own version as defined here as an example CustomFileSystemFileHandler.cs.</p> <p>Implementing your own version from this FileSystemHandler can be useful when running in Azure or Docker Containers.</p>"},{"location":"dotnet/Settings/#corspolicyoptions","title":"CorsPolicyOptions","text":"<p>Policies to use when using CORS. By default CORS is disabled. [Optional] This is a Enum Flag with these values: - None - AllowAnyHeader - AllowAnyMethod - AllowAnyOrigin - AllowAll</p>"},{"location":"dotnet/Stubbing/","title":"Stubbing","text":"<p>Documentation / dotnet / Stubbing</p>"},{"location":"dotnet/Stubbing/#stubbing","title":"Stubbing","text":"<p>The core feature of WireMock is the ability to return predefined HTTP responses for requests matching criteria.</p>"},{"location":"dotnet/Stubbing/#start-a-server","title":"Start a server","text":"<p>First thing first, to start a server it is as easy as calling a static method, and your done! C#<pre><code>var server = WireMockServer.Start();\n</code></pre> You can pass as an argument a port number but if you do not an available port will be chosen for you. Hence the above line of code start a server bounded to localhost a random port. To know on which port your server is listening, just use server property Port.</p>"},{"location":"dotnet/Stubbing/#basic-stubbing","title":"Basic stubbing","text":"<p>The following code will configure a response with a status of 200 to be returned when the relative URL exactly matches /some/thing (including query parameters). The body of the response will be \u201cHello world!\u201d and a Content-Type header will be sent with a value of text-plain.</p>"},{"location":"dotnet/Stubbing/#c-example","title":"C# example","text":"<p>C#<pre><code>var server = WireMockServer.Start();\n\nserver\n  .Given(\n    Request.Create().WithPath(\"/some/thing\").UsingGet()\n  )\n  .RespondWith(\n    Response.Create()\n      .WithStatusCode(200)\n      .WithHeader(\"Content-Type\", \"text/plain\")\n      .WithBody(\"Hello world!\")\n  );\n</code></pre> HTTP methods currently supported are: GET, POST, PUT, DELETE, HEAD. You can specify ANY (<code>.UsingAny</code>) if you want the stub mapping to match on any request method.</p>"},{"location":"dotnet/Stubbing/#json-mapping-example","title":"Json Mapping example","text":"<p>The same mapping as above, expressed in a json mapping:</p> JSON<pre><code>{\n    \"Request\": {\n        \"Path\": {\n            \"Matchers\": [\n                {\n                    \"Name\": \"WildcardMatcher\",\n                    \"Pattern\": \"/some/thing\"\n                }\n            ]\n        },\n        \"Methods\": [\n            \"get\"\n        ]\n    },\n    \"Response\": {\n        \"StatusCode\": 200,\n        \"Body\": \"Hello world!\",\n        \"Headers\": {\n            \"Content-Type\": \"text/plain\"\n        }\n    }\n}\n</code></pre> <p>More details on the json mapping API can be found here : Admin-API-Reference.</p>"},{"location":"dotnet/Stubbing/#c-example-for-a-body-with-bytes","title":"C# Example for a body with bytes","text":"<p>A response body in binary format can also be specified as a <code>byte[]</code> via an overloaded <code>WithBody()</code>:</p> C#<pre><code>var server = WireMockServer.Start();\nserver\n  .Given(\n    Request.Create().WithPath(\"/some/thing\").UsingGet()\n  )\n  .RespondWith(\n    Response.Create()\n      .WithBody(new byte[] { 48, 65, 6c, 6c, 6f })\n  );\n</code></pre>"},{"location":"dotnet/Stubbing/#stub-priority","title":"Stub priority","text":"<p>It is sometimes the case that you\u2019ll want to declare two or more stub mappings that \"overlap\", in that a given request would be a match for more than one of them.</p> <p>One example of this might be where you want to define a catch-all stub for any URL that doesn\u2019t match any more specific cases. Adding a priority to a stub mapping facilitates this:</p> C#<pre><code>var server = WireMockServer.Start();\n\n// Catch-all case\nserver\n  .Given(Request.Create().WithPath(\"/api/*\"))\n  .AtPriority(100)\n  .RespondWith(Responses.Create().WithStatusCode(401));\n\n// Specific case\nserver\n  .Given(Request.Create().WithPath(\"/api/specific-resource\"))\n  .AtPriority(1)\n  .RespondWith(Responses.Create().WithStatusCode(200));\n</code></pre> <p>:notes: - A lower value for the priority means a higher priority.</p>"},{"location":"dotnet/Stubbing/#verify-interactions","title":"Verify interactions","text":"<p>The server keeps a log of the received requests. You can use this log to verify the interactions that have been done with the server during a test. To get all the request received by the server, you just need to read property LogEntries: C#<pre><code>var logEntries = server.LogEntries;\n</code></pre> If you need to be more specific on the requests that have been send to the server, you can use the very same fluent API that allows to define routes: C#<pre><code>var customerReadRequests = server.FindLogEntries(\n    Request.Create().WithPath(\"/api/customer*\").UsingGet()\n); \n</code></pre></p>"},{"location":"dotnet/Stubbing/#simulating-delays","title":"Simulating delays","text":"<p>A server can be configured with a global delay that will be applied to all requests. To do so you need to call method WireMockServer.AddRequestProcessingDelay() as below: C#<pre><code>var server = WireMockServer.Start();\n\n// add a delay of 30 seconds for all requests\nserver.AddRequestProcessingDelay(TimeSpan.FromSeconds(30));\n</code></pre></p> <p>Delays can also be configured at route level: C#<pre><code>var server = WireMockServer.Start();\nserver\n  .Given(Request.Create().WithPath(\"/slow\"))\n  .RespondWith(\n    Responses.Create()\n      .WithStatusCode(200)\n      .WithBody(@\"{ \"\"msg\"\": \"\"Hello I'm a little bit slow!\"\" }\")\n      .WithDelay(TimeSpan.FromSeconds(10)\n    )\n  );\n</code></pre></p>"},{"location":"dotnet/Stubbing/#reset","title":"Reset","text":"<p>The WireMock server can be reset at any time, removing all stub mappings and deleting the request log. If you\u2019re using either of the UnitTest rules this will happen automatically at the start of every test case. However you can do it yourself via a call to <code>server.Reset()</code>.</p>"},{"location":"dotnet/Stubbing/#getting-all-currently-registered-stub-mappings","title":"Getting all currently registered stub mappings","text":"<p>All stub mappings can be fetched in C# by calling <code>server.Mappings</code> or <code>server.MappingModels</code>.</p>"},{"location":"dotnet/Using-HTTPS-%28SSL%29/","title":"Using HTTPS (SSL)","text":"<p>Documentation / dotnet / Using-HTTPS-(SSL)</p>"},{"location":"dotnet/Using-HTTPS-%28SSL%29/#http-ssl","title":"HTTP (SSL)","text":"<p>You can start a standalone mock server listening for HTTPS requests. To do so, there is just a flag to set when creating the server: C#<pre><code>var server1 = WireMockServer.Start(port: 8443, ssl: true);\n\n// or like this\n\nvar server2 = WireMockServer.Start(new WireMockServerSettings\n{\n    Urls = new[] { \"http://localhost:9091\", \"https://localhost:9443\" }\n});\n</code></pre></p>"},{"location":"dotnet/Using-HTTPS-%28SSL%29/#https-and-certificates","title":"HTTPS and certificates","text":"<p>WireMock.NET provides flexible support for SSL certificates through the following methods: - Using the Certificate Store - Loading a PFX certificate from the file system - Utilizing an in-memory <code>X509Certificate2</code> instance</p> <p>See WIKI : Settings - Certificate Settings for details.</p>"},{"location":"dotnet/Using-HTTPS-%28SSL%29/#windows","title":"Windows","text":""},{"location":"dotnet/Using-HTTPS-%28SSL%29/#net-standard-net-core","title":".NET Standard / .NET Core","text":"<p>In case you don't have a self-signed certificate yet, run the following command: Text Only<pre><code>dotnet dev-certs https --trust\n</code></pre></p> <p>WireMock.Net will now use this self signed certificate which can be overridden if you like to host https urls.</p>"},{"location":"dotnet/Using-HTTPS-%28SSL%29/#net-452-net-46","title":".NET 4.5.2 / .NET 4.6","text":"<p>In case when using .NET 4.5.2 or .NET 4.6, you need a certificate registered on your box, properly associated with your application and the port number that will be used. This is not really specific to WireMock.Net, not very straightforward and hence the following StackOverflow thread might come handy: Httplistener with https support.</p>"},{"location":"dotnet/Using-HTTPS-%28SSL%29/#linux","title":"Linux","text":"<p>In case of Linux or running WireMock.Net inside a Linux Docker container, apply the next steps:</p> <ol> <li> <p>Make the <code>localhost.conf</code> file of content: INI<pre><code>[req]\ndefault_bits       = 2048\ndefault_keyfile    = localhost.key\ndistinguished_name = req_distinguished_name\nreq_extensions     = req_ext\nx509_extensions    = v3_ca\n\n[req_distinguished_name]\ncommonName         = Common Name (e.g. server FQDN or YOUR name)\n\n[req_ext]\nsubjectAltName = @alt_names\n\n[v3_ca]\nsubjectAltName = @alt_names\nbasicConstraints = critical, CA:false\nkeyUsage = keyCertSign, cRLSign, digitalSignature,keyEncipherment\nextendedKeyUsage = 1.3.6.1.5.5.7.3.1\n1.3.6.1.4.1.311.84.1.1 = DER:01\n\n[alt_names]\nDNS.1   = localhost\nDNS.2   = 127.0.0.1\n ```\n\nNote the `1.3.6.1.4.1.311.84.1.1 = DER:01` it is critical for aspnet for [recognizing](https://github.com/dotnet/aspnetcore/blob/c75b3f7a2fb9fe21fd96c93c070fdfa88a2fbe97/src/Shared/CertificateGeneration/CertificateManager.cs#L81) the cert.\n\n2. Generate the cert:\n``` sh\nopenssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout localhost.key -out localhost.crt -config localhost.conf -subj /CN=localhost\nopenssl pkcs12 -export -out localhost.pfx -inkey localhost.key -in localhost.crt -passout pass:\n</code></pre></p> </li> <li> <p>Grab the <code>localhost.pfx</code> and <code>localhost.crt</code> and copy these files into the target system. In case of <code>Docker</code> that would look: Docker<pre><code>COPY localhost.crt /usr/local/share/ca-certificates/\nRUN dotnet dev-certs https --clean \\\n    &amp;&amp; update-ca-certificates\nCOPY localhost.pfx /root/.dotnet/corefx/cryptography/x509stores/my/\n</code></pre></p> </li> <li> <p>Profit. The system has the aspnetcore dev cert trusted.</p> </li> </ol> <p>See also this wiremock.net-https-demo-project.</p>"},{"location":"dotnet/Using-WireMock-in-UnitTests/","title":"Using WireMock in UnitTests","text":"<p>Documentation / dotnet / Using-WireMock-in-UnitTests</p>"},{"location":"dotnet/Using-WireMock-in-UnitTests/#wiremock-with-your-favorite-unittest-framework","title":"WireMock with your favorite UnitTest framework","text":"<p>Obviously you can use your favorite test framework and use WireMock.Net within your tests. In order to avoid flaky tests you should:   - let WireMock.Net choose ports dynamically. Avoid hard coded ports in your tests. This can cause issues when running these unit-tests on a build-server, there is not 100% guarantee that this port will be free on the OS.   - clean up the request log or shutdown the server at the end of each test</p> <p>Below a simple example using Nunit and NFluent test assertion library: C#<pre><code>[SetUp]\npublic void StartMockServer()\n{\n    _server = WireMockServer.Start();\n}\n\n[Test]\npublic async Task Should_respond_to_request()\n{\n  // Arrange (start WireMock.Net server)\n  _server\n    .Given(Request.Create().WithPath(\"/foo\").UsingGet())\n    .RespondWith(\n      Response.Create()\n        .WithStatusCode(200)\n        .WithBody(@\"{ \"\"msg\"\": \"\"Hello world!\"\" }\")\n    );\n\n  // Act (use a HttpClient which connects to the URL where WireMock.Net is running)\n  var response = await new HttpClient().GetAsync($\"{_server.Urls[0]}/foo\");\n\n  // Assert\n  Check.That(response).IsEqualTo(EXPECTED_RESULT);\n}\n\n[TearDown]\npublic void ShutdownServer()\n{\n    _server.Stop();\n}\n</code></pre></p> <p>For some more examples: see https://github.com/bredah/csharp-wiremock</p>"},{"location":"dotnet/Using-WireMock.Net.Aspire/","title":"Using WireMock.Net.Aspire","text":"<p>Documentation / dotnet / Using-WireMock.Net.Aspire More details to follow...</p> <p>For example code see: https://github.com/WireMock-Net/WireMock.Net/tree/master/examples-Aspire</p> <p>For some more info, see: https://mstack.nl/blogs/wiremock-net-aspire-component/</p>"},{"location":"dotnet/Using-WireMock.Net.Testcontainers/","title":"Using WireMock.Net.Testcontainers","text":"<p>Documentation / dotnet / Using-WireMock.Net.Testcontainers</p>"},{"location":"dotnet/Using-WireMock.Net.Testcontainers/#wiremocknettestcontainers","title":"WireMock.Net.Testcontainers","text":"<p>WireMock.Net.Testcontainers uses Testcontainers for .NET to spinup a docker container directly from the C# (unittest) code. </p> <p>This options requires docker service running locally.</p> <p>Both the Linux and the Windows version from WireMock.Net are supported <sup>:memo:</sup>.</p> <p>:memo: It's not needed to specify the version, this is determined automatically. (So if you are running Docker on a Windows Host, the Windows Docker image is used, else the Linux Docker image is used. </p>"},{"location":"dotnet/Using-WireMock.Net.Testcontainers/#usage","title":"Usage","text":""},{"location":"dotnet/Using-WireMock.Net.Testcontainers/#build-and-start","title":"Build and Start","text":"<p>To build a container and startup this container, use this code: C#<pre><code>var container = new WireMockContainerBuilder()\n    .WithAutoRemove(true)\n    .WithCleanUp(true)\n    .Build();\n\nawait container.StartAsync().ConfigureAwait(false);\n</code></pre></p>"},{"location":"dotnet/Using-WireMock.Net.Testcontainers/#methods","title":"Methods","text":"<p>The following builder methods are available for the <code>WireMockContainerBuilder</code>:</p> Method Example What <code>WithMappings</code> <code>.WithMappings(@\"C:\\example\\\\mappings\")</code> Specifies the path for the (static) mapping json files. <code>WithWatchStaticMappings</code> <code>.WithWatchStaticMappings(true)</code> Watch the static mapping files + folder for changes when running. <code>WithAdminUserNameAndPassword</code> <code>.WithAdminUserNameAndPassword(\"x\", \"y\")</code> Set the admin username. and password for the container (basic authentication). <code>WithImage</code> <code>.WithImage(\"sheyenrath/wiremock.net-alpine:1.6.4\")</code> You can provide a specific image + tag."},{"location":"dotnet/Using-WireMock.Net.Testcontainers/#create-a-admin-client","title":"Create a Admin Client","text":"<p>Use the following code to get a RestEase Admin Client for this running container instance. C#<pre><code>var restEaseApiClient = container.CreateWireMockAdminClient();\n</code></pre></p>"},{"location":"dotnet/Using-WireMock.Net.Testcontainers/#create-a-http-client","title":"Create a HTTP Client","text":"<p>Use the following code to get a HTTP Client for this running container instance to call WireMock.Net C#<pre><code>var client = container.CreateClient();\nvar result = await client.GetStringAsync(\"/test123\");\n</code></pre></p>"},{"location":"dotnet/Using-WireMock.Net.Testcontainers/#usage-in-unit-test","title":"Usage in Unit Test","text":"<p>Follow the tutorial here and make sure to use WireMock.Net container instead of the container used in that example.</p>"},{"location":"dotnet/Webhook/","title":"Webhook","text":"<p>Documentation / dotnet / Webhook</p>"},{"location":"dotnet/Webhook/#macro-rendering-error","title":"Macro Rendering Error","text":"<p>File: <code>dotnet/Webhook.md</code></p> <p>UndefinedError: 'request' is undefined</p> Text Only<pre><code>Traceback (most recent call last):\n  File \"/home/muna/Desktop/wiremock-documentation/venv/lib/python3.11/site-packages/mkdocs_macros/plugin.py\", line 688, in render\n    return md_template.render(**page_variables)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/home/muna/Desktop/wiremock-documentation/venv/lib/python3.11/site-packages/jinja2/environment.py\", line 1295, in render\n    self.environment.handle_exception()\n  File \"/home/muna/Desktop/wiremock-documentation/venv/lib/python3.11/site-packages/jinja2/environment.py\", line 942, in handle_exception\n    raise rewrite_traceback_stack(source=source)\n  File \"&lt;template&gt;\", line 69, in top-level template code\n  File \"/home/muna/Desktop/wiremock-documentation/venv/lib/python3.11/site-packages/jinja2/environment.py\", line 490, in getattr\n    return getattr(obj, attribute)\n           ^^^^^^^^^^^^^^^^^^^^^^^\njinja2.exceptions.UndefinedError: 'request' is undefined\n</code></pre>"},{"location":"dotnet/What-Is-WireMock.Net/","title":"What is WireMock.Net","text":"<p>Documentation / dotnet / What-Is-WireMock.Net</p>"},{"location":"dotnet/What-Is-WireMock.Net/#what-is-wiremocknet","title":"What Is WireMock.Net?","text":"<p>WireMock.Net is a tool which mimics the behaviour of an HTTP API, it captures the HTTP requests and sends it to WireMock.Net HTTP server, which is started and as a result, we can setup expectations, call the service and then verify its behaviour.</p>"},{"location":"dotnet/What-Is-WireMock.Net/#when-should-we-use-wiremocknet","title":"When Should We Use WireMock.Net?","text":"<p>Below are three situations when we should use WireMock.Net:</p>"},{"location":"dotnet/What-Is-WireMock.Net/#1-http-dependencies-not-ready","title":"1. <code>HTTP Dependencies Not Ready</code>","text":"<p>An engineering team needs to implement a feature which uses an HTTP API that is not ready, this occurs often in an microservice based architecture.</p> <p>To avoid engineering waste, you can mimic the behaviour of the HTTP API using WireMock.Net and then replace the call to WireMock.Net API to the actual API. </p>"},{"location":"dotnet/What-Is-WireMock.Net/#2-unit-test-classes-which-use-http-apis","title":"2. <code>Unit Test classes which use HTTP APIs</code>","text":"<p>Scenario: <code>Class A -&gt; depends on -&gt; Class B -&gt; depends on -&gt; HTTP API</code></p> <p>We want to unit test for Class A.</p> <p>Option1: Replace depend Class B with a MockObject when unit testing Class A.</p> <p>However, if the API client is written by you, using a mock object is not a good choice because it does not allow us to verify that our code can communicate with the HTTP API. </p> <p><code>Sociable Tests</code></p> <p>Therefore, Class A &amp; Class B should be tested as one unit and as a result we can verify that the correct information is send to the HTTP API and ensure that all legal responses can be processed by both Class A &amp; Class B.</p>"},{"location":"dotnet/What-Is-WireMock.Net/#3-integration-or-end-to-end-tests-using-external-http-apis","title":"3. <code>Integration or End-to-end tests using external HTTP APIs</code>","text":"<p><code>Dependency Down</code></p> <p>External HTTP API cannot initialise into a known state before the tests are run. Therefore, we cannot write tests which use the data returned by the external HTTP API, as it can differ.</p> <p><code>Slow tests</code> </p> <p>External HTTP API takes longer than getting the same response from WireMock.Net and we cannot use a short timeout because the test will fail, when the call is timed out.</p> <p><code>API Requests Blocked</code></p> <p>Wrong network connection, the API request which does not come from a known IP address is blocked.</p>"},{"location":"dotnet/What-Is-WireMock.Net/#to-write-fast-and-consistent-tests-for-http-apis-we-should-be-using-wiremocknet","title":"To write fast and consistent tests for HTTP APIs we should be using WireMock.Net.","text":""},{"location":"dotnet/What-Is-WireMock.Net/#however-wiremocknet-cannot-guarantee-that-our-application-is-compatible-with-the-consumed-http-api","title":"However, WireMock.Net cannot guarantee that our application is compatible with the consumed HTTP API.","text":"<p>The WireMock.Net tests will ensure  1.  Our application sends the expected requests to the used HTTP API. 2.  Our application is working as expected when it receives an expected response from the HTTP API. It is important that our expectations are correct otherwise those tests can be false positive.  </p>"},{"location":"dotnet/What-Is-WireMock.Net/#summary-of-what-wiremocknet-offers","title":"Summary of what WireMock.Net Offers","text":"<ol> <li>Configure the response returned by the HTTP API when it receives a specific request.</li> <li>Capture the incoming HTTP requests and write assertions for that requests.</li> <li>Identify the stubbed or captured HTTP requests by using request matching</li> <li>Configure request matchers by comparing the request.</li> <li>URL, path, request method, request headers, cookies and request body</li> <li>Run it as a standalone process. (flexible deployments)</li> <li>Or integrate it in your unit-tests</li> <li>Redirect HTTP Requests to another location, record and playbacks</li> <li>Support edge case failures</li> </ol> <p>Note: this page is based on https://github.com/AdriseYounis/WireMock.Net/blob/master/README.md</p>"},{"location":"dotnet/WireMock-as-a-%28Azure%29-Web-App/","title":"WireMock as a (Azure) Web App","text":"<p>Documentation / dotnet / WireMock-as-a-(Azure)-Web-App It's also possible to run WireMock as a Web-Application on Azure or IIS.</p>"},{"location":"dotnet/WireMock-as-a-%28Azure%29-Web-App/#references","title":"References","text":"<ul> <li>https://weblog.west-wind.com/posts/2016/Jun/06/Publishing-and-Running-ASPNET-Core-Applications-with-IIS</li> <li>https://docs.microsoft.com/en-us/aspnet/core/host-and-deploy/iis/development-time-iis-support?view=aspnetcore-2.1</li> <li>https://github.com/WireMock-Net/WireMock.Net/blob/master/examples/WireMock.Net.WebApplication.NETCore3/readme.md</li> <li>https://github.com/WireMock-Net/WireMock.Net/issues/564</li> </ul>"},{"location":"dotnet/WireMock-as-a-%28Azure%29-Web-App/#wiremockservice","title":"WireMockService","text":""},{"location":"dotnet/WireMock-as-a-%28Azure%29-Web-App/#code","title":"Code","text":"<p>See this code example how a App-Service could look:</p> C#<pre><code>public class WireMockService : IWireMockService\n{\n    private static int sleepTime = 30000;\n    private readonly ILogger _logger;\n    private readonly IWireMockServerSettings _settings;\n\n    private class Logger : IWireMockLogger\n    {\n        // Implement all methods from the IWireMockLogger here ...\n    }\n\n    public WireMockService(ILogger logger, IWireMockServerSettings settings)\n    {\n        _logger = logger;\n        _settings = settings;\n\n        _settings.Logger = new Logger(logger);\n    }\n\n    public void Run()\n    {\n        _logger.LogInformation(\"WireMock.Net server starting\");\n\n        StandAloneApp.Start(_settings);\n\n        _logger.LogInformation($\"WireMock.Net server settings {JsonConvert.SerializeObject(_settings)}\");\n\n        while (true)\n        {\n            _logger.LogInformation(\"WireMock.Net server running\");\n            Thread.Sleep(sleepTime);\n        }\n    }\n}\n</code></pre>"},{"location":"dotnet/WireMock-as-a-%28Azure%29-Web-App/#webconfig","title":"Web.Config","text":"XML<pre><code>&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;configuration&gt;\n  &lt;!--\n    Configure your application settings in appsettings.json. Learn more at http://go.microsoft.com/fwlink/?LinkId=786380\n  --&gt;\n  &lt;system.webServer&gt;\n    &lt;handlers&gt;\n      &lt;add name=\"aspNetCore\" path=\"*\" verb=\"*\" modules=\"AspNetCoreModuleV2\" resourceType=\"Unspecified\" /&gt;\n    &lt;/handlers&gt;\n    &lt;aspNetCore processPath=\"%LAUNCHER_PATH%\" arguments=\"%LAUNCHER_ARGS%\" stdoutLogEnabled=\"false\" stdoutLogFile=\".\\logs\\stdout\" forwardWindowsAuthToken=\"false\" /&gt;\n  &lt;/system.webServer&gt;\n&lt;/configuration&gt;\n</code></pre>"},{"location":"dotnet/WireMock-as-a-%28Azure%29-Web-App/#example-on-windows","title":"Example on Windows","text":"<p>For a full working example, see examples\\WireMock.Net.WebApplication.NETCore3</p>"},{"location":"dotnet/WireMock-as-a-%28Azure%29-Web-App/#publish-settings","title":"Publish Settings","text":""},{"location":"dotnet/WireMock-as-a-%28Azure%29-Web-App/#example-on-linux","title":"Example on Linux","text":"<p>For a full working example, see examples\\WireMock.Net.WebApplication.NET6</p>"},{"location":"dotnet/WireMock-as-a-%28Azure%29-Web-App/#publish-settings_1","title":"Publish settings:","text":""},{"location":"dotnet/WireMock-as-a-Windows-Service/","title":"WireMock as a Windows Service","text":"<p>Documentation / dotnet / WireMock-as-a-Windows-Service It's also possible to wrap WireMock in a Windows Service.</p>"},{"location":"dotnet/WireMock-as-a-Windows-Service/#programcs","title":"Program.cs","text":"<p>Create a Program.cs with the following content:</p> C#<pre><code>public static class Program\n{\n    #region Nested classes to support running as service\n    public const string ServiceName = \"Wiremock.Net.Service\";\n\n    public class Service : ServiceBase\n    {\n        public Service()\n        {\n            ServiceName = Program.ServiceName;\n        }\n\n        protected override void OnStart(string[] args)\n        {\n            Start();\n        }\n\n        protected override void OnStop()\n        {\n            Program.Stop();\n        }\n    }\n    #endregion\n\n    private static WireMockServer _server;\n\n    static void Main(string[] args)\n    {\n        // running as service\n        if (!Environment.UserInteractive)\n        {\n            using (var service = new Service())\n            {\n                ServiceBase.Run(service);\n            }\n        }\n        else\n        {\n            // running as console app\n            Start();\n\n            Console.WriteLine(\"Press any key to stop...\");\n            Console.ReadKey(true);\n\n            Stop();\n        }\n    }\n\n    private static void Start()\n    {\n        _server = StandAloneApp.Start(new FluentMockServerSettings\n        {\n            Urls = new[] { \"http://*:9091/\" },\n            StartAdminInterface = true,\n            ReadStaticMappings = true,\n            Logger = new WireMockConsoleLogger()\n        });\n    }\n\n    private static void Stop()\n    {\n        _server.Stop();\n    }\n}\n</code></pre> <p>When you start the exe file in Visual Studio or from the commandline, the application will behave same like WireMock-as a standalone process.</p>"},{"location":"dotnet/WireMock-as-a-Windows-Service/#example","title":"Example","text":"<p>For a full working example which also provides an Installer and batch-files to  * Install * Start * Stop * Uninstall</p> <p>the service, see examples/WireMock.Net.Service.</p>"},{"location":"dotnet/WireMock-as-a-standalone-process/","title":"WireMock as a standalone process","text":"<p>Documentation / dotnet / WireMock-as-a-standalone-process</p>"},{"location":"dotnet/WireMock-as-a-standalone-process/#wiremock-as-a-standalone-process","title":"WireMock as a standalone process","text":"<p>This is quite straight forward to launch a mock server within a console application.</p>"},{"location":"dotnet/WireMock-as-a-standalone-process/#option-1-using-the-wiremocknetstandalone-library","title":"Option 1 : using the WireMock.Net.StandAlone library.","text":"<p>(https://www.nuget.org/packages/WireMock.Net.StandAlone/) C#<pre><code>class Program\n{\n    static void Main(string[] args)\n    {\n        StandAloneApp.Start(args);\n\n        Console.WriteLine(\"Press any key to stop the server\");\n        Console.ReadKey();\n    }\n}\n</code></pre></p> <p>See [[WireMock commandline parameters]] for all supported commandline arguments.</p>"},{"location":"dotnet/WireMock-as-a-standalone-process/#option-2-using-the-wiremocknetstandalone-library-using-the-settings-object","title":"Option 2 : using the WireMock.Net.StandAlone library using the settings object","text":"C#<pre><code>class Program\n{\n    static void Main(string[] args)\n    {\n        // see source code for all the possible properties\n        var settings = new WireMockServerSettings\n            {\n                AllowPartialMapping=true,\n                StartAdminInterface=true\n            };\n        StandAloneApp.Start(settings);\n\n        Console.WriteLine(\"Press any key to stop the server\");\n        Console.ReadKey();\n    }\n}\n</code></pre>"},{"location":"dotnet/WireMock-as-a-standalone-process/#option-3-coding-yourself","title":"Option 3 : coding yourself","text":"C#<pre><code>static void Main(string[] args)\n{\n    int port;\n    if (args.Length == 0 || !int.TryParse(args[0], out port))\n        port = 8080;\n\n    var server = WireMockServer.Start(port);\n    Console.WriteLine(\"WireMockServer running at {0}\", string.Join(\",\", server.Ports));\n\n    // Order of rules matters. First matching is taken.\n    server\n        .Given(Request.Create().WithPath(u =&gt; u.Contains(\"x\")).UsingGet())\n        .RespondWith(Response.Create()\n            .WithStatusCode(200)\n            .WithHeader(\"Content-Type\", \"application/json\")\n            .WithBody(@\"{ \"\"result\"\": \"\"/x with FUNC 200\"\"}\"));\n\n    server\n        .Given(Request.Create().WithPath(\"/*\").UsingGet())\n        .RespondWith(Response.Create()\n            .WithStatusCode(200)\n            .WithHeader(\"Content-Type\", \"application/json\")\n            .WithBody(@\"{ \"\"msg\"\": \"\"Hello world!\"\"}\")\n        );\n\n    server\n        .Given(Request.Create().WithPath(\"/data\").UsingPost().WithBody(b =&gt; b.Contains(\"e\")))\n        .RespondWith(Response.Create()\n            .WithStatusCode(201)\n            .WithHeader(\"Content-Type\", \"application/json\")\n            .WithBody(@\"{ \"\"result\"\": \"\"data posted with FUNC 201\"\"}\"));\n\n    server\n        .Given(Request.Create().WithPath(\"/data\").UsingPost())\n        .RespondWith(Response.Create()\n            .WithStatusCode(201)\n            .WithHeader(\"Content-Type\", \"application/json\")\n            .WithBody(@\"{ \"\"result\"\": \"\"data posted with 201\"\"}\"));\n\n    server\n        .Given(Request.Create().WithPath(\"/data\").UsingDelete())\n        .RespondWith(Response.Create()\n            .WithStatusCode(200)\n            .WithHeader(\"Content-Type\", \"application/json\")\n            .WithBody(@\"{ \"\"result\"\": \"\"data deleted with 200\"\"}\"));\n\n    Console.WriteLine(\"Press any key to stop the server\");\n    Console.ReadKey();\n\n    Console.WriteLine(\"Displaying all requests\");\n    var allRequests = server.LogEntries;\n    Console.WriteLine(JsonConvert.SerializeObject(allRequests, Formatting.Indented));\n\n    Console.WriteLine(\"Press any key to quit\");\n    Console.ReadKey();\n}\n</code></pre>"},{"location":"dotnet/WireMock-as-a-standalone-process/#workaround-for-microsoftowinhosthttplistener-exception","title":"Workaround for Microsoft.Owin.Host.HttpListener exception","text":"<p>Note that when using WireMock in a NET 4.5x, NET 4.6.x project, you can get this exception when running your console application:</p> <p>Unhandled Exception: System.Exception: Service start failed with error: The server factory could not be located for &gt; the given input: Microsoft.Owin.Host.HttpListener ---&gt; System.MissingMemberException: The server factory could not be located for the given input: Microsoft.Owin.Host.HttpListener</p> <p>The solution is to add the <code>Microsoft.Owin.Host.HttpListener</code> (version 4.0.0) NuGet package to your hosting console application.</p>"},{"location":"dotnet/WireMock-as-dotnet-tool/","title":"WireMock as dotnet tool","text":"<p>Documentation / dotnet / WireMock-as-dotnet-tool</p>"},{"location":"dotnet/WireMock-as-dotnet-tool/#wiremock-as-dotnet-tool","title":"WireMock as dotnet tool","text":""},{"location":"dotnet/WireMock-as-dotnet-tool/#installation","title":"Installation","text":"<p>Install locally: Text Only<pre><code>dotnet tool install --global dotnet-wiremock\n</code></pre></p> <p>In case you also use private NuGet endpoints, follow this link to solve authentication errors.</p>"},{"location":"dotnet/WireMock-as-dotnet-tool/#usage","title":"Usage","text":"<p>Start the WireMock.Net server: Text Only<pre><code>dotnet-wiremock\n</code></pre></p> <p>See [[WireMock commandline parameters]] for all supported commandline arguments.</p>"},{"location":"dotnet/WireMock-commandline-parameters/","title":"WireMock commandline parameters","text":"<p>Documentation / dotnet / WireMock-commandline-parameters The following commandline arguments can be defined for: - [[WireMock as dotnet tool]] - [[WireMock as a standalone process]] - WireMock.Net running as Docker</p> <p></p>"},{"location":"dotnet/WireMock-commandline-parameters/#settings","title":"Settings","text":"Argument Name Value Type Default Description <code>--Help</code> Show a link to this wiki-page <code>--Port</code> integer wiki-port <code>--Urls</code> string wiki-urls <code>--StartAdminInterface</code> boolean true Defines whether to start admin interface. <code>--AllowPartialMapping</code> boolean false wiki-allowpartialmapping <code>--ReadStaticMappings</code> boolean false Defines if the static mappings should be read at startup. <code>--AdminUsername</code> string wiki-adminusername <code>--AdminPassword</code> string wiki-adminpassword <code>--MaxRequestLogCount</code> integer wiki-maxrequestlogcount <code>--RequestLogExpirationDuration</code> integer wiki-requestlogexpirationduration <code>--WireMockLogger</code> string WireMockNullLogger You can also define the value <code>WireMockConsoleLogger</code>. In that case the WireMockConsoleLogger is used. <code>--ProxyURL</code> string wiki-proxyandrecordsettings <code>--X509StoreName</code><code>--X509StoreLocation</code><code>--X509StoreThumbprintOrSubjectName</code><code>--X509CertificateFilePath</code><code>--X509CertificatePassword</code> stringstringstringstringstring wiki-certificatesettings"},{"location":"dotnet/WireMock-commandline-parameters/#proxy-settings-optional","title":"Proxy Settings [Optional]","text":"<p>See also Proxy and Record Settings for a complete list.</p> Argument Name Value Type Default Description <code>--ProxyUrl</code> string The URL to use for proxying. <code>--SaveMapping</code> boolean Save the mapping for each request/response to the internal Mappings.."},{"location":"dotnet/WireMock.Org/","title":"WireMock.Org","text":"<p>Documentation / dotnet / WireMock.Org</p>"},{"location":"dotnet/WireMock.Org/#info","title":"Info","text":"<p>This project mimics the functionality from the JAVA based WireMock.Org</p>"},{"location":"dotnet/WireMock.Org/#support","title":"Support","text":"<p>Note that there is some support for mappings generated by WireMock.Org. </p>"},{"location":"dotnet/WireMock.Org/#examples","title":"Examples","text":""},{"location":"dotnet/WireMock.Org/#get","title":"Get","text":"JSON<pre><code>{\n  \"id\" : \"ef53ea56-f118-4b3a-8c69-a9484851d99a\",\n  \"name\" : \"weatherforecast\",\n  \"request\" : {\n    \"url\" : \"/WeatherForecast\",\n    \"method\" : \"GET\"\n  },\n  \"response\" : {\n    \"status\" : 200,\n    \"body\" : \"[{\\\"date\\\":\\\"2021-09-09T20:44:48.0992639-03:00\\\",\\\"temperatureC\\\":51,\\\"temperatureF\\\":123,\\\"summary\\\":\\\"Hot\\\"},{\\\"date\\\":\\\"2021-09-10T20:44:48.0992692-03:00\\\",\\\"temperatureC\\\":34,\\\"temperatureF\\\":93,\\\"summary\\\":\\\"Mild\\\"},{\\\"date\\\":\\\"2021-09-11T20:44:48.0992696-03:00\\\",\\\"temperatureC\\\":43,\\\"temperatureF\\\":109,\\\"summary\\\":\\\"Sweltering\\\"},{\\\"date\\\":\\\"2021-09-12T20:44:48.0992698-03:00\\\",\\\"temperatureC\\\":46,\\\"temperatureF\\\":114,\\\"summary\\\":\\\"Cool\\\"},{\\\"date\\\":\\\"2021-09-13T20:44:48.0992701-03:00\\\",\\\"temperatureC\\\":3,\\\"temperatureF\\\":37,\\\"summary\\\":\\\"Freezing\\\"}]\",\n    \"headers\" : {\n      \"Date\" : \"Wed, 08 Sep 2021 23:44:47 GMT\",\n      \"Content-Type\" : \"application/json; charset=utf-8\",\n      \"Server\" : \"Kestrel\"\n    }\n  },\n  \"uuid\" : \"ef53ea56-f118-4b3a-8c69-a9484851d99a\",\n  \"persistent\" : true,\n  \"insertionIndex\" : 1\n}\n</code></pre>"},{"location":"dotnet/WireMock.Org/#post","title":"Post","text":"JSON<pre><code>{\n  \"id\" : \"365dd908-dc67-4f27-9e41-15d908206d81\",\n  \"name\" : \"weatherforecast_register-city\",\n  \"request\" : {\n    \"url\" : \"/WeatherForecast/register-city\",\n    \"method\" : \"POST\",\n    \"bodyPatterns\" : [ {\n      \"equalToJson\" : \"{ \\\"cityName\\\": \\\"S\u00e3o Paulo\\\", \\\"cityCode\\\": 5001 }\",\n      \"ignoreArrayOrder\" : true,\n      \"ignoreExtraElements\" : true\n    } ]\n  },\n  \"response\" : {\n    \"status\" : 200,\n    \"headers\" : {\n      \"Date\" : \"Wed, 08 Sep 2021 23:48:33 GMT\",\n      \"Server\" : \"Kestrel\"\n    }\n  },\n  \"uuid\" : \"365dd908-dc67-4f27-9e41-15d908206d81\",\n  \"persistent\" : true,\n  \"insertionIndex\" : 4\n}\n</code></pre>"},{"location":"dotnet/Xamarin---Could-not-load-file-or-assembly/","title":"Xamarin---Could-not-load-file-or-assembly","text":"<p>Documentation / dotnet / Xamarin---Could-not-load-file-or-assembly When using WireMock.Net in a Xamarin test project, you can encounter these errors:</p>"},{"location":"dotnet/Xamarin---Could-not-load-file-or-assembly/#could-not-load-file-or-assembly-systemmemory-version4010","title":"Could not load file or assembly 'System.Memory, Version=4.0.1.0","text":"Text Only<pre><code>WireMock.Exceptions.WireMockException : Service start failed with error: One or more errors occurred. (Could not load type of field 'Microsoft.AspNetCore.Server.Kestrel.Transport.Sockets.SocketTransportOptions:&lt;MemoryPoolFactory&gt;k__BackingField' (1) due to: Could not load file or assembly 'System.Memory, Version=4.0.1.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51' or one of its dependencies.)\n  ----&gt; System.AggregateException : One or more errors occurred. (Could not load type of field 'Microsoft.AspNetCore.Server.Kestrel.Transport.Sockets.SocketTransportOptions:&lt;MemoryPoolFactory&gt;k__BackingField' (1) due to: Could not load file or assembly 'System.Memory, Version=4.0.1.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51' or one of its dependencies.)\n  ----&gt; System.TypeLoadException : Could not load type of field 'Microsoft.AspNetCore.Server.Kestrel.Transport.Sockets.SocketTransportOptions:&lt;MemoryPoolFactory&gt;k__BackingField' (1) due to: Could not load file or assembly 'System.Memory, Version=4.0.1.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51' or one of its dependencies.\nTearDown : System.NullReferenceException : Object reference not set to an instance of an object\n</code></pre> <p>or</p> Text Only<pre><code>The operation failed.\nBind result: hr = 0x80070002. The system cannot find the file specified.\n\nAssembly manager loaded from:  C:\\Windows\\Microsoft.NET\\Framework\\v4.0.30319\\clr.dll\nRunning under executable  C:\\git\\WireMock.Net\\examples\\WireMock.Net.Console.Net461.Classic\\bin\\Debug\\WireMock.Net.Console.Net461.Classic.exe\n</code></pre>"},{"location":"dotnet/Xamarin---Could-not-load-file-or-assembly/#solutions","title":"Solutions:","text":""},{"location":"dotnet/Xamarin---Could-not-load-file-or-assembly/#1-adding-systemmemory-and-systemthreadingtasksextensions-as-nuget-references","title":"1. Adding System.Memory and System.Threading.Tasks.Extensions as NuGet references.","text":""},{"location":"dotnet/Xamarin---Could-not-load-file-or-assembly/#2-assembly-binding-redirects","title":"2. Assembly binding redirects","text":"<p>Adding assembly binding redirects to the app.config for the assemblies which have an error. Like: XML<pre><code>&lt;runtime&gt;\n    &lt;assemblyBinding xmlns=\"urn:schemas-microsoft-com:asm.v1\"&gt;\n      &lt;dependentAssembly&gt;\n        &lt;assemblyIdentity name=\"System.Buffers\" publicKeyToken=\"cc7b13ffcd2ddd51\" culture=\"neutral\" /&gt;\n        &lt;bindingRedirect oldVersion=\"4.0.2.0-4.0.3.0\" newVersion=\"4.0.3.0\" /&gt;\n      &lt;/dependentAssembly&gt;\n\n      &lt;dependentAssembly&gt;\n        &lt;assemblyIdentity name=\"System.Numerics.Vectors\" publicKeyToken=\"b03f5f7f11d50a3a\" culture=\"neutral\"/&gt;\n        &lt;bindingRedirect oldVersion=\"4.0.0.0-4.1.4.0\" newVersion=\"4.1.4.0\"/&gt;\n      &lt;/dependentAssembly&gt;\n    &lt;/assemblyBinding&gt;\n  &lt;/runtime&gt;\n</code></pre></p>"},{"location":"extensibility/adding_template_helpers/","title":"Adding Template Helpers","text":"<p>Documentation / extensibility / adding_template_helpers Extensions that implement the <code>TemplateHelperProviderExtension</code> interface provide additional Handlebars helpers to the templating system:</p> Java<pre><code>new WireMockServer(wireMockConfig().extensions(\n    new TemplateHelperProviderExtension() {\n        @Override\n        public String getName() {\n            return \"custom-helpers\";\n        }\n\n        @Override\n        public Map&lt;String, Helper&lt;?&gt;&gt; provideTemplateHelpers() {\n            Helper&lt;String&gt; helper = (context, options) -&gt; context.length();\n            return Map.of(\"string-length\", helper);\n        }\n    }\n));\n</code></pre> <p>This custom <code>string-length</code> helper will return the string length of the supplied parameter and is used like this:</p> Text Only<pre><code>{{string-length 'abcde'}}\n{{string-length request.body}}\n</code></pre>"},{"location":"extensibility/adding_template_model_data/","title":"Adding Template Model Data","text":"<p>Documentation / extensibility / adding_template_model_data Extensions that implement the <code>TemplateModelDataProviderExtension</code> interface provide additional model elements to the templating system:</p> Java<pre><code>new WireMockServer(.extensions(\n    new TemplateModelDataProviderExtension() {\n        @Override\n        public Map&lt;String, Object&gt; provideTemplateModelData(ServeEvent serveEvent) {\n            return Map.of(\n                \"mydata\", Map.of(\"path\", serveEvent.getRequest().getUrl()));\n        }\n\n        @Override\n        public String getName() {\n            return \"custom-model-data\";\n        }\n    }\n));\n</code></pre> <p>This can then be accessed via the templating system e.g.:</p> Handlebars<pre><code>{{mydata.path}}\n</code></pre>"},{"location":"extensibility/admin_api_extensions/","title":"Admin API Extensions","text":"<p>Documentation / extensibility / admin_api_extensions Additional API routes under WireMock's <code>/__admin</code> endpoint can be configured by implementing <code>AdminApiExtension</code>.</p>"},{"location":"extensibility/custom_matching/","title":"Custom Matching","text":"<p>Documentation / extensibility / custom_matching If WireMock's standard set of request matching strategies isn't sufficient, you can register one or more request matcher classes containing your own logic.</p> <p>Custom matchers can be attached directly to stubs via the Java API when using the local admin interface (by calling <code>stubFor(...)</code> on <code>WireMockServer</code> or <code>WireMockRule</code>). They can also be added via the extension mechanism and used with individual stubs by referring to them by name as described above for response transformers.</p> <p>As with response transformers, per stub mapping parameters can be passed to matchers.</p> <p>To add a matcher directly to a stub mapping:</p> Java<pre><code>wireMockServer.stubFor(requestMatching(new RequestMatcherExtension() {\n    @Override\n    public MatchResult match(Request request, Parameters parameters) {\n        return MatchResult.of(request.getBody().length &gt; 2048);\n    }\n}).willReturn(aResponse().withStatus(422)));\n</code></pre> <p>To use it in a verification :</p> Java<pre><code>verify(2, requestMadeFor(new ValueMatcher&lt;Request&gt;() {\n    @Override\n    public MatchResult match(Request request) {\n        return MatchResult.of(request.getBody().length &gt; 2048);\n    }\n}));\n</code></pre> <p>In Java 8 and above this can be achieved using a lambda:</p> Java<pre><code>wireMockServer.stubFor(requestMatching(request -&gt;\n    MatchResult.of(request.getBody().length &gt; 2048)\n).willReturn(aResponse().withStatus(422)));\n</code></pre> <p>To create a matcher to be referred to by name, create a class extending <code>RequestMatcher</code> and register it as an extension as per the instructions at the top of this page e.g.</p> Java<pre><code>public class BodyLengthMatcher extends RequestMatcherExtension {\n\n    @Override\n    public String getName() {\n        return \"body-too-long\";\n    }\n\n    @Override\n    public MatchResult match(Request request, Parameters parameters) {\n        int maxLength = parameters.getInt(\"maxLength\");\n        return MatchResult.of(request.getBody().length &gt; maxLength);\n    }\n}\n</code></pre> <p>Then define a stub with it:</p> JavaJSON Java<pre><code>stubFor(requestMatching(\"body-too-long\", Parameters.one(\"maxLength\", 2048))\n        .willReturn(aResponse().withStatus(422)));\n</code></pre> JSON<pre><code>{\n    \"request\": {\n        \"customMatcher\": {\n            \"name\": \"body-too-long\",\n            \"parameters\": {\n                \"maxLength\": 2048\n            }\n        }\n    },\n    \"response\": {\n        \"status\": 422\n    }\n}\n</code></pre>"},{"location":"extensibility/custom_matching/#combining-standard-and-custom-request-matchers","title":"Combining standard and custom request matchers","text":"<p>An inline custom matcher can be used in combination with standard matchers in the following way:</p> Java<pre><code>stubFor(get(urlPathMatching(\"/the/.*/one\"))\n        .andMatching(new MyRequestMatcher()) // Will also accept a Java 8+ lambda\n        .willReturn(ok()));\n</code></pre> <p>Note that inline matchers of this form can only be used from Java, and only when <code>stubFor</code> is being called against a local WireMock server. An exception will be thrown if attempting to use an inline custom matcher against a remote instance.</p> <p>Custom matchers defined as extensions can also be combined with standard matchers.</p> JavaJSON Java<pre><code>stubFor(get(urlPathMatching(\"/the/.*/one\"))\n        .andMatching(\"path-contains-param\", Parameters.one(\"path\", \"correct\"))\n        .willReturn(ok()));\n</code></pre> JSON<pre><code>{\n    \"request\": {\n        \"urlPathPattern\": \"/the/.*/one\",\n        \"method\": \"GET\",\n        \"customMatcher\": {\n            \"name\": \"path-contains-param\",\n            \"parameters\": {\n                \"path\": \"correct\"\n            }\n        }\n    },\n    \"response\": {\n        \"status\": 200\n    }\n}\n</code></pre>"},{"location":"extensibility/extending_wiremock/","title":"Extending WireMock","text":"<p>Documentation / extensibility / extending_wiremock </p> <p>WireMock Cloud</p> <p>Chaos testing, RBAC, dynamic state and more with WireMock Cloud.</p> <p>WireMock can be customised via a variety of extension points.</p> <p>Each extension point is defined by an interface that extends from <code>Extension</code> and extension implementations are loaded at startup time.</p> <p>At present, the following extension interfaces are available:</p> <ul> <li><code>RequestFilterV2</code>/<code>AdminRequestFilterV2</code>/<code>StubRequestFilterV2</code>: Intercept requests, modifying them or taking alternative actions based on their content.</li> <li><code>ResponseDefinitionTransformerV2</code>: Modify the response definition used to generate a response. See Transforming responses.</li> <li><code>ResponseTransformerV2</code>: Modify the response served to the client. See Transforming responses.</li> <li><code>ServeEventListener</code>: Listen for events at various points in the request processing lifecycle. See Listening for Serve Events.</li> <li><code>AdminApiExtension</code>: Add admin API functions. See Admin API Extensions.</li> <li><code>RequestMatcherExtension</code>: Implement custom request matching logic. See Custom matching.</li> <li><code>GlobalSettingsListener</code>: Listen for changes to the settings object. See Listening for Settings Changes.</li> <li><code>StubLifecycleListener</code>: Listen for changes to the stub mappings. See Listening for Stub Changes.</li> <li><code>TemplateHelperProviderExtension</code>: Provide custom Handlebars helpers to the template engine. See Adding Template Helpers.</li> <li><code>TemplateModelDataProviderExtension</code>: Provide additional data to the model passed to response templates. See Adding Template Model Data.</li> <li><code>MappingsLoaderExtension</code>: Provide additional source to load the stub mappings. See Adding Mappings Loader.</li> </ul> <p>The interfaces in this list ending with <code>V2</code> supercede deprecated equivalents with an older, more restrictive interface. Additionally <code>ServeEventListener</code> deprecates <code>PostServeAction</code>.</p> <p>As of WireMock version <code>3.6.0</code>, the <code>Extension</code> interface has two new lifecycle methods called <code>start()</code> and <code>stop()</code>.  The <code>start()</code> method is called on each extension when the WireMock server first starts (just before the stub mappings  are loaded) and the <code>stop()</code> method is called when the server is stopped. This allows extensions to perform any initialisation or cleanup tasks.</p>"},{"location":"extensibility/extending_wiremock/#registering-extensions","title":"Registering Extensions","text":"<p>You can directly register the extension programmatically via its class name, class or an instance:</p> Java<pre><code>new WireMockServer(wireMockConfig()\n  .extensions(\"com.mycorp.BodyContentTransformer\", \"com.mycorp.HeaderMangler\"));\n\nnew WireMockServer(wireMockConfig()\n  .extensions(BodyContentTransformer.class, HeaderMangler.class));\n\nnew WireMockServer(wireMockConfig()\n  .extensions(new BodyContentTransformer(), new HeaderMangler()));\n</code></pre> <p>See Running as a Standalone Process for details on running with extensions from the command line.</p>"},{"location":"extensibility/extending_wiremock/#factories","title":"Factories","text":"<p>You can also register an extension factory, which allows an extension to be created with various core WireMock services passed to the constructor:</p> Java<pre><code>new WireMockServer(wireMockConfig()\n  .extensions(services -&gt;\n                    List.of(\n                        new MiscInfoApi(\n                            services.getAdmin(),\n                            services.getOptions(),\n                            services.getStores(),\n                            services.getFiles(),\n                            services.getExtensions()\n                        ))));\n</code></pre> <p>Services currently available to extension factories are: * <code>Admin</code>: the main WireMock functional interface for stubbing, verification and configuration tasks. * <code>Options</code>: the configuration object built at startup. * <code>Stores</code>: the root interface for gaining access to the various stores of WireMock's state and creating/using custom stores. * <code>FileSource</code>: the <code>__files</code> directory where larger response body files are often kept. * <code>Extensions</code>: the service for creating and providing extension implementations. * <code>TemplateEngine</code>: the Handlebars template engine.</p>"},{"location":"extensibility/extending_wiremock/#extension-registration-via-service-loading","title":"Extension registration via service loading","text":"<p>Extensions that are packaged with the relevant Java service loader framework metadata will be loaded automatically if they are placed on the classpath.</p> <p>See https://github.com/wiremock/wiremock/tree/master/test-extension for an example of such an extension.</p>"},{"location":"extensibility/extending_wiremock/#attaching-sub-events-during-request-processing","title":"Attaching sub-events during request processing","text":"<p>Sub-events are a used to report interesting/useful information during request processing. WireMock attaches the diff report generated when a request is not matched as a sub-event, and custom extension can exploit this approach to surface e.g. diagnostic and validation data in the serve event log, where it can be retrieved later via the API or exported to monitoring/observability tools via listeners.</p> <p>Several types of extension act on WireMock's request processing: <code>RequestFilterV2</code> (and its stub/admin sub-interfaces), <code>ResponseDefinitionTransformer</code>, <code>ResponseTransformer</code> and <code>ServeEventListener</code>.</p> <p>The primary method in each of these takes the current <code>ServeEvent</code> as a parameter and sub-events can be attached to this:</p> Java<pre><code>serveEvent.appendSubEvent(\n  \"JSON_PARSE_WARNING\",\n  Map.of(\"message\", \"Single quotes are not permitted\")\n);\n</code></pre> <p>The second parameter to <code>appendSubEvent()</code> can be a Map or object containing any data required.</p>"},{"location":"extensibility/filtering_and_modifying_requests/","title":"Filtering and Modifying Requests","text":"<p>Documentation / extensibility / filtering_and_modifying_requests</p> <p>WireMock Cloud</p> <p>If you need to protect your mock APIs with Enterprise-grade security options, learn about WireMock Cloud.</p> <p>Requests to both stubs and the admin API can be intercepted and either modified or halted with an immediate response. This supports a number of use cases including: authentication, URL rewriting and request header injection.</p> <p>To intercept stub requests, create a class that extends <code>StubRequestFilter</code>. For instance, to perform simple authentication:</p> Java<pre><code>public class SimpleAuthRequestFilter implements StubRequestFilterV2 {\n\n    @Override\n    public RequestFilterAction filter(Request request, ServeEvent serveEvent) {\n        if (request.header(\"Authorization\").firstValue().equals(\"Basic abc123\")) {\n            return RequestFilterAction.continueWith(request);\n        }\n\n        return RequestFilterAction.stopWith(ResponseDefinition.notAuthorised());\n    }\n\n    @Override\n    public String getName() {\n        return \"simple-auth\";\n    }\n}\n</code></pre> <p>Then add it as an extension as usual e.g.</p> Java<pre><code>new WireMockRule(wireMockConfig().extensions(new SimpleAuthRequestFilter()));\n</code></pre> <p>To intercept admin API follow the same process, but extend <code>AdminRequestFilter</code>.</p>"},{"location":"extensibility/filtering_and_modifying_requests/#modifying-the-request-during-interception","title":"Modifying the request during interception","text":"<p>To modify the HTTP request, the simplest approach is to wrap the original request with a <code>RequestWrapper</code> then continue e.g.</p> Java<pre><code>public static class UrlAndHeadersModifyingFilter extends StubRequestFilterV2 {\n\n    @Override\n    public RequestFilterAction filter(Request request, ServeEvent serveEvent) {\n        Request wrappedRequest = RequestWrapper.create()\n                .transformAbsoluteUrl(url -&gt; url + \"?extraQueryParam=123\")\n                .addHeader(\"X-Custom-Header\", \"headerval\")\n                .wrap(request);\n\n        return RequestFilterAction.continueWith(wrappedRequest);\n    }\n\n    @Override\n    public String getName() {\n        return \"url-and-header-modifier\";\n    }\n}\n</code></pre> <p><code>RequestWrapper</code> is a builder pattern and allows any number of changes to the request. It supports the following changes:</p> <ul> <li>Transformation of the URL. <code>transformAbsoluteUrl</code> takes a <code>FieldTransformer</code> as a parameter (or equivalent lambda) which maps     from the old to the new URL. Note that the URL passed in is absolute, and the returned URL must also be.</li> <li>Addition, removal and transformation (via <code>FieldTransformer</code>) of headers.</li> <li>Addition, removal and transformation of cookies.</li> <li>Changing the HTTP method.</li> <li>Transformation of the request body.</li> <li>Transformation of body parts (if a multipart encoded request).</li> </ul>"},{"location":"extensibility/listening_for_serve_events/","title":"Listening for Serve Events","text":"<p>Documentation / extensibility / listening_for_serve_events Serve event listeners are intended for use when you wish to take an action at a specific point in the request processing flow, without affecting processing in any way. For instance a serve event listener would be the most suitable extension point to use for exporting telemetry data to a monitoring/observability tool.</p> <p>The <code>ServeEventListener</code> interface (which deprecates <code>PostServeAction</code>) supports two different modes of operation - you can either override specific methods if the listener should only fire at a specific point in the request processing flow, or you can override a generic method then configure which lifecycle points it's fired at when binding the listener to specific stubs. Or it can simply be made to fire at all lifecycle points.</p>"},{"location":"extensibility/listening_for_serve_events/#listening-for-specific-lifecycle-events","title":"Listening for specific lifecycle events","text":"<p>The <code>ServeEventListener</code> interface has a set of callback methods that can be implemented for specific points in the request lifecycle. These have no-op defaults, so you can override just the ones that are relevant:</p> Java<pre><code>public class MyServeEventListener implements ServeEventListener {\n\n    @Override\n    public void beforeMatch(ServeEvent serveEvent, Parameters parameters) {\n        // Do something before request matching\n    }\n\n    @Override\n    public void afterMatch(ServeEvent serveEvent, Parameters parameters) {\n        // Do something after request matching\n    }\n\n    @Override\n    public void beforeResponseSent(ServeEvent serveEvent, Parameters parameters) {\n        // Do something before the response is sent to the client\n    }\n\n    @Override\n    public void afterComplete(ServeEvent serveEvent, Parameters parameters) {\n        // Do something after the response has been sent to the client\n    }\n\n    @Override\n    public String getName() {\n        return \"my-listener\";\n    }\n}\n</code></pre>"},{"location":"extensibility/listening_for_serve_events/#listening-for-all-lifecycle-events","title":"Listening for all lifecycle events","text":"<p>The alternative approach you can take is to listen for all events along with a request phase value indicating when the event fired:</p> Java<pre><code>public class MyServeEventListener implements ServeEventListener {\n\n    @Override\n    public void onEvent(\n        RequestPhase requestPhase,\n        ServeEvent serveEvent,\n        Parameters parameters) {\n\n        log.debug(\"Received serve event in phase \" + requestPhase);\n    }\n\n    @Override\n    public String getName() {\n        return \"my-listener\";\n    }\n}\n</code></pre>"},{"location":"extensibility/listening_for_setting_changes/","title":"Listening for Settings Changes","text":"<p>Documentation / extensibility / listening_for_setting_changes You can listen for changes to the global settings object.</p> <p>This is most useful when combined with other extension points, allowing extensions to define and make use of extended settings values rather than rolling their own configuration strategy.</p> <p>A common pattern is to listen for changes and capture the value locally, using this to affect the main extension's behaviour e.g.:</p> Java<pre><code>public class MyConfigurableServeEventListener\n        implements ServeEventListener, GlobalSettingsListener {\n\n    private volatile String mySetting = \"\";\n\n    @Override\n    public void afterGlobalSettingsUpdated(\n            GlobalSettings oldSettings,\n            GlobalSettings newSettings) {\n\n        mySetting = newSettings.getExtended().getString(\"my-setting\");\n    }\n\n    @Override\n    public void onEvent(\n            RequestPhase requestPhase,\n            ServeEvent serveEvent,\n            Parameters parameters) {\n\n        log.debug(\"My setting is \" + mySetting);\n    }\n\n    @Override\n    public String getName() {\n        return \"my-listener\";\n    }\n}\n</code></pre>"},{"location":"extensibility/listening_for_stub_changes/","title":"Listening for Stub Changes","text":"<p>Documentation / extensibility / listening_for_stub_changes You can subscribe to changes in the state of WireMock's stubs via the <code>StubLifecycleListener</code> extension point.</p> <p>For instance, to respond after a new stub has been created you would do the following:</p> Java<pre><code>public class MyStubEventListener implements StubLifecycleListener {\n\n    @Override\n    public void afterStubCreated(StubMapping stub) {\n        log.debug(\"Stub named \" + stub.getName() + \" was created\");\n    }\n\n    @Override\n    public String getName() {\n        return \"my-listener\";\n    }\n}\n</code></pre> <p>The following methods can be overridden to subscribe to various stub lifecycle events:</p> Java<pre><code>void beforeStubCreated(StubMapping stub)\nvoid afterStubCreated(StubMapping stub)\nvoid beforeStubEdited(StubMapping oldStub, StubMapping newStub)\nvoid afterStubEdited(StubMapping oldStub, StubMapping newStub)\nvoid beforeStubRemoved(StubMapping stub)\nvoid afterStubRemoved(StubMapping stub)\nvoid beforeStubsReset()\nvoid afterStubsReset()\n</code></pre>"},{"location":"extensibility/mapping_loader_extensions/","title":"Mappings Loader Extensions","text":"<p>Documentation / extensibility / mapping_loader_extensions Additional source to load the stub mappings can be configured by implementing <code>MappingsLoaderExtension</code>.</p> Java<pre><code>public class DummyMappingsLoaderExtension extends MappingsLoaderExtension {\n  @Override\n  public String getName() {\n    return \"dummy-mappings-loader\"; // Return the name of extension\n  }\n\n  @Override\n  public void loadMappingsInto(StubMappings stubMappings) {\n        // implementation to load the mappings\n        // mappings can be loaded from any source like git repo, database, file storage, stc\n  }\n}\n</code></pre> <p>Registering the extension with wiremock.</p> Java<pre><code>        WireMockServer wireMockServer = new WireMockServer(wireMockConfig()\n                .extensions(new DummyMappingsLoaderExtension())\n                ); // Register your extension here\n</code></pre>"},{"location":"extensibility/stub_metadata/","title":"Stub Metadata","text":"<p>Documentation / extensibility / stub_metadata It is possible to attach arbitrary metadata to stub mappings, which can be later used to search or deletion, or simply retrieval.</p>"},{"location":"extensibility/stub_metadata/#adding-metadata-to-stubs","title":"Adding metadata to stubs","text":"<p>Data under the <code>metadata</code> key is a JSON object (represented in Java by a <code>Map&lt;String, ?&gt;</code>). It can be added to a stub mapping on creation.</p> JavaJSON Java<pre><code>stubFor(get(\"/with-metadata\")\n    .withMetadata(metadata()\n        .attr(\"singleItem\", 1234)\n        .list(\"listItem\", 1, 2, 3, 4)\n        .attr(\"nestedObject\", metadata()\n            .attr(\"innerItem\", \"Hello\")\n        )\n));\n</code></pre> JSON<pre><code>{\n    \"request\": {\n        \"url\": \"/with-metadata\"\n    },\n    \"response\": {\n        \"status\": 200\n    },\n\n    \"metadata\": {\n        \"singleItem\": 1234,\n        \"listItem\": [1, 2, 3, 4],\n        \"nestedObject\": {\n            \"innerItem\": \"Hello\"\n        }\n    }\n}\n</code></pre>"},{"location":"extensibility/stub_metadata/#search-for-stubs-by-metadata","title":"Search for stubs by metadata","text":"<p>Stubs can be found by matching against their metadata using the same matching strategies as when matching HTTP requests. The most useful matcher for this is <code>matchesJsonPath</code>:</p> JavaJSON Java<pre><code>List&lt;StubMapping&gt; stubs =\n    findStubsByMetadata(matchingJsonPath(\"$.singleItem\", containing(\"123\")));\n</code></pre> JSON<pre><code>POST /__admin/mappings/find-by-metadata\n\n{\n    \"matchesJsonPath\" : {\n    \"expression\" : \"$.singleItem\",\n    \"contains\" : \"123\"\n    }\n}\n</code></pre>"},{"location":"extensibility/stub_metadata/#remove-stubs-by-metadata","title":"Remove stubs by metadata","text":"<p>Similarly, stubs with matching metadata can be removed:</p> JavaJSON Java<pre><code>removeStubsByMetadata(matchingJsonPath(\"$.singleItem\", containing(\"123\")));\n</code></pre> <p>POST /__admin/mappings/remove-by-metadata</p> JSON<pre><code>{\n    \"matchesJsonPath\" : {\n    \"expression\" : \"$.singleItem\",\n    \"contains\" : \"123\"\n    }\n}\n</code></pre>"},{"location":"extensibility/stub_metadata/#remove-request-journal-events-by-metadata","title":"Remove request journal events by metadata","text":"<p>See Removing items from the journal</p>"},{"location":"extensibility/transforming_responses/","title":"Transforming Responses","text":"<p>Documentation / extensibility / transforming_responses Sometimes, returning wholly static responses to stub requests isn't practical e.g. when there are transaction IDs being passed between request/responses, dates that must be current. Via WireMock's extension mechanism it is possible to dynamically modify responses, allowing header re-writing and templated responses amongst other things.</p> <p>There are two ways to dynamically transform output from WireMock. WireMock stub mappings consist in part of a <code>ResponseDefinition</code>. This is essentially a description that WireMock (sometimes) combines with other information when producing the final response. A basic <code>ResponseDefinition</code> closely resembles an actual response in that it has status, headers and body fields, but it can also indicate to WireMock that the actual response should be the result of a proxy request to another system or a fault of some kind.</p> <p><code>ResponseDefinition</code> objects are \"rendered\" by WireMock into a <code>Response</code>, and it is possible to interject either before or after this process when writing an extension, meaning you can either transform the <code>ResponseDefinition</code> prior to rendering, or the rendered <code>Response</code> afterwards.</p>"},{"location":"extensibility/transforming_responses/#parameters","title":"Parameters","text":"<p>Transformer extensions can have parameters passed to them on a per-stub basis via a <code>Parameters</code> fetched by calling <code>serveEvent.getTransformerParameters()</code>. <code>Parameters</code> derives from Java's <code>Map</code> and can be therefore arbitrarily deeply nested. Only types compatible with JSON (strings, numbers, booleans, maps and lists) can be used.</p>"},{"location":"extensibility/transforming_responses/#response-definition-transformation","title":"Response definition transformation","text":"<p>To transform <code>ResponseDefinition</code> implement the <code>ResponseDefinitionTransformerV2</code> interface:</p> Java<pre><code>public static class ExampleTransformer implements ResponseDefinitionTransformerV2 {\n\n        @Override\n        public ResponseDefinition transform(ServeEvent serveEvent) {\n            return new ResponseDefinitionBuilder()\n                    .withHeader(\"MyHeader\", \"Transformed\")\n                    .withStatus(200)\n                    .withBody(\"Transformed body\")\n                    .build();\n        }\n\n        @Override\n        public String getName() {\n            return \"example\";\n        }\n    }\n</code></pre> <p>Transformer classes must have a no-args constructor unless you only intend to register them via an instance as described below.</p>"},{"location":"extensibility/transforming_responses/#supplying-parameters","title":"Supplying parameters","text":"<p>Parameters are supplied on a per stub mapping basis:</p> JavaJSON Java<pre><code>stubFor(get(urlEqualTo(\"/transform\")).willReturn(\n        aResponse()\n                .withTransformerParameter(\"newValue\", 66)\n                .withTransformerParameter(\"inner\", ImmutableMap.of(\"thing\", \"value\")))); // ImmutableMap is from Guava, but any Map will do\n</code></pre> JSON<pre><code>{\n    \"request\": {\n        \"url\": \"/transform\",\n        \"method\": \"GET\"\n    },\n    \"response\": {\n        \"status\": 200,\n        \"transformerParameters\": {\n            \"newValue\": 66,\n            \"inner\": {\n                \"thing\": \"value\"\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"extensibility/transforming_responses/#non-global-transformations","title":"Non-global transformations","text":"<p>By default transformations will be applied globally. If you only want them to apply in certain cases you can refer to make them non-global by adding this to your transformer class:</p> Java<pre><code>@Override\npublic boolean applyGlobally() {\n    return false;\n}\n</code></pre> <p>Then you add the transformation to specific stubs via its name:</p> JavaJSON Java<pre><code>stubFor(get(urlEqualTo(\"/local-transform\")).willReturn(aResponse()\n        .withStatus(200)\n        .withBody(\"Original body\")\n        .withTransformers(\"my-transformer\", \"other-transformer\")));\n</code></pre> JSON<pre><code>{\n    \"request\": {\n        \"method\": \"GET\",\n        \"url\": \"/local-transform\"\n    },\n    \"response\": {\n        \"status\": 200,\n        \"body\": \"Original body\",\n        \"transformers\": [\"my-transformer\", \"other-transformer\"]\n    }\n}\n</code></pre> <p>The Java API also has a convenience method for adding transformers and parameters in one call:</p> Java<pre><code>stubFor(get(urlEqualTo(\"/transform\")).willReturn(\n        aResponse()\n                .withTransformer(\"body-transformer\", \"newValue\", 66)));\n</code></pre>"},{"location":"extensibility/transforming_responses/#response-transformation","title":"Response transformation","text":"<p>A response transformer extension class is identical to <code>ResponseDefinitionTransformerV2</code> with the exception that it takes a <code>Response</code> in its transform method's parameter list and returns a <code>Response</code>.</p> <p>This transformer is the best option if you want to transform the response from a proxy call.</p> Java<pre><code>public static class StubResponseTransformerWithParams implements ResponseTransformerV2 {\n\n        @Override\n        public Response transform(Response response, ServeEvent serveEvent) {\n            Parameters parameters = serveEvent.getTransformerParameters();\n            return Response.Builder.like(response)\n                    .but().body(parameters.getString(\"name\") + \", \"\n                            + parameters.getInt(\"number\") + \", \"\n                            + parameters.getBoolean(\"flag\"))\n                    .build();\n        }\n\n        @Override\n        public String getName() {\n            return \"stub-transformer-with-params\";\n        }\n}\n</code></pre>"},{"location":"getting_started/community_resources/","title":"Community Resources","text":"<p>Documentation / getting_started / community_resources</p>"},{"location":"getting_started/community_resources/#community-resources","title":"Community Resources","text":"<p>Code, articles and videos related to WireMock from around the web.</p>"},{"location":"getting_started/community_resources/#configuration-clients","title":"Configuration / Clients","text":"<p>Automate configuration of stubs from JAX-RS annotated resources. Wiremock with JAX-RS support. Enables creation of stubs from JAX-RS annotated resources</p> <p>https://github.com/tomasbjerre/wiremock-jaxrs</p> <p>Monitor JVM metrics and WireMock response times. Wiremock extension that expose jvm and wiremock requests metrics in prometheus format.</p> <p>https://github.com/rasklaad/wiremock-metrics</p> <p>PHP client for WireMock Stub and mock web services with the power of WireMock from PHP.</p> <p>https://github.com/rowanhill/wiremock-php</p> <p>NodeJS client for WireMock This is Wiremock Standalone wrapped inside an NPM package. It relies only on dependencies found in NPM.</p> <p>https://www.npmjs.com/package/wiremock</p> <p>NodeJS + TypeScript client WireMock WireMock Captain provides an easy interface for testing HTTP-based APIs.</p> <p>https://www.npmjs.com/package/wiremock-captain</p> <p>Epresso test using WireMock as the backend for Android apps Running WireMock on Android</p> <p>https://handstandsam.com/2016/01/30/running-wiremock-on-android/</p> <p>Make the creation of WireMock stubs for Spring REST controllers safe and effortless. Adds a @GenerateWireMockStub annotation for Spring REST controllers makes the creation of WireMock stubs for tests safe and effortless.</p> <p>https://dzone.com/articles/wiremock-the-ridiculously-easy-way</p>"},{"location":"getting_started/community_resources/#integrations","title":"Integrations","text":"<p>WireMocha is a WireMock plugin for IntelliJ. WireMocha is an IntelliJ-based plugin that provides framework integration for the WireMock library. It offers various tools to generate and validate WireMock related test code, and to provide additional contextual information</p> <p>https://plugins.jetbrains.com/plugin/18860-wiremocha</p> <p>Spring Contract Verifier (previously called Accurest) Spring Contract Verifier (previously called Accurest) is a consumer driven contracts tool that generates WireMock stub mappings as examples for client testing</p> <p>https://spring.io/projects/spring-cloud-contract</p> <p>Spring REST Docs WireMock Integration A Spring REST Docs integration for WireMock that generates WireMock stub mappings from your test cases.</p> <p>https://github.com/epages-de/restdocs-wiremock</p> <p>WireMock Micronaut WireMock Micronaut drastically simplifies testing HTTP clients in Micronaut &amp; jUnit 5 based integration tests.</p> <p>https://github.com/Nahuel92/wiremock-micronaut</p> <p>A WireMock plugin for Maven. Run WireMock as part of Maven lifecycle.</p> <p>https://github.com/automatictester/wiremock-maven-plugin</p> <p>Zero-config, fully declarative Spring Boot integration with WireMock. WireMock Spring Boot drastically simplifies testing HTTP clients in Spring Boot &amp; Junit 5 based integration tests.</p> <p>https://github.com/wiremock/wiremock-spring-boot</p> <p>JSON Web Token Request Matching An extension for matching requests based on the contents of JSON web tokens</p> <p>https://github.com/MasonM/wiremock-jwt-extension</p> <p>Create a mock server with WireMock and Postman - Practical implementation In this video you will see how to configure Wiremock server in Postman.</p> <p>https://www.youtube.com/watch?v=Zd4_tUSOHfw&amp;pp=ygUId2lyZW1vY2s%3D</p> <p>Create a mock server with WireMock and Postman - Configuration theory This video discusses Wiremock and its configuration theory while creating mock server in postman.</p> <p>https://www.youtube.com/watch?v=gVVTO4U8M_k&amp;pp=ygUId2lyZW1vY2s%3D</p> <p>Transparent http client testing with http4K and WireMock Hear WireMock engineer, Robert Elliot as he gives a talk on transparent http client testing with http4K and WireMock</p> <p>https://www.youtube.com/watch?v=fpXf1K_E_bY&amp;pp=ygUId2lyZW1vY2s%3D</p>"},{"location":"getting_started/community_resources/#tutorial","title":"Tutorial","text":"<p>WireMock, Cucumber, and Spring Boot How you can use WireMock, Cucumber, and Spring Boot to develop APIs using Test Driven Development, Behavior Driven Development, and Consumer Contract Driven Development principles and practices</p> <p>https://arc-e-tect.medium.com/wiremock-cucumber-and-springboot-ae3e107bd3d7</p> <p>A workshop introduction to service virtualization with WireMock Open source workshop teaching you the basics of WireMock</p> <p>https://github.com/basdijkstra/wiremock-workshop</p> <p>Service Virtualization with Wiremock You will learn how to extend the testing coverage and have confidence in delivering the best software by introducing a new testing approach.</p> <p>https://eliasnogueira.com/service-virtualization-with-wiremock/</p> <p>A step-by-step guide to running your acceptance tests in Kubernetes using WireMock. A video showing how to mock external systems in acceptance tests using WireMock and Kubernetes.</p> <p>https://blog.sebastian-daschner.com/entries/acceptance_tests_wiremock_kubernetes</p> <p>Testing microservices with WireMock at Norway's top online marketplace. Norway's number one online marketplace, used to be a monolith but has migrated to Microservices during the last 4 years. The daily life of developers has become a lot better with Microservices, instead of everyone working on the same monolith. However, a problem arises when testing services thoroughly, as each service is dependent on other Microservices. This has been a big challenge, and has led to a lot of manual testing. However, lately we have started using a tool called WireMock which helps us stubbing out other Microservices. We will explain how this tool has helped us. Hopefully, the talk will help other developers with similar problems to get better testing when using Microservices.</p> <p>https://www.youtube.com/watch?v=cmJfMnGK-r0</p> <p>AWS:Reinvent talk from Intuit on isolating services for testing with WireMock. One of the challenges of implementing CI/CD with service-oriented architectures (SOA) is reliable execution of test automation. Because every service evolves on its own schedule, having a single integrated test environment is virtually impossible. One way to handle this complexity is dependency mocking. We use the Wiremock tool, which allows users to stub for service dependencies and do resiliency testing that was hard to automate before.</p> <p>https://www.youtube.com/watch?list=PLhr1KZpdzuke5pqzTvI2ZxwP8-NwLACuU&amp;v=sUsh3EnzKKk</p> <p>Using WireMock for HTTP stubbing and mocking. WireMock is a powerful tool for testing and simulating HTTP interactions in your application. By following this guide, you can effectively integrate WireMock into your development and testing workflows, ensuring robust and reliable tests for your HTTP-dependent components.</p> <p>https://medium.com/@2023sl93093/using-wiremock-for-http-stubbing-and-mocking-a-guide-0446dcf37b07</p> <p>Request filtering (interception) and modification with WireMock. Wiremock is a powerful tool and it is used for mocking APIs. It has a ton of features and configurations. This tutorial is about one of those features called request filtering. By using this feature we can easily intercept any request and modify it.</p> <p>https://medium.com/gitconnected/wiremock-server-request-filtering-interception-and-modification-b13c48c87e32</p> <p>Mastering API Performance Testing with k6, Grafana and WireMock. A Comprehensive Guide to Load Testing APIs with k6, Grafana, and WireMock.</p> <p>https://medium.com/gitconnected/mastering-api-performance-testing-with-k6-grafana-and-wiremock-e09825fb2241</p> <p>Standalone stub server using Spring Cloud Contract and WireMock. This article explains how to build a standalone stub server for stubbing REST APIs using Spring Cloud Contract WireMock.</p> <p>https://medium.com/@boottechnologies-ci/standalone-stub-server-using-spring-cloud-contract-wiremock-c91e72d8cdde</p> <p>Mock servers in the era of microservices. We are in the era of microservices. One of the advantages of microservices architecture is faster time to market. Development can be split into smaller parts, hence can be developed in parallel. Most of the time microservices communication is done by REST API. With that being said, a question arises as to how to efficiently develop a part of the system that requires communication with another part that is not ready. And the answer is by using mock. This tutorial will show how to easily set up a local mock server.</p> <p>https://medium.com/gitconnected/mock-server-using-wiremock-a61cbd55a690</p> <p>Understanding proxying with WireMock and .NET In this lecture we will understand proxing of WireMock.NET and how to enable proxying within WireMock Server.</p> <p>https://www.youtube.com/watch?v=kRHiNlkF2po&amp;pp=ygUId2lyZW1vY2s%3D</p> <p>Running WireMock as a .NET Tool in CommandLine In this lecture we will discuss how we can run WireMock as a .NET tool in the command line interface and map the existing Static mapping file and run the WireMock.NET as a full blown server instead of you running WireMock on the code.</p> <p>https://www.youtube.com/watch?v=YdyR1ZWrnC4&amp;pp=ygUId2lyZW1vY2s%3D</p> <p>Generating Static Mappings for Stubs in WireMock and .NET In this lecture we will discuss how we can generate static mappings for all the registered stubs in WireMockServer in WireMock.NET</p> <p>https://www.youtube.com/watch?v=xilAgj4NqhQ&amp;pp=ygUId2lyZW1vY2s%3D</p> <p>Using admin interfaces to debug tests efficiently with WireMock and .NET In this lecture we will discuss how Admin Interface provided by WireMock.NET</p> <p>https://www.youtube.com/watch?v=Q5sxMG84H0w&amp;pp=ygUId2lyZW1vY2s%3D</p> <p>Getting JSON body responses from WireMock and .NET In this lecture we will work with Getting JSON body response from WireMock.NET</p> <p>https://www.youtube.com/watch?v=fPAUqXo68e8&amp;pp=ygUId2lyZW1vY2s%3D</p> <p>Mocking Bearer Token Authentication using WireMock and .NET In this lecture we will work with Mocking Bearer Token Authentication using WireMock.NET</p> <p>https://www.youtube.com/watch?v=IC1lMYuPd4Y&amp;pp=ygUId2lyZW1vY2s%3D</p> <p>Custom database Logging with WireMock This video empowers you to extend WireMock's functionalities by implementing a custom database notifier. Store detailed request and response data directly in your MySQL database for powerful logging capabilities.</p> <p>https://www.youtube.com/watch?v=HuGAXwrg0nE&amp;pp=ygUId2lyZW1vY2s%3D</p> <p>Understanding request matchers in WireMock and .NET In this lecture we will understand and work with different types of Request Matchers in WireMock.NET</p> <p>https://www.youtube.com/watch?v=XrgS1ZsUKCY&amp;pp=ygUId2lyZW1vY2s%3D</p> <p>Advanced API mocking Strategies with WireMock Cloud This video dives deep into the advanced capabilities of WireMock Cloud, the industry-leading platform for streamlined and powerful API mocking.</p> <p>https://www.youtube.com/watch?v=Pdg5wIEyS08&amp;pp=ygUId2lyZW1vY2s%3D</p> <p>Introduction to WireMock and .NET WireMock.NET is a flexible and powerful tool for stubbing and mocking HTTP services for testing purposes. It allows you to simulate HTTP responses from real servers</p> <p>https://www.youtube.com/watch?v=SQRPqBWHeJs&amp;pp=ygUId2lyZW1vY2s%3D</p> <p>Dev Services for Gradle Projects with Quarkus, Gradle and WireMock Oleg Nenashev - Community Builder and Developer Advocate, Gradle &amp; CNCF Ambassador and Jenkins Core Maintainer talks about Dev Services for Gradle Projects with Quarkus, Gradle and WireMock</p> <p>https://www.youtube.com/watch?v=Lf15C0Jl3Yk&amp;pp=ygUId2lyZW1vY2s%3D</p> <p>Spring Cloud OpenFeign &amp; Testing with WireMock In this Spring Boot 3 Microservices tutorial series, we will learn how to build microservices using Spring Boot and Spring Cloud. This is part 4 of the series, in this part, we will cover, Integrating Synchronous Communication using Spring Cloud OpenFeign, Write Integration Tests using WireMock</p> <p>https://www.youtube.com/watch?v=GpqnYd8VR3k&amp;pp=ygUId2lyZW1vY2s%3D</p> <p>Easy Integration Tests for Spring webclients with WireMock. In this video, I will show you how to perform integration testing for Spring WebClient that invokes external REST APIs with WireMock and JUnit 5.</p> <p>https://www.youtube.com/watch?v=hbr4snySA6I&amp;pp=ygUId2lyZW1vY2s%3D</p> <p>Wiremock - How to use dynamic responses (Espanol) Neste v\u00eddeo voc\u00ea vai aprender a utilizar respostas din\u00e2micas em seus stubs com WireMock.</p> <p>https://www.youtube.com/watch?v=eazDmNtl5aM&amp;pp=ygUId2lyZW1vY2s%3D</p> <p>WireMock platform Enhanced API Security Astra Review WireMock is an API developer productivity platform that provides developers with the tools and technologies needed to get the job done easily when they depend on APIs in the development process. It allows developers to be productive when they're consuming 3rd party and internal APIs that delay their development or when they prototype and deliver APIs.</p> <p>https://www.youtube.com/watch?v=2zC7L1uMeis&amp;pp=ygUId2lyZW1vY2s%3D</p> <p>The power of visualization with WireMock (Espanol) \u00c9 a sua chance de explorar os conceitos fundamentais e obter respostas para todas as suas perguntas sobre Arquiteturas de Integra\u00e7\u00f5es.</p> <p>https://www.youtube.com/watch?v=aiH83J8ZgsU&amp;pp=ygUId2lyZW1vY2s%3D</p> <p>Exploring WireMock's built-in request matchers In this video tutorial we will learn about WireMock's in built matchers to create stub configurations. equalTo, contains, doesNotContain, matches, doesNotMatches, and, or, hasExactly, includes, caseinsensitive</p> <p>https://www.youtube.com/watch?v=73quuWlJAkM&amp;pp=ygUId2lyZW1vY2s%3D</p> <p>Request Matching With URLs with WireMock This video talks about request matching with URL, regular expressions, query parameter &amp; path parameter matching</p> <p>https://www.youtube.com/watch?v=1VIr__OWYRI&amp;pp=ygUId2lyZW1vY2s%3D</p> <p>External APIs Testing with WireMock This video, will show you how to mock external APIs in Java using WireMock.</p> <p>https://www.youtube.com/watch?v=KaW8yl52z5w&amp;pp=ygUId2lyZW1vY2s%3D</p> <p>Setup a WireMock Standalone Server Locally and create a basic JSON stub </p> <p>https://www.youtube.com/watch?v=kIgl7Yxmd4M&amp;pp=ygUId2lyZW1vY2s%3D</p> <p>Top use cases for API mocking with WireMock </p> <p>https://www.youtube.com/watch?v=L3Pb0ciIhgI&amp;pp=ygUId2lyZW1vY2s%3D</p> <p>Wiremock for monoliths vs microservices </p> <p>https://www.youtube.com/watch?v=wTD9vBRxoP0&amp;pp=ygUId2lyZW1vY2s%3D</p> <p>Web services integration testing with WireMock \u041e\u0434\u043d\u0430 \u0438\u0437 \u043d\u0430\u0438\u0431\u043e\u043b\u0435\u0435 \u0447\u0430\u0441\u0442\u044b\u0445 \u043f\u0440\u043e\u0431\u043b\u0435\u043c, \u043a\u043e\u0442\u043e\u0440\u044b\u0435 \u043c\u043e\u0433\u0443\u0442 \u0432\u043e\u0437\u043d\u0438\u043a\u043d\u0443\u0442\u044c \u043f\u0440\u0438 \u0430\u0432\u0442\u043e\u043c\u0430\u0442\u0438\u0437\u0430\u0446\u0438\u0438 \u0442\u0435\u0441\u0442\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f \u0432\u0435\u0431-\u0441\u0435\u0440\u0432\u0438\u0441\u043e\u0432, \u0437\u0430\u043a\u043b\u044e\u0447\u0430\u0435\u0442\u0441\u044f \u0432 \u0442\u043e\u043c, \u0447\u0442\u043e \u0432\u043d\u0435\u0448\u043d\u0438\u0439 \u0441\u0435\u0440\u0432\u0438\u0441 \u043d\u0435\u0434\u043e\u0441\u0442\u0443\u043f\u0435\u043d \u043d\u0430 \u043c\u043e\u043c\u0435\u043d\u0442 \u0440\u0430\u0437\u0440\u0430\u0431\u043e\u0442\u043a\u0438.</p> <p>https://www.youtube.com/watch?v=koxLAS6PM-g&amp;pp=ygUId2lyZW1vY2s%3D</p> <p>Exploring API Testing: Challenges and Tools In this webinar, we will delve deep into API Testing, exploring its challenges and key aspects that will help us comprehend why it is so important. We will also dive into mocks, their advantages, how to create them, and present a demo of WireMock, an open-source tool for API mocking.</p> <p>https://www.youtube.com/watch?v=BhsSd2wLfM0&amp;pp=ygUId2lyZW1vY2s%3D</p> <p>How to generate WireMock stubs with the OpenAPI generator (French) </p> <p>https://www.youtube.com/watch?v=0jhONfBrcKw&amp;pp=ygUId2lyZW1vY2s%3D</p> <p>Fake It until You Make It! API Integration Testing with Containers &amp; WireMock Testcontainers has become one of the most popular tools for software integration testing. If you can put your system-under-test into a container, Docker compose cluster or a pod, this is what you're likely to use. If your target isn't ready, not containerizable or just too heavy for testing as is, you can always use mock testing frameworks, e.g. WireMock or MockServer in the JVM ecosystem.</p> <p>https://www.youtube.com/watch?v=YEc6EwiHrjM&amp;pp=ygUId2lyZW1vY2s%3D</p> <p>Apidays Paris 2023 - Boost Productivity with Mock APIs: A Game Changer From the classic method of building API-enabled products to the innovative approach of mock-based prototyping, discover how to create, validate, and integrate APIs seamlessly. Presented by Tom Akehurst, CTO &amp; Co-founder at WireMock, learn how tools like Wot Cloud facilitate quick mock API generation and streamline API design, offering long-term value across the development lifecycle.</p> <p>https://www.youtube.com/watch?v=paqtGXPKVwE&amp;pp=ygUId2lyZW1vY2s%3D</p> <p>Testcontainers and API mocking with WireMock for C/C++ Testcontainers has become one of the most popular tools for software integration testing. If you can put your system-under-test into a container, Docker compose cluster or a pod, this is what you\u2019re likely to use. If your target isn\u2019t ready, not containerizable or just too heavy for testing as is, you can always use API mocking like WireMock to mock your interfaces including REST API, gRPC, etc. But are these tools available to C/C++ developers? And the answer is YES</p> <p>https://www.youtube.com/watch?v=dBjjFDZS5FM&amp;pp=ygUId2lyZW1vY2s%3D</p> <p>Spring Integration Testing Demystified: Testcontainers, WebTestClient, and WireMock In this video we delve into the secrets of integration testing in the Spring environment. Harness the power of tools like Testcontainers for dynamic Docker container management, WebTestClient for HTTP layer testing, and WireMock for creating client testing stubs.</p> <p>https://www.youtube.com/watch?v=kPqbfzZSUE4&amp;pp=ygUId2lyZW1vY2s%3D</p> <p>Integration Tests with WireMock and Spring Boot In this tutorial, we write integration tests for the Spring Boot application using WireMock.</p> <p>https://www.youtube.com/watch?v=QnfwblMrBd4&amp;pp=ygUId2lyZW1vY2s%3D</p> <p>Response templating - how to create mock APIs that return dynamic responses in WireMock Cloud In this video, we'll show you how to use dynamic response templating in WireMock Cloud to create a powerful mock API that can serve different data using a single stub. Response templating allows you to simulate real-world API behavior by providing variable responses based on the incoming request. This helps you create more realistic tests and examine how downstream components interact with the API in different scenarios.</p> <p>https://www.youtube.com/watch?v=A-LWoewCJN4&amp;pp=ygUId2lyZW1vY2s%3D</p> <p>Stub External APIs with WireMock and Spring Boot In this tutorial, we stub an external API using WireMock. I also use the new RestClient for the first time to interact with the API.</p> <p>https://www.youtube.com/watch?v=dx-69FrfZrw&amp;pp=ygUId2lyZW1vY2s%3D</p> <p>REST APIs for your tests with WIreMock (Russian) </p> <p>https://www.youtube.com/watch?v=bDKMvb3RUTg&amp;pp=ygUId2lyZW1vY2s%3D</p>"},{"location":"getting_started/download_and_installation/","title":"Download and Installation","text":"<p>Documentation / getting_started / download_and_installation</p> <p>WireMock Cloud</p> <p>To create publicly hosted mock APIs without anything to install, learn more about WireMock Cloud.</p>"},{"location":"getting_started/download_and_installation/#download-options","title":"Download options","text":"<p>WireMock Java is distributed in two flavours - a standard JAR containing just WireMock, and a standalone uber JAR containing WireMock plus all its dependencies.</p> <p>Most of the standalone JAR's dependencies are shaded i.e. they are hidden in alternative packages. This allows WireMock to be used in projects with conflicting versions of its dependencies. The standalone JAR is also runnable (see Running as a Standalone Process).</p> <p>WireMock currently has two releases available.  The <code>3.x</code> release (below) and the new <code>4.x</code> beta releases.</p>"},{"location":"getting_started/download_and_installation/#3x-release-downloads","title":"3.x Release Downloads","text":""},{"location":"getting_started/download_and_installation/#test-dependencies","title":"Test dependencies","text":"MavenGradle GroovyGradle KotlinScala SBT <p>Add the following to your project's pom.xml dependencies:</p> <p>XML<pre><code>    &lt;dependency&gt;\n        &lt;groupId&gt;org.wiremock&lt;/groupId&gt;\n        &lt;artifactId&gt;wiremock&lt;/artifactId&gt;\n        &lt;version&gt;3.13.1&lt;/version&gt;\n        &lt;scope&gt;test&lt;/scope&gt;\n    &lt;/dependency&gt;\n</code></pre> Then follow the next steps for JUnit 5+ or plain Java.</p> <p>Add the following to your project's build.gradle:</p> Groovy<pre><code>testImplementation \"org.wiremock:3.13.1\"\n</code></pre> <p>Then follow the next steps for JUnit 5+ or plain Java.</p> <p>Add the following to your project's build.gradle:</p> Kotlin<pre><code>testImplementation(\"org.wiremock:wiremock:3.13.1\")\n</code></pre> <p>Then follow the next steps for JUnit 5+ or plain Java.</p> <p>Add the following to your project's build.gradle:</p> Scala<pre><code>libraryDependencies +=\n\"org.wiremock\" % \"wiremock\" % \"3.13.1\" % Test\n</code></pre> <p>Then follow the next steps for JUnit 5+ or plain Java.</p>"},{"location":"getting_started/download_and_installation/#standalone-service","title":"Standalone Service","text":"<p>Run the following in a terminal:</p> DockerMavenGradle Bash<pre><code>docker run -it --rm -p 8080:8080 --name wiremock \\\nwiremock/wiremock:3.13.1\n</code></pre> XML<pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.wiremock&lt;/groupId&gt;\n    &lt;artifactId&gt;wiremock-standalone&lt;/artifactId&gt;\n    &lt;version&gt;3.13.1&lt;/version&gt;\n    &lt;scope&gt;test&lt;/scope&gt;\n&lt;/dependency&gt;\n</code></pre> Groovy<pre><code>testImplementation \"org.wiremock:wiremock-standalone:3.13.1}\"\n</code></pre> <p>Learn more in the Docker guide.</p>"},{"location":"getting_started/download_and_installation/#direct-download","title":"Direct download","text":"<p>If you want to run WireMock as a standalone process you can download the standalone JAR from here</p>"},{"location":"getting_started/download_and_installation/#4x-beta-release-downloads","title":"4.x Beta Release Downloads","text":"<p>The <code>4.x</code> release of WireMock is currently in beta.  These releases are under active development and we recommend you try it out.  We would love  to hear your feedback over on the community slack - https://slack.wiremock.org/</p> <p>We have given these releases a beta label due to the fact that as we move forwards with the <code>4.x</code> release there will be  breaking changes.  These are the current updates to the <code>4.x</code> release:</p> <ul> <li>Java 17 is now the baseline java version</li> <li>Jetty 12 is shipped by default so there is no longer a specific jetty 12 release of <code>4.x</code> and Jetty 11 is no longer supported</li> </ul>"},{"location":"getting_started/download_and_installation/#test-dependencies_1","title":"Test dependencies","text":"MavenGradle GroovyGradle KotlinScala SBT <p>Add the following to your project's pom.xml dependencies:</p> <p>XML<pre><code>    &lt;dependency&gt;\n        &lt;groupId&gt;org.wiremock&lt;/groupId&gt;\n        &lt;artifactId&gt;wiremock&lt;/artifactId&gt;\n        &lt;version&gt;4.0.0-beta.10&lt;/version&gt;\n        &lt;scope&gt;test&lt;/scope&gt;\n    &lt;/dependency&gt;\n</code></pre> Then follow the next steps for JUnit 5+ or plain Java.</p> <p>Add the following to your project's build.gradle:</p> Groovy<pre><code>testImplementation \"org.wiremock:4.0.0-beta.10\"\n</code></pre> <p>Then follow the next steps for JUnit 5+ or plain Java.</p> <p>Add the following to your project's build.gradle:</p> Kotlin<pre><code>testImplementation(\"org.wiremock:wiremock:4.0.0-beta.10\")\n</code></pre> <p>Then follow the next steps for JUnit 5+ or plain Java.</p> <p>Add the following to your project's build.gradle:</p> Scala<pre><code>libraryDependencies +=\n\"org.wiremock\" % \"wiremock\" % \"4.0.0-beta.10\" % Test\n</code></pre> <p>Then follow the next steps for JUnit 5+ or plain Java.</p>"},{"location":"getting_started/download_and_installation/#standalone-service_1","title":"Standalone Service","text":"<p>Run the following in a terminal:</p> MavenGradle XML<pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.wiremock&lt;/groupId&gt;\n    &lt;artifactId&gt;wiremock-standalone&lt;/artifactId&gt;\n    &lt;version&gt;4.0.0-beta.10&lt;/version&gt;\n    &lt;scope&gt;test&lt;/scope&gt;\n&lt;/dependency&gt;\n</code></pre> Groovy<pre><code>testImplementation \"org.wiremock:wiremock-standalone:4.0.0-beta.10\"\n</code></pre>"},{"location":"getting_started/download_and_installation/#direct-download_1","title":"Direct download","text":"<p>If you want to run WireMock as a standalone process you can download the standalone JAR from here</p>"},{"location":"getting_started/frequently_asked_questions/","title":"Frequently Asked Questions","text":"<p>Documentation / getting_started / frequently_asked_questions </p> <p>Here, you can find information about what API mocking and WireMock are, as well as recommendations and best practices for different challenges in various areas of WireMock.</p>"},{"location":"getting_started/frequently_asked_questions/#api-mocking-and-wiremock-as-a-service","title":"API mocking and WireMock as a service","text":""},{"location":"getting_started/frequently_asked_questions/#what-is-wiremock","title":"What is WireMock?","text":"<p>WireMock is a free API mocking tool that can be run as a standalone server, or in a hosted version via the WireMock Cloud managed service.</p>"},{"location":"getting_started/frequently_asked_questions/#what-is-api-mocking","title":"What is API mocking?","text":"<p>API mocking involves creating a simple simulation of an API, accepting the same types of request and returning identically structured responses as the real thing, enabling fast and reliable development and testing.</p>"},{"location":"getting_started/frequently_asked_questions/#when-do-you-need-to-mock-apis","title":"When do you need to mock APIs?","text":"<p>API mocking is typically used during development and testing as it allows you to build your app without worrying about 3rd party APIs or sandboxes breaking. It can also be used to rapidly prototype APIs that don\u2019t exist yet.</p>"},{"location":"getting_started/frequently_asked_questions/#how-do-you-create-an-api-mock","title":"How do you create an API mock?","text":"<p>WireMock supports several approaches for creating mock APIs - in code, via its REST API, as JSON files and by recording HTTP traffic proxied to another destination.</p>"},{"location":"getting_started/frequently_asked_questions/#what-makes-wiremock-unique","title":"What makes WireMock unique?","text":"<p>WireMock has a rich matching system, allowing any part of an incoming request to be matched against complex and precise criteria. Responses of any complexity can be dynamically generated via the Handlebars based templating system. Finally, WireMock is easy to integrate into any workflow due to its numerous extension points and comprehensive APIs.</p>"},{"location":"getting_started/frequently_asked_questions/#is-wiremock-open-source","title":"Is WireMock open source?","text":"<p>Yes, WireMock is a completely open source API mocking tool GitHub repository. If you\u2019re looking for a hosted version of WireMock, check out WireMock Cloud.</p>"},{"location":"getting_started/frequently_asked_questions/#is-wiremock-a-free-service","title":"Is WireMock a free service?","text":"<p>WireMock is completely free under the Apache 2.0 license.</p>"},{"location":"getting_started/frequently_asked_questions/#technical-questions","title":"Technical questions","text":""},{"location":"getting_started/frequently_asked_questions/#how-to-manage-many-mocks-across-different-use-cases-and-teams","title":"How to manage many mocks across different use cases and teams?","text":"<p>This question is valid especially when it is getting difficult to keep track of what test case(s) a particular mock was meant for.</p>"},{"location":"getting_started/frequently_asked_questions/#potential-solutions","title":"Potential solutions","text":"<ul> <li>Create your stubs (or most of them at least) in the test cases themselves, then reset them each time.</li> <li>Use the <code>metadata</code> element in the stub data to tag stubs with info relating them to specific test cases.</li> </ul>"},{"location":"getting_started/frequently_asked_questions/#potential-solutions-for-wiremock-standalone","title":"Potential solutions for WireMock standalone","text":"<ul> <li>Use configuration-as-code, and store your definitions in a repository. You can have a hierarchical structure of Mappings and Files to specify teams.<ul> <li>Disabling the modifying APIs after moving to configuration-as-code is also highly recommended, so that teams cannot break each other's mocks.</li> </ul> </li> <li>Introduce \"subprojects\" by having each app/team to use <code>$WIREMOCK_URL/$PROJECT_ID</code> or even <code>$WIREMOCK_URL/$TEAM_ID/$PROJECT_ID</code>.</li> <li>Do performance monitoring for your instance, because a single shared WireMock instance can be overloaded if multiple teams execute performance/stress tests on it. If the workload is exceeded, you can split it into multiple instances, or consider WireMock Cloud which is scalable.</li> </ul>"},{"location":"getting_started/overview/","title":"Overview","text":"<p>Documentation / getting_started / overview </p> <p>WireMock is a popular open-source tool for API mock testing with over 5 million downloads per month. It can help you to create stable test and development environments, isolate yourself from flakey 3rd parties and simulate APIs that don't exist yet.</p> <p>Started in 2011 as a Java library by Tom Akehurst, now WireMock spans across multiple programming languages and technology stacks. It can run as a library or client wrapper in many languages, or as a standalone server. There is a big community behind the project and its ecosystem.</p> <p>WireMock supports several approaches for creating mock APIs - in code, via its REST API, as JSON files and by recording HTTP traffic proxied to another destination. WireMock has a rich matching system, allowing any part of an incoming request to be matched against complex and precise criteria. Responses of any complexity can be dynamically generated via the Handlebars based templating system. Finally, WireMock is easy to integrate into any workflow due to its numerous extension points and comprehensive APIs.</p>"},{"location":"getting_started/overview/#key-features","title":"Key features","text":"<ul> <li>HTTP response stubbing, matchable on URL, header and body content patterns</li> <li>Request verification</li> <li>Runs in unit tests, as a standalone process or as a WAR app</li> <li>Record/playback of stubs</li> <li>Configurable response delays and Fault injection</li> <li>Per-request conditional proxying</li> <li>Browser proxying for request inspection and replacement</li> <li>Stateful behaviour simulation</li> </ul> <p>All the features are configurable via a fluent Java API and JSON files, or via JSON over HTTP for the standalone service.</p>"},{"location":"getting_started/overview/#getting-started","title":"Getting Started","text":"<p>Check out WireMock Quick-starts and tutorials here.</p>"},{"location":"getting_started/overview/#wiremock-ecosystem","title":"WireMock Ecosystem","text":"<p>WireMock has implementations and adapters for other languages and test frameworks. It supports adapters and implementations for various technology stacks, including Python, .NET, Golang, and Rust. For the JVM ecosystem, there are libraries for Spring Boot, Quarkus, Kotlin, Testcontainers and other. WireMock can also run on Android support, and soon to provide official gRPC and GraphQL adapters.</p> <p>You can learn more about WireMock Ecosystem here.</p>"},{"location":"getting_started/quick_start_api_mocking_with_java_junit_4/","title":"Quick Start: API Mocking with Java and JUnit 4","text":"<p>Documentation / getting_started / quick_start_api_mocking_with_java_junit_4</p> <p>WireMock Cloud</p> <p>Centralize and scale your API mocks with WireMock Cloud.</p> <p>In this guide we will write an API Unit test with WireMock and JUnit 4.</p>"},{"location":"getting_started/quick_start_api_mocking_with_java_junit_4/#prerequisites","title":"Prerequisites","text":"<ul> <li>Java 11 or 17</li> <li>Maven or Gradle, recent versions</li> <li>A Java project, based on Maven and Gradle</li> <li>A Unit test file which we will use as a playground</li> </ul>"},{"location":"getting_started/quick_start_api_mocking_with_java_junit_4/#add-wiremock-dependency-to-your-project","title":"Add WireMock Dependency to your project","text":"<p>WireMock is distributed via Maven Central and can be included in your project using common build tools' dependency management. To add the standard WireMock JAR as a project dependency, put the dependencies below section of your build file.</p> <p>In our test, we will also use AssertJ to verify the responses. To send the requests, we will use the embedded HTTP client available in Java 11+. If you want to add a Java 1.8 test, you will need to add an external HTTP Client implementation like Apache HttpClient.</p> MavenGradle XML<pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.wiremock&lt;/groupId&gt;\n    &lt;artifactId&gt;wiremock&lt;/artifactId&gt;\n    &lt;version&gt;3.13.1&lt;/version&gt;\n    &lt;scope&gt;test&lt;/scope&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.assertj&lt;/groupId&gt;\n    &lt;artifactId&gt;assertj-core&lt;/artifactId&gt;\n    &lt;version&gt;3.26.3&lt;/version&gt;\n    &lt;scope&gt;test&lt;/scope&gt;\n&lt;/dependency&gt;\n</code></pre> Groovy<pre><code>testImplementation \"org.wiremock:wiremock:3.13.1\"\ntestImplementation \"org.assertj:assertj-core:3.24.2\"\n</code></pre>"},{"location":"getting_started/quick_start_api_mocking_with_java_junit_4/#add-the-wiremock-rule","title":"Add the WireMock rule","text":"<p>WireMock ships with some JUnit rules to manage the server's lifecycle and setup/tear-down tasks.</p> <p>To use WireMock's fluent API add the following import:</p> Java<pre><code>import static com.github.tomakehurst.wiremock.client.WireMock.*;\n</code></pre> <p>To automatically start and stop WireMock per-test case, add the following to your test class (or a superclass of it):</p> Java<pre><code>@Rule\npublic WireMockRule wireMockRule = new WireMockRule(8089); // No-args constructor defaults to port 8080\n</code></pre>"},{"location":"getting_started/quick_start_api_mocking_with_java_junit_4/#write-a-test","title":"Write a test","text":"<p>Now you're ready to write a test case like this:</p> Java<pre><code>import java.net.http.HttpClient;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpResponse;\n\n...\n\n@Test\npublic void exampleTest() {\n    // Setup the WireMock mapping stub for the test\n    stubFor(post(\"/my/resource\")\n        .withHeader(\"Content-Type\", containing(\"xml\"))\n        .willReturn(ok()\n            .withHeader(\"Content-Type\", \"text/xml\")\n            .withBody(\"&lt;response&gt;SUCCESS&lt;/response&gt;\")));\n\n    // Setup HTTP POST request (with HTTP Client embedded in Java 11+)\n    final HttpClient client = HttpClient.newBuilder().build();\n    final HttpRequest request = HttpRequest.newBuilder()\n        .uri(wiremockServer.url(\"/my/resource\"))\n        .header(\"Content-Type\", \"text/xml\")\n        .POST().build();\n\n    // Send the request and receive the response\n    final HttpResponse&lt;String&gt; response =\n            client.send(request, HttpResponse.BodyHandlers.ofString());\n\n    // Verify the response (with AssertJ)\n    assertThat(response.statusCode()).as(\"Wrong response status code\").isEqualTo(200);\n    assertThat(response.body()).as(\"Wrong response body\").contains(\"&lt;response&gt;SUCCESS&lt;/response&gt;\");\n}\n</code></pre>"},{"location":"getting_started/quick_start_api_mocking_with_java_junit_4/#extend-the-test","title":"Extend the test","text":"<p>For a bit more control over the settings of the WireMock server created by the rule you can pass a fluently built Options object to either rule's constructor. Let's change the port numbers as an example.</p>"},{"location":"getting_started/quick_start_api_mocking_with_java_junit_4/#change-the-port-numbers","title":"Change the port numbers","text":"Java<pre><code>import static com.github.tomakehurst.wiremock.core.WireMockConfiguration.wireMockConfig;\n...\n\n@Rule\npublic WireMockRule wireMockRule = new WireMockRule(wireMockConfig().port(8089).httpsPort(8443));\n</code></pre>"},{"location":"getting_started/quick_start_api_mocking_with_java_junit_4/#random-port-numbers","title":"Random port numbers","text":"<p>You can have WireMock (or more accurately the JVM) pick random, free HTTP and HTTPS ports. It is a great idea if you want to run your tests concurrently.</p> Java<pre><code>@Rule\npublic WireMockRule wireMockRule = new WireMockRule(wireMockConfig().dynamicPort().dynamicHttpsPort());\n</code></pre> <p>Then find out which ports to use from your tests as follows:</p> Java<pre><code>int port = wireMockRule.port();\nint httpsPort = wireMockRule.httpsPort();\n</code></pre>"},{"location":"getting_started/quick_start_api_mocking_with_java_junit_4/#further-reading","title":"Further reading","text":"<ul> <li>For more details on verifying requests and stubbing responses, see Stubbing and Verifying</li> <li>For more information on the JUnit 4 rules see The JUnit 4 Rule.</li> <li>For more information on the JUnit 5 Jupiter extension see JUnit 5+ Jupiter; for previous JUnit versions you can use the JUnit 4 Rule.</li> <li>For many more examples of JUnit tests check out the WireMock's own acceptance tests</li> </ul>"},{"location":"getting_started/wiremock_tutorials/","title":"WireMock Tutorials","text":"<p>Documentation / getting_started / wiremock_tutorials </p> <p>Getting Started with WireMock in your project? Check out the guidelines below.</p>"},{"location":"getting_started/wiremock_tutorials/#quick-starts","title":"Quick Starts","text":"<p>At the moment, we provide the following quick starts for beginners:</p> <ul> <li>API Mocking with Java and JUnit 4</li> <li>Downloading and Installing WireMock</li> <li>Using WireMock with Jetty 12</li> </ul>"},{"location":"getting_started/wiremock_tutorials/#featured-tutorials","title":"Featured tutorials","text":"<p>Here are some good tutorials from the External Resources you can use:</p> <ul> <li>WireMock Basics Workshop, by Bas Dijkstra</li> <li>Running your acceptance tests in Kubernetes using WireMock, by Sebastian Daschner</li> <li>Running WireMock on Android, by Sam Edwards</li> </ul>"},{"location":"getting_started/wiremock_tutorials/#contributing-tutorials","title":"Contributing tutorials","text":"<p>If you know about additional tutorials and extensions for WireMock, let us know! If you would like to write a new tutorial, see the Contributor Guide.</p>"},{"location":"integrations/wiremock_spring_boot_integration/","title":"WireMock Spring Boot Integration","text":"<p>Documentation / integrations / wiremock_spring_boot_integration </p> <p>WireMock's Spring Boot integration provides a simple, declarative way to configure and run one or more WireMock instances their JUnit tests.</p>"},{"location":"integrations/wiremock_spring_boot_integration/#installation","title":"Installation","text":"<p>Maven: XML<pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.wiremock.integrations&lt;/groupId&gt;\n    &lt;artifactId&gt;wiremock-spring-boot&lt;/artifactId&gt;\n    &lt;version&gt;3.10.0&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre></p> <p>Gradle: Groovy<pre><code>implementation 'org.wiremock.integrations:wiremock-spring-boot:3.10.0'\n</code></pre></p>"},{"location":"integrations/wiremock_spring_boot_integration/#basic-usage","title":"Basic usage","text":"<p>The integration is enabled by adding the <code>@EnableWireMock</code> annotation to your test class.</p> Java<pre><code>@SpringBootTest(classes = ExamplesTests.AppConfiguration.class)\n@EnableWireMock\nclass ExampleTests {\n\n  @Value(\"${wiremock.server.baseUrl}\")\n  private String wireMockUrl;\n\n  @Test\n  void returns_a_ping() {\n    stubFor(get(\"/ping\").willReturn(ok(\"pong\")));\n\n    RestClient client = RestClient.create();\n    String body = client.get()\n            .uri(wireMockUrl + \"/ping\")\n            .retrieve()\n            .body(String.class);\n\n    assertThat(body, is(\"pong\"));\n  }\n\n  @SpringBootApplication\n  static class AppConfiguration {}\n}\n</code></pre>"},{"location":"integrations/wiremock_spring_boot_integration/#injected-properties","title":"Injected properties","text":"<p>The example above will start a WireMock instance with a sensible set of defaults and set the following properties in the Spring context:</p> <ul> <li><code>wiremock.server.baseUrl</code> - Base URL of WireMock server.</li> <li><code>wiremock.server.port</code> - HTTP port of WireMock server.</li> </ul> <p>These property names can be changed as follows:</p> Java<pre><code>@EnableWireMock(\n    @ConfigureWireMock(\n        baseUrlProperties = { \"customUrl\", \"sameCustomUrl\" },\n        portProperties = \"customPort\"\n))\nclass CustomPropertiesTest {\n\n @Value(\"${customUrl}\")\n private String customUrl;\n\n @Value(\"${sameCustomUrl}\")\n private String sameCustomUrl;\n\n @Value(\"${customPort}\")\n private String customPort;\n\n // ...\n}\n</code></pre>"},{"location":"integrations/wiremock_spring_boot_integration/#declarative-configuration","title":"Declarative configuration","text":"<p>A number of WireMock's common configuration values can be overridden via the <code>@ConfigureWireMock</code> annotation, which is used as follows:</p> Java<pre><code>@EnableWireMock({\n  @ConfigureWireMock(\n      name = \"my-mock\",\n      port = 8888)\n})\n</code></pre> <p>This currently supports the following config items:</p> <ul> <li><code>port</code>: the HTTP port number. Defaults to 0 i.e. random.</li> <li><code>httpsPort</code>: the HTTPS port number. Defaults to 0 i.e. random.</li> <li><code>name</code>: the WireMock instance name. It is usually a good idea to set this when running multiple WireMock instances. Defaults to <code>wiremock</code>.</li> <li><code>usePortFromPredefinedPropertyIfFound</code>: if true, take the port number from the Spring configuration. Defaults to false.</li> <li><code>portProperties</code>: Overrides for the HTTP port property name.</li> <li><code>httpsPortProperties</code>: Overrides for the HTTPS port property name.</li> <li><code>baseUrlProperties</code>: Overrides for the HTTP base URL property name.</li> <li><code>httpsBaseUrlProperties</code>: Overrides for the HTTPS base URL property name.</li> <li><code>filesUnderClasspath</code>: Classpath root that will be used as the WireMock instance's file source. See Customizing the mappings directory for details.</li> <li><code>filesUnderDirectory</code>: File root that will be used as the WireMock instance's file source. See Customizing the mappings directory for details.</li> <li><code>extensions</code>: WireMock extensions to be loaded, specified as class names.</li> <li><code>extensionFactories</code>: WireMock extension factories to be loaded, specified as class names.</li> <li><code>configurationCustomizers</code>: Customizer classes to be applied to the configuration object passed to the WireMock instance on construction. See Programmatic configuration for details.</li> </ul>"},{"location":"integrations/wiremock_spring_boot_integration/#programmatic-configuration","title":"Programmatic configuration","text":"<p>If full control over the WireMock server's configuration is needed you can supply a customizer class that can call methods directly on the WireMock configuration object.</p> Java<pre><code>@EnableWireMock({\n    @ConfigureWireMock(\n        configurationCustomizers = CustomizerTest.Customizer.class)\n})\npublic class CustomizerTest {\n\n    static class Customizer implements WireMockConfigurationCustomizer {\n\n        @Override\n        public void customize(\n            WireMockConfiguration configuration,\n            ConfigureWireMock options\n        ) {\n            configuration.notifier(new CustomNotifier());\n        }\n    }\n}\n</code></pre>"},{"location":"integrations/wiremock_spring_boot_integration/#customizing-the-mappings-directory","title":"Customizing the mappings directory","text":"<p>By default, each <code>WireMockServer</code> is configured to load WireMock root from:</p> <ol> <li>Classpath if specified</li> <li><code>{specified-resource-name}/{server-name}</code></li> <li><code>{specified-resource-name}</code></li> <li>Directory</li> <li><code>{CWD}/wiremock/{server-name}</code></li> <li><code>{CWD}/stubs/{server-name}</code></li> <li><code>{CWD}/mappings/{server-name}</code></li> <li><code>{CWD}/wiremock</code></li> <li><code>{CWD}/stubs</code></li> <li><code>{CWD}/mappings</code></li> </ol> <p>This can be changed as follows:</p> Java<pre><code>@EnableWireMock({\n  @ConfigureWireMock(\n      name = \"fs-client\",\n      filesUnderClasspath = \"some/classpath/resource\",\n      filesUnderDirectory = \"or/a/directory\")\n})\n</code></pre>"},{"location":"integrations/wiremock_spring_boot_integration/#injecting-wiremock-instances-into-the-test","title":"Injecting WireMock instances into the test","text":"<p>Sometimes it's necessary to gain programmatic access to a running WireMock instance e.g. to configure stubs or perform verifications.</p> <p>To enable this you can inject the WireMock server into a field on the test class as follows:</p> Java<pre><code>@SpringBootTest(classes = InjectionTest.AppConfiguration.class)\n@EnableWireMock\npublic class InjectionTest {\n\n  @InjectWireMock\n  WireMockServer wireMock;\n\n}\n</code></pre> <p>As described in the next section you can also specify the name of the desired instance when injecting:</p> Java<pre><code>@SpringBootTest(classes = InjectionTest.AppConfiguration.class)\n@EnableWireMock({\n  @ConfigureWireMock(name = \"user-service\")\n})\npublic class InjectionTest {\n\n  @InjectWireMock(\"user-service\")\n  WireMockServer mockUserService;\n\n  @Test\n  void fetch_empty_list_of_users() {\n\n    mockUserService.stubFor(get(\"/users\").willReturn(okJson(\"[]\")));\n\n    // ...\n  }\n}\n</code></pre>"},{"location":"integrations/wiremock_spring_boot_integration/#running-multiple-instances","title":"Running multiple instances","text":"<p>It's typically a good idea to run a WireMock instance per API you wish to mock, primarily to avoid clashes in the URL schemes of the two (or more) APIs.</p> <p>The Spring Boot integration supports this explictly via annotation configuration. By adding more than one configuration item, multiple instances will be started and the associated properties added to the Spring context.</p> <p>These instances can then be injected as fields on the test class to </p> Java<pre><code>@SpringBootTest(classes = WireMockSpringExtensionTest.AppConfiguration.class)\n@EnableWireMock({\n  @ConfigureWireMock(\n      name = \"user-service\",\n      baseUrlProperties = \"user-service.url\",\n      portProperties = \"user-service.port\"),\n  @ConfigureWireMock(\n      name = \"todo-service\",\n      baseUrlProperties = \"todo-service.url\",\n      portProperties = \"todo-service.port\")\n})\npublic class WireMockSpringExtensionTest {\n\n  @SpringBootApplication\n  static class AppConfiguration {}\n\n  @InjectWireMock(\"user-service\")\n  private WireMockServer mockUserService;\n\n  @InjectWireMock(\"todo-service\")\n  private WireMockServer mockTodoService;\n}\n</code></pre>"},{"location":"java_usage/java_configuration/","title":"Java configuration","text":"<p>Documentation / java_usage / java_configuration </p> <p>WireMock Cloud</p> <p>Centralize and scale your API mocks with WireMock Cloud.</p> <p>Both <code>WireMockServer</code> and the <code>WireMockRule</code> take a configuration builder as the parameter to their constructor e.g.</p> Java<pre><code>import static com.github.tomakehurst.wiremock.core.WireMockConfiguration.options;\n\nWireMockServer wm = new WireMockServer(options().port(2345));\n\n@Rule\nWireMockRule wm = new WireMockRule(options().port(2345));\n</code></pre> <p>Every option has a sensible default, so only options that you require an override for should be specified.</p>"},{"location":"java_usage/java_configuration/#network-ports-and-binding","title":"Network ports and binding","text":"Java<pre><code>// Statically set the HTTP port number. Defaults to 8080.\n.port(8000)\n\n// Statically set the HTTPS port number. Defaults to 8443.\n.httpsPort(8001)\n\n// Randomly assign the HTTP port on startup\n.dynamicPort()\n\n// Randomly asssign the HTTPS port on startup\n.dynamicHttpsPort()\n\n// Bind the WireMock server to this IP address locally. Defaults to the loopback adaptor.\n.bindAddress(\"192.168.1.111\")\n</code></pre>"},{"location":"java_usage/java_configuration/#jetty-configuration","title":"Jetty configuration","text":"<p>Typically it is only necessary to tweak these settings if you are doing performance testing under significant loads.</p> Java<pre><code>// Set the number of request handling threads in Jetty. Defaults to 10.\n.containerThreads(5)\n\n// Set the number of connection acceptor threads in Jetty. Defaults to 2.\n.jettyAcceptors(4)\n\n// Set the Jetty accept queue size. Defaults to Jetty's default of unbounded.\n.jettyAcceptQueueSize(100)\n\n // Set the size of Jetty's header buffer (to avoid exceptions when very large request headers are sent). Defaults to 8192.\n.jettyHeaderBufferSize(16834)\n\n// Enable asynchronous request processing in Jetty. Recommended when using WireMock for performance testing with delays, as it allows much more efficient use of container threads and therefore higher throughput. Defaults to false.\n.asynchronousResponseEnabled(true)\n\n// Set the number of asynchronous response threads. Effective only with asynchronousResponseEnabled=true. Defaults to 10.\n.asynchronousResponseThreads(10)\n</code></pre>"},{"location":"java_usage/java_configuration/#https-configuration","title":"HTTPS configuration","text":"<p>WireMock can accept HTTPS connections from clients, require a client to present a certificate for authentication, and pass a client certificate on to another service when proxying.</p> Java<pre><code>// Set the keystore containing the HTTPS certificate\n.keystorePath(\"/path/to/https-certs-keystore.jks\")\n\n// Set the password to the keystore. Note: the behaviour of this changed in version 2.27.0.\n// Previously this set Jetty's key manager password, whereas now it sets the keystore password value.\n.keystorePassword(\"verysecret!\")\n\n// Set the password to the Jetty's key manager. Note: added in version 2.27.0.\n.keyManagerPassword(\"donttell\")\n\n// Set the keystore type\n.keystoreType(\"BKS\")\n\n// Require a client calling WireMock to present a client certificate\n.needClientAuth(true)\n\n// Path to the trust store containing the client certificate required in by the previous parameter\n.trustStorePath(\"/path/to/trust-store.jks\")\n\n// The password to the trust store\n.trustStorePassword(\"trustme\")\n</code></pre> <p>WireMock uses the trust store for three purposes:</p> <ol> <li>As a server, when requiring client auth, WireMock will trust the client if it    presents a public certificate in this trust store</li> <li>As a proxy, WireMock will use the private key &amp; certificate in this key store    to authenticate its http client with target servers that require client auth</li> <li>As a proxy, WireMock will trust a target server if it presents a public    certificate in this trust store</li> </ol>"},{"location":"java_usage/java_configuration/#http2-configuration","title":"HTTP/2 configuration","text":"<p>HTTP/2 can be disabled separately for plain text (HTTP) and TLS (HTTPS):</p> Java<pre><code>// Disable HTTP/2 over HTTP\n.http2PlainDisabled(true);\n\n// Disable HTTP/2 over HTTPS\n.http2TlsDisabled(true);\n</code></pre>"},{"location":"java_usage/java_configuration/#proxy-settings","title":"Proxy settings","text":"Java<pre><code>// Set the timeout for requests to the proxy in milliseconds\n.proxyTimeout(5000)\n\n// Make WireMock behave as a forward proxy e.g. via browser proxy settings\n.enableBrowserProxying(true)\n\n// Send the Host header in the original request onwards to the system being proxied to\n.preserveHostHeader(false)\n\n// As of WireMock `3.7.0`, when in proxy mode, this option will transfer the original `User-Agent` header from the client to the proxied service.\n.preserveUserAgentProxyHeader(true) \n\n // Override the Host header sent when reverse proxying to another system (this and the previous parameter are mutually exclusive)\n.proxyHostHeader(\"my.otherdomain.com\")\n\n // When reverse proxying, also route via the specified forward proxy (useful inside corporate firewalls)\n.proxyVia(\"my.corporate.proxy\", 8080)\n\n// When proxying, path to a security store containing client private keys and trusted public certificates for communicating with a target server\n.trustStorePath(\"/path/to/trust-store.jks\")\n\n// The password to the trust store\n.trustStorePassword(\"trustme\")\n\n// When proxying, a key store containing a root Certificate Authority private key and certificate that can be used to sign generated certificates\n.caKeystorePath(\"/path/to/ca-key-store.jks\")\n\n// The password to the CA key store\n.caKeystorePassword(\"trustme\")\n\n// The type of the CA key store\n.caKeystoreType(\"JKS\")\n\n// Which proxy encodings to proxy through to the target if the request contains an Accept-Encoding header\n// By default this is null, which means the header is sent to the target unchanged\n// If there is an Accept-Encoding header on the request, and it does not contain any of the supported proxy encodings, the header is not sent to the target.\n.withSupportedProxyEncodings(\"gzip\", \"deflate\")\n</code></pre>"},{"location":"java_usage/java_configuration/#file-locations","title":"File locations","text":"<p>WireMock, when started programmatically, will default to <code>src/test/resources</code> as a filesystem root if not configured otherwise.</p> Java<pre><code>// Set the root of the filesystem WireMock will look under for files and mappings\n.usingFilesUnderDirectory(\"/path/to/files-and-mappings-root\")\n\n// Set a path within the classpath as the filesystem root\n.usingFilesUnderClasspath(\"root/path/under/classpath\")\n</code></pre>"},{"location":"java_usage/java_configuration/#request-journal","title":"Request journal","text":"<p>The request journal records requests received by WireMock. It is required by the verification features, so these will throw errors if it is disabled.</p> Java<pre><code>// Do not record received requests. Typically needed during load testing to avoid JVM heap exhaustion.\n.disableRequestJournal()\n\n// Limit the size of the request log (for the same reason as above).\n.maxRequestJournalEntries(Optional.of(100))\n</code></pre>"},{"location":"java_usage/java_configuration/#template-cache","title":"Template Cache","text":"<p>When response templating is enabled, compiled template fragments are cached to improve performance.  This setting allows you to configure the maximum number of entries to allow in the cache.  As of WireMock <code>3.7.0</code>, this defaults to 1000  cache entries.  Before WireMock <code>3.7.0</code> the default was unlimited</p> Java<pre><code>.withMaxTemplateCacheEntries(100)\n</code></pre>"},{"location":"java_usage/java_configuration/#notification-logging","title":"Notification (logging)","text":"<p>WireMock wraps all logging in its own <code>Notifier</code> interface. It ships with no-op, Slf4j and console (stdout) implementations.</p> Java<pre><code>// Provide an alternative notifier. The default logs to slf4j.\n.notifier(new ConsoleNotifier(true))\n</code></pre>"},{"location":"java_usage/java_configuration/#gzip","title":"Gzip","text":"<p>Gzipping of responses can be disabled.</p> Java<pre><code>.gzipDisabled(true)\n</code></pre>"},{"location":"java_usage/java_configuration/#extensions","title":"Extensions","text":"<p>For details see Extending WireMock.</p> Java<pre><code>// Add extensions\n.extensions(\"com.mycorp.ExtensionOne\", \"com.mycorp.ExtensionTwo\")\n</code></pre>"},{"location":"java_usage/java_configuration/#transfer-encoding","title":"Transfer encoding","text":"<p>By default WireMock will send all responses chunk encoded, meaning with a <code>Transfer-Encoding: chunked</code> header present and no <code>Content-Length</code> header.</p> <p>This behaviour can be modified by setting a chunked encoding policy e.g.</p> Java<pre><code>.useChunkedTransferEncoding(Options.ChunkedEncodingPolicy.BODY_FILE)\n</code></pre> <p>Valid values are:</p> <ul> <li><code>NEVER</code> - Never use chunked encoding. Warning: this will buffer all response bodies in order to calculate the size.     This might put a lot of strain on the garbage collector if you're using large response bodies.</li> <li><code>BODY_FILE</code> - Use chunked encoding for body files but calculate a <code>Content-Length</code> for directly configured bodies.</li> <li><code>ALWAYS</code> - Always use chunk encoding - the default.</li> </ul>"},{"location":"java_usage/java_configuration/#cross-origin-response-headers-cors","title":"Cross-origin response headers (CORS)","text":"<p>WireMock always sends CORS headers with admin API responses, but not by default with stub responses. To enable automatic sending of CORS headers on stub responses, do the following:</p> Java<pre><code>.stubCorsEnabled(true)\n</code></pre>"},{"location":"java_usage/java_configuration/#limiting-logged-response-body-size","title":"Limiting logged response body size","text":"<p>By default, response bodies will be recorded in the journal in their entirety. This can result in out of memory errors when very large bodies are served so WireMock provides an option to limit the number of bytes of response bodies retained (truncating any that are larger).</p> Java<pre><code>.maxLoggedResponseSize(100000) // bytes\n</code></pre>"},{"location":"java_usage/java_configuration/#preventing-proxying-to-and-recording-from-specific-target-addresses","title":"Preventing proxying to and recording from specific target addresses","text":"<p>As a security measure WireMock can be configured to only permit proxying (and therefore recording) to certain addresses. This is achieved via a list of allowed address rules and a list of denied address rules, where the allowed list is evaluated first.</p> <p>Each rule can be one of the following:</p> <ul> <li>A single IP address</li> <li>An IP address range in the e.g. <code>10.1.1.1-10.2.2.2</code></li> <li>A hostname wildcard e.g. <code>dev-*.example.com</code></li> </ul> <p>The ruleset is built and applied as follows:</p> Java<pre><code>.limitProxyTargets(NetworkAddressRules.builder()\n  .allow(\"192.168.56.42\")\n  .allow(\"192.0.1.1-192.168.254.1\")\n  .deny(\"*.acme.com\")\n  .build()\n)\n</code></pre>"},{"location":"java_usage/java_configuration/#filename-template","title":"Filename template","text":"<p>WireMock can set up specific filename template format based on stub information.  The main rule for set up specify stub metadata information in handlebar format.  For instance for endpoint <code>PUT /hosts/{id}</code> and format <code>{{{method}}}-{{{request.url}}}.json</code> will be generated: <code>put-hosts-id.json</code> filename. Default template: <code>{{{method}}}-{{{path}}}-{{{id}}}.json</code>.</p> Java<pre><code>.filenameTemplate(\"{{{request.url}}}-{{{request.url}}}.json\")\n</code></pre> <p>Note: starting from 3.0.0-beta-8</p>"},{"location":"java_usage/java_configuration/#listening-for-raw-traffic","title":"Listening for raw traffic","text":"<p>If you would like to observe raw HTTP traffic to and from Jetty for debugging purposes you can use a <code>WiremockNetworkTrafficListener</code>.</p> <p>One scenario where it can be useful is where Jetty alters the response from Wiremock before sending it to the client. (An example of that is where Jetty appends a --gzip postfix to the ETag response header if the response is gzipped.) Using WireMock's request listener extension points in this case would not show those alterations.</p> <p>To output all raw traffic to console use <code>ConsoleNotifyingWiremockNetworkTrafficListener</code>, for example:</p> Java<pre><code>.networkTrafficListener(new ConsoleNotifyingWiremockNetworkTrafficListener()));\n</code></pre> <p>If you would like to collect the traffic and for example add it to your acceptance test's output, you can use the <code>CollectingNetworkTrafficListener</code>.</p>"},{"location":"java_usage/java_configuration/#http-client","title":"HTTP Client","text":"<p>If you want to increase the proxying performance of WireMock you can enable connection reuse and increase the maximum number of connections:</p> Java<pre><code>// Maximum connections for Http Client\n.maxHttpClientConnections(1000);\n//Disable http connection reuse, `false` to enable\n.disableConnectionReuse(true)\n</code></pre>"},{"location":"java_usage/java_configuration/#webhook-configuration","title":"Webhook configuration","text":"<p>The default webhook thread pool size is 10.  This is more than enough for normal mocking with callbacks but if you are running performance tests using WireMock with callbacks, you might need to tweak the size of the threadpool used to  process webhook requests. This option is available as of WireMock version <code>3.13.0</code></p> Java<pre><code>// The number of threads created for processing webhook requests. Defaults to 10\n.withWebhookThreadPoolSize(100)\n</code></pre>"},{"location":"java_usage/junit_4_and_vintage/","title":"JUnit 4 and Vintage","text":"<p>Documentation / java_usage / junit_4_and_vintage </p> <p>WireMock includes a JUnit rule, compatible with JUnit 4.x and JUnit 5 Vintage. This provides a convenient way to manage one or more WireMock instances in your test cases. It handles the lifecycle for you, starting the server before each test method and stopping afterwards.</p>"},{"location":"java_usage/junit_4_and_vintage/#basic-usage","title":"Basic usage","text":"<p>To make WireMock available to your tests on its default port (8080):</p> Java<pre><code>@Rule\npublic WireMockRule wireMockRule = new WireMockRule();\n</code></pre> <p>The rule's constructor can take an <code>Options</code> instance to override various settings. An <code>Options</code> implementation can be created via the <code>WireMockConfiguration.options()</code> builder:</p> Java<pre><code>@Rule\npublic WireMockRule wireMockRule = new WireMockRule(options().port(8888).httpsPort(8889));\n</code></pre> <p>See Configuration for details.</p>"},{"location":"java_usage/junit_4_and_vintage/#unmatched-requests","title":"Unmatched requests","text":"<p>The JUnit rule will verify that all requests received during the course of a test case are served by a configured stub, rather than the default 404. If any are not a <code>VerificationException</code> is thrown, failing the test. This behaviour can be disabled by passing an extra constructor flag:</p> Java<pre><code>@Rule\npublic WireMockRule wireMockRule = new WireMockRule(options().port(8888), false);\n</code></pre>"},{"location":"java_usage/junit_4_and_vintage/#other-rule-configurations","title":"Other @Rule configurations","text":"<p>With a bit more effort you can make the WireMock server continue to run between test cases. This is easiest in JUnit 4.10:</p> Java<pre><code>@ClassRule\n@Rule\npublic static WireMockClassRule wireMockRule = new WireMockClassRule(8089);\n</code></pre> <p>Unfortunately JUnit 4.11 and above prohibits <code>@Rule</code> on static members so a slightly more verbose form is required:</p> Java<pre><code>@ClassRule\npublic static WireMockClassRule wireMockRule = new WireMockClassRule(8089);\n\n@Rule\npublic WireMockClassRule instanceRule = wireMockRule;\n</code></pre>"},{"location":"java_usage/junit_4_and_vintage/#accessing-the-stubbing-and-verification-dsl-from-the-rule","title":"Accessing the stubbing and verification DSL from the rule","text":"<p>In addition to the static methods on the <code>WireMock</code> class, it is also possible to configure stubs etc. via the rule object directly. There are two advantages to this -  1. it's a bit faster as it avoids sending commands over HTTP, and  2. if you want to mock multiple services you can declare a rule per service but not have to create a client object for each e.g.</p> Java<pre><code>@Rule\npublic WireMockRule service1 = new WireMockRule(8081);\n\n@Rule\npublic WireMockRule service2 = new WireMockRule(8082);\n\n@Test\npublic void bothServicesDoStuff() {\n    service1.stubFor(get(urlEqualTo(\"/blah\")).....);\n    service2.stubFor(post(urlEqualTo(\"/blap\")).....);\n\n    ...\n}\n</code></pre>"},{"location":"java_usage/junit_5_plus_jupiter/","title":"JUnit 5+ Jupiter","text":"<p>Documentation / java_usage / junit_5_plus_jupiter </p> <p>The JUnit Jupiter extension simplifies running of one or more WireMock instances in a Jupiter test class.</p> <p>It supports two modes of operation - declarative (simple, limited configuration options) and programmatic (less simple, very configurable). These are both explained in detail below.</p>"},{"location":"java_usage/junit_5_plus_jupiter/#basic-usage-declarative","title":"Basic usage - declarative","text":"<p>The extension can be applied to your test class declaratively by annotating it with <code>@WireMockTest</code>. This will run a single WireMock server, defaulting to a random port, HTTP only (no HTTPS).</p> <p>To get the running port number, base URL or a DSL instance you can declare a parameter of type <code>WireMockRuntimeInfo</code> in your test or lifecycle methods.</p> Java<pre><code>@WireMockTest\npublic class DeclarativeWireMockTest {\n\n    @Test\n    void test_something_with_wiremock(WireMockRuntimeInfo wmRuntimeInfo) {\n        // The static DSL will be automatically configured for you\n        stubFor(get(\"/static-dsl\").willReturn(ok()));\n\n        // Instance DSL can be obtained from the runtime info parameter\n        WireMock wireMock = wmRuntimeInfo.getWireMock();\n        wireMock.register(get(\"/instance-dsl\").willReturn(ok()));\n\n        // Info such as port numbers is also available\n        int port = wmRuntimeInfo.getHttpPort();\n\n        // Do some testing...\n    }\n}\n</code></pre>"},{"location":"java_usage/junit_5_plus_jupiter/#wiremock-server-lifecycle","title":"WireMock server lifecycle","text":"<p>In the above example a WireMock server will be started before the first test method in the test class and stopped after the last test method has completed.</p> <p>Stub mappings and requests will be reset before each test method.</p>"},{"location":"java_usage/junit_5_plus_jupiter/#fixing-the-port-number","title":"Fixing the port number","text":"<p>If you need to run WireMock on a fixed port you can pass this via the <code>httpPort</code> parameter to the extension annotation:</p> Java<pre><code>@WireMockTest(httpPort = 8080)\npublic class FixedPortDeclarativeWireMockTest {\n    ...\n}\n</code></pre>"},{"location":"java_usage/junit_5_plus_jupiter/#enabling-https","title":"Enabling HTTPS","text":"<p>You can also enable HTTPS via the <code>httpsEnabled</code> annotation parameter. By default a random port will be assigned:</p> Java<pre><code>@WireMockTest(httpsEnabled = true)\npublic class HttpsRandomPortDeclarativeWireMockTest {\n    ...\n}\n</code></pre> <p>But like with the HTTP port you can also fix the HTTPS port number via the <code>httpsPort</code> parameter:</p> Java<pre><code>@WireMockTest(httpsEnabled = true, httpsPort = 8443)\npublic class HttpsFixedPortDeclarativeWireMockTest {\n    ...\n}\n</code></pre>"},{"location":"java_usage/junit_5_plus_jupiter/#enabling-extension-scanning","title":"Enabling Extension Scanning","text":"<p>When extending WireMock via service loading, it may be helpful to have WireMock scan for extensions automatically via the <code>extensionScanningEnabled</code> parameter.</p> Java<pre><code>@WireMockTest(extensionScanningEnabled = true)\npublic class ExtensionScanningDeclarativeWireMockTest {\n    ...\n}\n</code></pre>"},{"location":"java_usage/junit_5_plus_jupiter/#advanced-usage-programmatic","title":"Advanced usage - programmatic","text":"<p>Invoking the extension programmatically with <code>@RegisterExtension</code> allows you to run any number of WireMock instances and provides full control over configuration.</p> Java<pre><code>public class ProgrammaticWireMockTest {\n\n    @RegisterExtension\n    static WireMockExtension wm1 = WireMockExtension.newInstance()\n            .options(wireMockConfig().dynamicPort().dynamicHttpsPort())\n            .build();\n\n    @RegisterExtension\n    static WireMockExtension wm2 = WireMockExtension.newInstance()\n            .options(wireMockConfig()\n                     .dynamicPort()\n                     .extensions(new ResponseTemplateTransformer(\n                          getTemplateEngine(),\n                          options.getResponseTemplatingGlobal(),\n                          getFiles(),\n                          templateModelProviders\n                        )\n                     )\n            .build();\n\n    @Test\n    void test_something_with_wiremock() {\n        // You can get ports, base URL etc. via WireMockRuntimeInfo\n        WireMockRuntimeInfo wm1RuntimeInfo = wm1.getRuntimeInfo();\n        int httpsPort = wm1RuntimeInfo.getHttpsPort();\n\n        // or directly via the extension field\n        int httpPort = wm1.port();\n\n        // You can use the DSL directly from the extension field\n        wm1.stubFor(get(\"/api-1-thing\").willReturn(ok()));\n\n        wm2.stubFor(get(\"/api-2-stuff\").willReturn(ok()));\n    }\n}\n</code></pre>"},{"location":"java_usage/junit_5_plus_jupiter/#static-vs-instance","title":"Static vs. instance","text":"<p>In the above example, as with the declarative form, each WireMock server will be started before the first test method in the test class and stopped after the last test method has completed, and by default, with a call to reset before each test method.</p> <p>However, if the extension fields are declared at the instance scope (without the <code>static</code> modifier) each WireMock server will be created and started before each test method and stopped after the end of the test method.</p>"},{"location":"java_usage/junit_5_plus_jupiter/#configuring-the-static-dsl","title":"Configuring the static DSL","text":"<p>If you want to use the static DSL with one of the instances you have registered programmatically you can declare this by calling <code>configureStaticDsl(true)</code> on the extension builder. The configuration will be automatically applied when the server is started:</p> Java<pre><code>public class AutomaticStaticDslConfigTest {\n\n    @RegisterExtension\n    static WireMockExtension wm1 = WireMockExtension.newInstance()\n            .options(wireMockConfig().dynamicPort().dynamicHttpsPort())\n            .configureStaticDsl(true)\n            .build();\n\n    @RegisterExtension\n    static WireMockExtension wm2 = WireMockExtension.newInstance()\n            .options(wireMockConfig().dynamicPort().dynamicHttpsPort())\n            .build();\n\n    @Test\n    void test_something_with_wiremock() {\n        // Will communicate with the instance called wm1\n        stubFor(get(\"/static-dsl\").willReturn(ok()));\n\n        // Do test stuff...\n    }\n}\n</code></pre>"},{"location":"java_usage/junit_5_plus_jupiter/#resetting-before-each-test-method","title":"Resetting before each test method","text":"<p>By default WireMock will be reset before each tests method.  This will reset the stubs and any requests that have been  made.  </p> <p>Most of the time this is the desired behaviour but this behavior can be changed by calling <code>.resetOnEachTest(false)</code> on the extension builder when using the programmatic form.  This option is available as of WireMock version <code>3.13.0</code></p>"},{"location":"java_usage/junit_5_plus_jupiter/#unmatched-request-behaviour","title":"Unmatched request behaviour","text":"<p>By default, in either the declarative or programmatic form, if the WireMock instance receives unmatched requests during a test run an assertion error will be thrown and the test will fail.</p> <p>This behavior can be changed by calling <code>.failOnUnmatchedRequests(false)</code> on the extension builder when using the programmatic form.</p>"},{"location":"java_usage/junit_5_plus_jupiter/#proxy-mode","title":"Proxy mode","text":"<p>The JUnit Jupiter extension can be configured to enable \"proxy mode\" which simplifies configuration and supports multi-domain mocking.</p>"},{"location":"java_usage/junit_5_plus_jupiter/#declarative","title":"Declarative","text":"<p>In declarative mode this is done by setting the <code>proxyMode = true</code> in the annotation declaration. Then, provided your app's HTTP client honours the JVM's proxy system properties, you can specify different domain (host) names when creating stubs.</p>"},{"location":"java_usage/junit_5_plus_jupiter/#programmatic","title":"Programmatic","text":"<p>Proxy mode can be enabled via the extension builder when using the programmatic form.</p> DeclarativeProgramatic Java<pre><code>@WireMockTest(proxyMode = true)\npublic class JUnitJupiterExtensionJvmProxyDeclarativeTest {\n\nCloseableHttpClient client;\n\n@BeforeEach\nvoid init() {\n    client = HttpClientBuilder.create()\n    .useSystemProperties() // This must be enabled for auto proxy config\n    .build();\n}\n\n@Test\nvoid configures_jvm_proxy_and_enables_browser_proxying() throws Exception {\n    stubFor(get(\"/things\")\n    .withHost(equalTo(\"one.my.domain\"))\n    .willReturn(ok(\"1\")));\n\n    stubFor(get(\"/things\")\n    .withHost(equalTo(\"two.my.domain\"))\n    .willReturn(ok(\"2\")));\n\n    assertThat(getContent(\"http://one.my.domain/things\"), is(\"1\"));\n    assertThat(getContent(\"http://two.my.domain/things\"), is(\"2\"));\n}\n\nprivate String getContent(String url) throws Exception {\n    try (CloseableHttpResponse response = client.execute(new HttpGet(url))) {\n    return EntityUtils.toString(response.getEntity());\n    }\n}\n}\n</code></pre> Java<pre><code>public class JUnitJupiterProgrammaticProxyTest {\n\n@RegisterExtension\nstatic WireMockExtension wm = WireMockExtension.newInstance()\n    .proxyMode(true)\n    .build();\n\nCloseableHttpClient client;\n\n@BeforeEach\nvoid init() {\n    client = HttpClientBuilder.create()\n    .useSystemProperties() // This must be enabled for auto proxy config\n    .build();\n}\n\n@Test\nvoid configures_jvm_proxy_and_enables_browser_proxying() throws Exception {\n    wm.stubFor(get(\"/things\")\n    .withHost(equalTo(\"one.my.domain\"))\n    .willReturn(ok(\"1\")));\n\n    wm.stubFor(get(\"/things\")\n    .withHost(equalTo(\"two.my.domain\"))\n    .willReturn(ok(\"2\")));\n\n    assertThat(getContent(\"http://one.my.domain/things\"), is(\"1\"));\n    assertThat(getContent(\"http://two.my.domain/things\"), is(\"2\"));\n}\n\nprivate String getContent(String url) throws Exception {\n    try (CloseableHttpResponse response = client.execute(new HttpGet(url))) {\n    return EntityUtils.toString(response.getEntity());\n    }\n}\n}\n</code></pre>"},{"location":"java_usage/junit_5_plus_jupiter/#subclassing-the-extension","title":"Subclassing the extension","text":"<p>Like the JUnit 4.x rule, <code>WireMockExtension</code> can be subclassed in order to extend its behaviour by hooking into its lifecycle events. This can also be a good approach for creating a domain-specific API mock, by adding methods to stub and verify specific calls.</p> Java<pre><code>public class MyMockApi extends WireMockExtension {\n\n    public MyMockApi(WireMockExtension.Builder builder) {\n      super(builder);\n    }\n\n    @Override\n    protected void onBeforeAll(WireMockRuntimeInfo wireMockRuntimeInfo) {\n      // Do things before any tests have run\n    }\n\n    @Override\n    protected void onBeforeEach(WireMockRuntimeInfo wireMockRuntimeInfo) {\n      // Do things before each test\n    }\n\n    @Override\n    protected void onAfterEach(WireMockRuntimeInfo wireMockRuntimeInfo) {\n      // Do things after each test\n    }\n\n    @Override\n    protected void onAfterAll(WireMockRuntimeInfo wireMockRuntimeInfo) {\n      // Do things after all tests have run\n    }\n}\n</code></pre> <p>Note the constructor, which takes the extension's builder as its parameter. By making this public, you can pass an instance of the builder in when constructing your extension as follows:</p> Java<pre><code>  @RegisterExtension\n  static MyMockApi myMockApi =\n      new MyMockApi(\n          WireMockExtension.extensionOptions()\n              .options(wireMockConfig().dynamicPort().dynamicHttpsPort())\n              .configureStaticDsl(true));\n</code></pre> <p>This will ensure that all parameters from the builder will be set as they would if you had constructed an instance of <code>WireMockExtension</code> from it.</p>"},{"location":"java_usage/plain_java/","title":"Plain Java","text":"<p>Documentation / java_usage / plain_java </p> <p>If you're not using JUnit or neither of the WireMock rules manage its lifecycle in a suitable way you can construct and start the server directly.</p>"},{"location":"java_usage/plain_java/#the-server","title":"The Server","text":"<p>If you want to use WireMock from Java (or any other JVM language) outside of JUnit you can programmatically create, start and stop the server:</p> Java<pre><code>WireMockServer wireMockServer = new WireMockServer(options().port(8089)); //No-args constructor will start on port 8080, no HTTPS\nwireMockServer.start();\n\n// Sometime later\n\nwireMockServer.stop();\n</code></pre> <p>For more details of the <code>options()</code> builder accepted by the constructor see Configuration for details.</p> <p>As with stubbing and verification via the JUnit rule you can call the stubbing/verifying DSL from the server object as an alternative to calling the client.</p>"},{"location":"java_usage/plain_java/#managing-ports","title":"Managing ports","text":"<p>If you've changed the port number and/or you're running the server on another host, you'll need to tell the client:</p> Java<pre><code>WireMock.configureFor(\"wiremock.host\", 8089);\n</code></pre> <p>And if you've deployed it into a servlet container under a path other than root you'll need to set that too:</p> Java<pre><code>WireMock.configureFor(\"tomcat.host\", 8080, \"/wiremock\");\n</code></pre>"},{"location":"java_usage/plain_java/#the-client","title":"The Client","text":"<p>The <code>WireMock</code> class provides an over-the-wire client to a WireMock server (the local one by default).</p>"},{"location":"java_usage/plain_java/#configuring-for-static-calls","title":"Configuring for static calls","text":"<p>To configure the static client for an alternative host and port:</p> Java<pre><code>import static com.github.tomakehurst.wiremock.client.WireMock.*;\n\nconfigureFor(\"wiremock.host\", 8089);\nstubFor(get(....));\n</code></pre> <p>If you've deployed the server into a servlet container under a path other than root you'll need to set that too:</p> Java<pre><code>WireMock.configureFor(\"tomcat.host\", 8080, \"/wiremock\");\n</code></pre>"},{"location":"java_usage/plain_java/#newing-up","title":"Newing up","text":"<p>Instances of <code>WireMock</code> can also be created. This is useful if you need to talk to more than one server instance.</p> Java<pre><code>WireMock wireMock = new WireMock(\"some.host\", 9090, \"/wm\"); // As above, 3rd param is for non-root servlet deployments\nwireMock.register(get(....)); // Equivalent to stubFor()\n</code></pre>"},{"location":"java_usage/runnint_without_the_http_server/","title":"Running without the HTTP Server","text":"<p>Documentation / java_usage / runnint_without_the_http_server </p> <p>If you want to run Wiremock inside another process, such as wrapping it in a serverless function such as on AWS Lambda, or using it as part of an application's integration tests, you previously would need to resort to Running as a Standalone Process.</p> <p>This works well, but has the overhead of a full HTTP server and HTTP calls back and forth that in some cases may not be relevant, and adds a fair bit of overhead to each call, and the memory footprint of the application.</p> <p>Since Wiremock v2.32.0, the <code>DirectCallHttpServer</code> provides the ability to run a Wiremock server without ever interacting with an HTTP layer.</p> <p>It can be constructed and used like so (example usage is adapted from <code>DirectCallHttpServerIntegrationTest</code>):</p> Java<pre><code>import com.github.tomakehurst.wiremock.WireMockServer;\nimport com.github.tomakehurst.wiremock.http.Response;\nimport com.github.tomakehurst.wiremock.direct.DirectCallHttpServer;\nimport com.github.tomakehurst.wiremock.direct.DirectCallHttpServerFactory;\n\nimport static com.github.tomakehurst.wiremock.core.WireMockConfiguration.wireMockConfig;\n// ..\n\nDirectCallHttpServerFactory factory = new DirectCallHttpServerFactory();\nWireMockServer wm = new WireMockServer(wireMockConfig().httpServerFactory(factory));\nwm.start(); // no-op, not required\n\nDirectCallHttpServer server = factory.getHttpServer();\n\nRequest request = new Request() {\n  // fill in with the incoming request data\n}\n\nResponse response = server.stubRequest(request);\n// then use the `response`'s data, and map it accordingly\n</code></pre> <p>Note that prior to Wiremock v2.32.0, you can use the workaround as described by Jamie Tanna, which uses internal APIs for this.</p>"},{"location":"java_usage/using_wiremock_with_jetty_12/","title":"Using WireMock with Jetty 12","text":"<p>Documentation / java_usage / using_wiremock_with_jetty_12 </p> <p>WireMock ships with Jetty 11 by default but fully supports Jetty 12 as well with a new module <code>wiremock-jetty12</code>. In this tutorial we are going to see how Wiremock could be configured to use Jetty 12.</p>"},{"location":"java_usage/using_wiremock_with_jetty_12/#prerequisites","title":"Prerequisites","text":"<ul> <li>Java 17</li> <li>Maven or Gradle, recent versions</li> <li>A Java project, based on Maven or Gradle</li> </ul>"},{"location":"java_usage/using_wiremock_with_jetty_12/#add-wiremock-dependency-to-your-project","title":"Add WireMock Dependency to your project","text":"MavenGradle XML<pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.wiremock&lt;/groupId&gt;\n    &lt;artifactId&gt;wiremock-jetty12&lt;/artifactId&gt;\n    &lt;version&gt;3.13.1&lt;/version&gt;\n    &lt;scope&gt;test&lt;/scope&gt;\n&lt;/dependency&gt;\n</code></pre> Groovy<pre><code>testImplementation \"org.wiremock:wiremock-jetty12:3.13.1\"\n</code></pre>"},{"location":"java_usage/using_wiremock_with_jetty_12/#limitations","title":"Limitations","text":"<p>There are few limitations that usage of Jetty 12 is imposing with respect to stubbing behavior.</p> <ul> <li>status message will not be returned to the client even if set by the stub explicitly     Java<pre><code>    stubFor(get(\"/my/resource\")\n        .willReturn(status(400)\n            .withStatusMessage(\"ERROR\")));\n\n    URI uri = URI.create(wireMockRule.url(\"/my/resource\"));\n    HttpURLConnection connection = (HttpURLConnection) uri.toURL ().openConnection ();\n    connection.setRequestMethod (\"GET\");\n\n    assertThat(connection.getResponseCode()).isEqualTo(400);\n    assertThat(connection.getResponseMessage()).isEqualTo(\"Bad Request\"); /* the status message is not returned */\n</code></pre></li> <li> <p>when using multipart form data, the body is not decoded into plain text in case of <code>base64</code> (or other encodings) </p> </li> <li> <p>serving files from configured file locations always ends up with redirect when folder (without trailing <code>/</code>) is requested</p> </li> </ul>"},{"location":"java_usage/wiremock_for_java_and_jvm_languages/","title":"WireMock for Java and JVM languages","text":"<p>Documentation / java_usage / wiremock_for_java_and_jvm_languages</p> <p>WireMock Cloud</p> <p>Centralize and scale your API mocks with WireMock Cloud.</p> <p>WireMock was originally created for Java development, and there are plenty of solutions when developing applications powered by the Java Virtual Machine.</p>"},{"location":"java_usage/wiremock_for_java_and_jvm_languages/#wiremock","title":"WireMock","text":"<p>WireMock, also known as WireMock Java is the flagman implementation of WireMock functionality and specifications, maintained on the WireMock GitHub organization. It is included into many distributions (including WireMock Docker), test framework adapters and products. Most of the documentation on this website is about WireMock Java, unless specified explicitly.</p> <p>Usage:</p> <ul> <li>Running WireMock as a Standalone server</li> <li>Using WireMock in plain Java without frameworks</li> </ul> <p>References:</p> <ul> <li>WireMock Java on GitHub</li> </ul>"},{"location":"java_usage/wiremock_for_java_and_jvm_languages/#integrations-with-test-frameworks","title":"Integrations with test frameworks","text":"<p>WireMock has integrations with many popular Java test frameworks for unit and integration testing.</p> <ul> <li>JUnit 5+ and Jupiter</li> <li>JUnit 4 and Vintage</li> <li>Testcontainers Java</li> <li>Spock - maintained outside WireMock's organization on GitHub</li> </ul>"},{"location":"java_usage/wiremock_for_java_and_jvm_languages/#wiremock-extensions","title":"WireMock Extensions","text":"<p>WireMock Java is extensible, and there is a number of available extensions that can be included into WireMock to extend its functionality, including but not limited to request filters, observability, storage, etc.</p> <p>A few popular extensions:</p> <ul> <li>Response Template Transformer</li> <li>Documentation</li> <li>This extension is a built-in part of the WireMock Java, but needs to be enabled explicitly</li> <li>Webhooks</li> <li>Documentation</li> <li>JSON Body Transformer, Callback Simulator, Request time matcher</li> <li>9cookies/wiremock-extensions     Active</li> <li>CORS Protection Extension</li> <li>RichieLoco/WiremockCorsExtension</li> </ul>"},{"location":"java_usage/wiremock_for_java_and_jvm_languages/#solutions-specific-to-jvm-technologies","title":"Solutions specific to JVM technologies","text":"<p>Here are references to particular JVM technologies and languages, sorted by alphabet:</p> <ul> <li>Android</li> <li>Clojure</li> <li>Groovy</li> <li>Kotlin</li> <li>Pact</li> <li>Scala</li> <li>Spring Boot</li> </ul>"},{"location":"mock_api_template_library/using_mock_api_templates/","title":"Using Mock API Templates","text":"<p>Documentation / mock_api_template_library / using_mock_api_templates </p> <p>This guide explains how to run an API template after you've downloaded the JSON file from the library page.</p>"},{"location":"mock_api_template_library/using_mock_api_templates/#wiremock-standalone-jar","title":"WireMock standalone JAR","text":"<ol> <li>Create a folder called <code>mappings</code> if one doesn't already exist in the directory containing the standalone JAR file.</li> <li>Copy the downloaded JSON file into the <code>mappings</code> directory then  e.g.</li> <li>The JSON will be automatically loaded at startup, via the command line</li> </ol> Bash<pre><code>java -jar wiremock-jre8-standalone-3.13.1.jar\n</code></pre> <p>See this page for general details on running WireMock standalone.</p>"},{"location":"mock_api_template_library/using_mock_api_templates/#in-wiremock-docker","title":"In WireMock Docker","text":"<ol> <li>Create a folder with a subfolder inside called <code>mappings</code>.</li> <li>Copy the JSON file into the <code>mappings</code> folder.</li> <li>Start the Docker container, mounting the parent folder e.g. assuming the current directory contains <code>mappings</code>:</li> </ol> Bash<pre><code>docker run -it --rm \\\n  -p 8080:8080 \\\n  --name wiremock \\\n  -v $PWD:/home/wiremock \\\n  wiremock/wiremock:3.13.1\n</code></pre> <p>See this page for general details on running WireMock Docker.</p>"},{"location":"mock_api_template_library/using_mock_api_templates/#plain-java","title":"Plain Java","text":"<p>If you're running WireMock embedded in a Java program or test suite you can place the JSON file in a folder called <code>mappings</code> then set its parent as the WireMock server's root at startup.</p> Java<pre><code>WireMockServer wm =\n  new WireMockServer(wireMockConfig()\n    .withRootDirectory(\"path/to/root\") // The parent folder of mappings\n  );\n</code></pre> <p>See this for general details on running WireMock in embedded Java.</p>"},{"location":"mock_api_template_library/using_mock_api_templates/#junit","title":"JUnit","text":"<p>To do the same thing using the JUnit Jupiter extension:</p> Java<pre><code>@RegisterExtension\n    static WireMockExtension wm1 = WireMockExtension.newInstance()\n            .options(wireMockConfig().withRootDirectory(\"path/to/root\"))\n            .build();\n</code></pre> <p>See this for general details on running WireMock with JUnit 5+ Jupiter.</p>"},{"location":"mock_api_template_library/using_mock_api_templates/#pushing-to-a-remotely-running-wiremock-server","title":"Pushing to a remotely running WireMock server","text":"<p>The mock API JSON can be pushed to a remotely running WireMock server via its Admin API.</p> <p>For instance if the WireMock server is running on <code>wiremock.dev.mycompany.com</code> port 8080, you can POST the JSON file to it e.g.</p> Bash<pre><code>curl -v -d@mockapi.json http://wiremock.dev.mycompany.com:8080/__admin/mappings/import\n</code></pre>"},{"location":"mock_api_template_library/wiremock_api_template_library/","title":"WireMock API Templates Library","text":"<p>Documentation / mock_api_template_library / wiremock_api_template_library</p> <p>WireMock Cloud</p> <p>To easily share templates across teams or choose from thousands of popular 3rd party templates, learn more about WireMock Cloud.</p> <p>The library.wiremock.org site provides a catalog of API Templates that can be used with both WireMock or WireMock Cloud. You can browse our library of mock API templates and examples, find the API that you need, and get a running mock in seconds - on your local machine or in the cloud.</p> <p></p>"},{"location":"mock_api_template_library/wiremock_api_template_library/#using-templates-in-wiremock","title":"Using templates in WireMock","text":"<ol> <li>Go to the Mock API Templates Library site</li> <li>Choose a template you need. There are categories and search capabilities at your disposal</li> <li>Click the Download WireMock JSON button to download the JSON file</li> <li>Use the JSON file to configure your WireMock instance    See Using Templates</li> </ol>"},{"location":"mock_api_template_library/wiremock_api_template_library/#using-templates-in-wiremock-cloud","title":"Using templates in WireMock Cloud","text":"<p>For WireMock Cloud there is also the Run in WireMock Cloud button that allows you to quickly import the Mock API definition into your project.</p>"},{"location":"mock_api_template_library/wiremock_api_template_library/#editing-and-adding-templates","title":"Editing and Adding templates","text":"<p>Template definitions can be found in another repository: wiremock/api-template-library.</p> <p>If you would like to edit the existing template or to contribute a new API template, feel free to submit a pull request to wiremock/api-template-library. This is a public repository enables WireMock and WireMock Cloud users  to build their own Mock APIs based off a public template, e.g. for your public service.</p> <p>A template can be added to featured list by adding the <code>featured</code> tag in the metadata JSON. If a template is somehow related to WireMock, please also use the <code>wiremock</code> tag.</p> <p>It may take some time to propagate changes to WireMock or WireMock Cloud.</p>"},{"location":"mock_api_template_library/wiremock_api_template_library/#references","title":"References","text":"<ul> <li>Templates Repository</li> <li>WireMock Library Sources</li> </ul>"},{"location":"protocols/json_web_tokens/","title":"JSON Web Tokens (JWT)","text":"<p>Documentation / protocols / json_web_tokens The JWT extension provides support for generating JWTs and corresponding JSON Web Key Sets (JWKS) in stub responses via response templating.</p> <p>For details see the project's README.</p>"},{"location":"protocols/mocking_grpc_services/","title":"Mocking gRPC services","text":"<p>Documentation / protocols / mocking_grpc_services</p> <p>WireMock Cloud</p> <p>WireMock Cloud can transform your gRPC API development, learn more about WireMock Cloud.</p> <p>WireMock 3.2.0+ supports mocking of gRPC services via the WireMock extension for gRPC.</p> <p>The extension scans for descriptor files (generated from the service's <code>.proto</code> files) in the <code>grpc</code> subdirectory of WireMock's root.</p> <p>Using these, it converts incoming messages to JSON before passing them to WireMock's core stubbing system which allows the existing JSON matchers to be used when matching requests. It also converts JSON responses back into proto messages so that all of WireMock's response definition features including templating can be used. </p> <p></p> <p>The extension also adds a Java DSL that works with the Java classes generated by <code>protoc</code>, while also providing a more gRPC idiomatic way of defining stubs.</p>"},{"location":"protocols/mocking_grpc_services/#java-usage","title":"Java usage","text":""},{"location":"protocols/mocking_grpc_services/#setup","title":"Setup","text":"<p>Add the extension JAR dependency to your project:</p> <p>Gradle:</p> Text Only<pre><code>implementation 'org.wiremock:wiremock-grpc-extension:0.11.0'\n</code></pre> <p>Maven:</p> XML<pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.wiremock&lt;/groupId&gt;\n    &lt;artifactId&gt;wiremock-grpc-extension&lt;/artifactId&gt;\n    &lt;version&gt;0.11.0&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> <p>Create a root directory for WireMock, typically <code>src/test/resources/wiremock</code>, and create a subdirectory in it named <code>grpc</code>.</p> <p>Copy the descriptor files generated by <code>protoc</code> from your <code>.proto</code> files into the <code>grpc</code> subdirectory.</p> <p>Initialise WireMock server with the extension enabled and the root directory set to the path created in the previous steps:</p> Java<pre><code>// Same config object also for the JUnit 4 rule or JUnit 5 extension\nWireMockServer wm = new WireMockServer(wireMockConfig()\n        .dynamicPort()\n        .withRootDirectory(\"src/test/resources/wiremock\")\n        .extensions(new GrpcExtensionFactory())\n));\n</code></pre> <p>Initialise a service class for the gRPC service you want to mock (this must be defined in the <code>.proto</code> file you compiled to a descriptor):</p> Java<pre><code>WireMockGrpcService mockGreetingService =\n    new WireMockGrpcService(\n        new WireMock(wm.getPort()),\n        \"com.example.grpc.GreetingService\"\n    );\n</code></pre>"},{"location":"protocols/mocking_grpc_services/#stubbing-via-json-matching-responses","title":"Stubbing via JSON matching + responses","text":"<p>To specify request criteria and response data using JSON:</p> Java<pre><code>mockGreetingService.stubFor(\n    method(\"greeting\")\n        .withRequestMessage(equalToJson(\"{ \\\"name\\\":  \\\"Tom\\\" }\"))\n        .willReturn(json(\"{ \"greeting\": \"Hi Tom from JSON\" }\")));\n</code></pre> <p>Or, with a templated response:</p> Java<pre><code>mockGreetingService.stubFor(\n    method(\"greeting\")\n        .withRequestMessage(equalToJson(\"{ \\\"name\\\":  \\\"${json-unit.any-string}\\\" }\"))\n        .willReturn(\n            jsonTemplate(\n                \"{ \\\"greeting\\\": \\\"Hello {{jsonPath request.body '$.name'}}\\\" }\")));\n</code></pre>"},{"location":"protocols/mocking_grpc_services/#stubbing-via-java-message-objects","title":"Stubbing via Java message objects","text":"<p>Matching and stubbing in the Java DSL can also be specified using the Java classes generated by <code>protoc</code>:</p> Java<pre><code>mockGreetingService.stubFor(\n    method(\"greeting\")\n        .withRequestMessage(equalToMessage(HelloRequest.newBuilder().setName(\"Tom\")))\n        .willReturn(message(HelloResponse.newBuilder().setGreeting(\"OK\"))));\n</code></pre>"},{"location":"protocols/mocking_grpc_services/#non-ok-responses","title":"Non-OK responses","text":"<p>You can return gRPC error codes instead of an OK response:</p> Java<pre><code>mockGreetingService.stubFor(\n    method(\"greeting\")\n        .withRequestMessage(equalToMessage(\n            HelloRequest.newBuilder().setName(\"Prereq failure\")\n        ))\n        .willReturn(Status.FAILED_PRECONDITION, \"Failed on some prerequisite\"));\n</code></pre>"},{"location":"protocols/mocking_grpc_services/#more-examples","title":"More examples","text":"<p>For a more complete set of examples, see the Java demo project.</p>"},{"location":"protocols/mocking_grpc_services/#standalone-usage","title":"Standalone usage","text":""},{"location":"protocols/mocking_grpc_services/#setup_1","title":"Setup","text":"<p>Download the standalone JAR at version 3.2.0 or above  and the gRPC extension JAR into your working directory.</p> <p>Create a WireMock data directory with two subdirectories; one for stub mappings, and another for descriptor files:</p> Bash<pre><code>mkdir -p wiremock wiremock/mappings wiremock/grpc\n</code></pre> <p>Compile your proto files into descriptors:</p> Bash<pre><code>protoc --descriptor_set_out wiremock/grpc/services.dsc ExampleServices.proto\n</code></pre> <p>Run WireMock, with both directories you just created on the classpath:</p> Bash<pre><code>java -cp wiremock-standalone-3.13.1.jar:wiremock-grpc-extension-standalone-0.11.0.jar \\\n  wiremock.Run \\\n  --root-dir wiremock\n</code></pre>"},{"location":"protocols/mocking_grpc_services/#stubbing","title":"Stubbing","text":"<p>gRPC stubs are defined using WireMock's standard JSON format. Requests should always be matched with a <code>POST</code> method and a URL path of <code>/&lt;fully-qualified service name&gt;/&lt;method name&gt;</code>.</p> JSON<pre><code>{\n  \"request\" : {\n    \"urlPath\" : \"/com.example.grpc.GreetingService/greeting\",\n    \"method\" : \"POST\",\n    \"bodyPatterns\" : [{\n      \"equalToJson\" : \"{ \\\"name\\\":  \\\"Tom\\\" }\"\n    }]\n  },\n  \"response\" : {\n    \"status\" : 200,\n    \"body\" : \"{\\n  \\\"greeting\\\": \\\"Hi Tom\\\"\\n}\",\n    \"headers\" : {\n      \"grpc-status-name\" : \"OK\"\n    }\n  }\n}\n</code></pre>"},{"location":"protocols/mocking_grpc_services/#reloading-grpc-descriptor-files","title":"Reloading gRPC descriptor files","text":"<p>If you plan to update your gRPC descriptor files at runtime, you can inform WireMock to reload all file descriptors via a POST to the admin API endpoint <code>/__admin/ext/grpc/reset</code>.</p>"},{"location":"protocols/mocking_grpc_services/#more-demos","title":"More Demos","text":"<p>For more see the standalone demo project.</p>"},{"location":"protocols/serving_https/","title":"Serving HTTPS","text":"<p>Documentation / protocols / serving_https </p> <p>WireMock can optionally accept requests over HTTPs. By default it will serve its own self-signed TLS certificate, but this can be overridden if required by providing a keystore containing another certificate.</p>"},{"location":"protocols/serving_https/#handling-https-requests","title":"Handling HTTPS requests","text":"<p>To enable HTTPS using WireMock's self-signed certificate just specify an HTTPS port:</p> Java<pre><code>@Rule\npublic WireMockRule wireMockRule = new WireMockRule(wireMockConfig().httpsPort(8443));\n</code></pre> <p>To use your own keystore you can specify its path and optionally its password:</p> Java<pre><code>@Rule\npublic WireMockRule wireMockRule = new WireMockRule(wireMockConfig()\n    .httpsPort(8443)\n    .keystorePath(\"/path/to/keystore.jks\") // Either a path to a file or a resource on the classpath\n    .keystorePassword(\"verysecret\") // The password used to access the keystore. Defaults to \"password\" if omitted\n    .keyManagerPassword(\"verysecret\")); // The password used to access individual keys in the keystore. Defaults to \"password\" if omitted\n</code></pre> <p>The keystore type defaults to JKS, but this can be changed if you're using another keystore format e.g. Bouncycastle's BKS with Android:</p> Java<pre><code>.keystoreType(\"BKS\")\n</code></pre> <p>To allow only HTTPS requests, disable HTTP by adding:</p> Java<pre><code>@Rule\npublic WireMockRule wireMockRule = new WireMockRule(wireMockConfig().httpsPort(8443).httpDisabled(true));\n</code></pre>"},{"location":"protocols/serving_https/#requiring-client-certificates","title":"Requiring client certificates","text":"<p>To make WireMock require clients to authenticate via a certificate you need to supply a trust store containing the certs to trust and enable client auth:</p> Java<pre><code>@Rule\npublic WireMockRule wireMockRule = new WireMockRule(wireMockConfig()\n    .httpsPort(8443)\n    .needClientAuth(true)\n    .trustStorePath(\"/path/to/truststore.jks\") // Either a path to a file or a resource on the classpath\n    .trustStorePassword(\"mostsecret\")); // Defaults to \"password\" if omitted\n</code></pre> <p>If you using WireMock as a proxy onto another system which requires client certificate authentication, you will also need to specify a trust store containing the certificate(s).</p> <p>note</p> <p>Jetty requires client certificates to contain Subject Alternative Names. See this script for an example of how to build a truststore containing a valid certificate (you'll probably want to edit the client-cert.conf file before running this).</p>"},{"location":"protocols/serving_https/#common-https-issues","title":"Common HTTPS issues","text":"<p><code>javax.net.ssl.SSLException: Unrecognized SSL message, plaintext connection?</code>: Usually means you've tried to connect to the HTTP port with a client that's expecting HTTPS (i.e. has <code>https://</code> in the URL).</p> <p><code>org.apache.hc.core5.http.NoHttpResponseException: The target server failed to respond</code>: Could mean you've tried to connect to the HTTPS port with a client expecting HTTP.</p> <p><code>javax.net.ssl.SSLHandshakeException: sun.security.validator.ValidatorException: PKIX path building failed: sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target</code>: You are using WireMock's default (self-signed) TLS certificate or another certificate that isn't signed by a CA. In this case you need to specifically configure your HTTP client to trust the certificate being presented, or to trust all certificates. Here is an example of how to do this with the Apache HTTP client.</p>"},{"location":"protocols/webhooks_and_callbacks/","title":"Webhooks and Callbacks","text":"<p>Documentation / protocols / webhooks_and_callbacks </p> <p>WireMock can make asynchronous outbound HTTP calls when an incoming request is matched to a specific stub. This pattern is commonly referred to as webhooks or callbacks and is a common design in APIs that need to proactively notify their clients of events or perform long-running processing asynchronously without blocking.</p>"},{"location":"protocols/webhooks_and_callbacks/#enabling-webhooks","title":"Enabling webhooks","text":"<p>Prior to WireMock 3.1.0 webhooks were provided via an extension and needed to be explicitly enabled. See the 2.x docs for details on how to do this.</p> <p>From version 3.1.0 the webhooks extension is part of WireMock's core and enabled by default.</p>"},{"location":"protocols/webhooks_and_callbacks/#old-vs-new-extension-point","title":"Old vs. new extension point","text":"<p>The revised version of webhooks in 3.1.0 makes use of the new <code>ServeEventListener</code> extension point. This article shows how to use this newer extension point, however the legacy <code>PostServeAction</code> interface is still supported for backwards compatibility.</p>"},{"location":"protocols/webhooks_and_callbacks/#creating-a-simple-single-webhook","title":"Creating a simple, single webhook","text":"<p>You can trigger a single webhook request to a fixed URL, with fixed data like this:</p> <p>Java:</p> Java<pre><code>import static org.wiremock.webhooks.Webhooks.*;\n...\n\nwm.stubFor(post(urlPathEqualTo(\"/something-async\"))\n    .willReturn(ok())\n    .withServeEventListener(\"webhook\", webhook()\n        .withMethod(POST)\n        .withUrl(\"http://my-target-host/callback\")\n        .withHeader(\"Content-Type\", \"application/json\")\n        .withBody(\"{ \\\"result\\\": \\\"SUCCESS\\\" }\"))\n  );\n</code></pre> <p>JSON:</p> JSON<pre><code>{\n    \"request\": {\n        \"urlPath\": \"/something-async\",\n        \"method\": \"POST\"\n    },\n    \"response\": {\n        \"status\": 200\n    },\n    \"serveEventListeners\": [\n        {\n            \"name\": \"webhook\",\n            \"parameters\": {\n                \"method\": \"POST\",\n                \"url\": \"http://my-target-host/callback\",\n                \"headers\": {\n                    \"Content-Type\": \"application/json\"\n                },\n                \"body\": \"{ \\\"result\\\": \\\"SUCCESS\\\" }\"\n            }\n        }\n    ]\n}\n</code></pre>"},{"location":"protocols/webhooks_and_callbacks/#using-data-from-the-original-request","title":"Using data from the original request","text":"<p>Webhooks use the same templating system as WireMock responses. This means that any of the configuration fields can be provided with a template expression which will be resolved before firing the webhook.</p> <p>Similarly to response templates the original request data is available, although in this case it is named <code>originalRequest</code>.</p> <p>Supposing we wanted to pass a transaction ID from the original (triggering) request and insert it into the JSON request body sent by the webhook call.</p> <p>For an original request body JSON like this:</p> JSON<pre><code>{\n    \"transactionId\": \"12345\"\n}\n</code></pre> <p>We could construct a JSON request body in the webhook like this:</p> <p>Java:</p> Java<pre><code>wm.stubFor(post(urlPathEqualTo(\"/templating\"))\n      .willReturn(ok())\n      .withServeEventListener(\"webhook\", webhook()\n          .withMethod(POST)\n          .withUrl(\"http://my-target-host/callback\")\n          .withHeader(\"Content-Type\", \"application/json\")\n          .withBody(\"{ \\\"message\\\": \\\"success\\\", \\\"transactionId\\\": \\\"{{jsonPath originalRequest.body '$.transactionId'}}\\\" }\")\n  );\n</code></pre> <p>JSON:</p> JSON<pre><code>{\n    \"request\": {\n        \"urlPath\": \"/templating\",\n        \"method\": \"POST\"\n    },\n    \"response\": {\n        \"status\": 200\n    },\n    \"serveEventListeners\": [\n        {\n            \"name\": \"webhook\",\n            \"parameters\": {\n                \"method\": \"POST\",\n                \"url\": \"http://my-target-host/callback\",\n                \"headers\": {\n                    \"Content-Type\": \"application/json\"\n                },\n                \"body\": \"{ \\\"message\\\": \\\"success\\\", \\\"transactionId\\\": \\\"{{jsonPath originalRequest.body '$.transactionId'}}\\\" }\"\n            }\n        }\n    ]\n}\n</code></pre> <p>note</p> <p>Webhook templates currently do not support system or environment variables.</p>"},{"location":"protocols/webhooks_and_callbacks/#implementing-a-callback-using-templating","title":"Implementing a callback using templating","text":"<p>To implement the callback pattern, where the original request contains the target to be called on completion of a long-running task, we can use templating on the URL and method.</p> <p>Java:</p> Java<pre><code>wm.stubFor(post(urlPathEqualTo(\"/something-async\"))\n      .willReturn(ok())\n      .withServeEventListener(\"webhook\", webhook()\n          .withMethod(\"{{jsonPath originalRequest.body '$.callbackMethod'}}\")\n          .withUrl(\"{{jsonPath originalRequest.body '$.callbackUrl'}}\"))\n  );\n</code></pre> <p>JSON:</p> JSON<pre><code>{\n    \"request\": {\n        \"urlPath\": \"/something-async\",\n        \"method\": \"POST\"\n    },\n    \"response\": {\n        \"status\": 200\n    },\n    \"serveEventListeners\": [\n        {\n            \"name\": \"webhook\",\n            \"parameters\": {\n                \"method\": \"{{jsonPath originalRequest.body '$.callbackMethod'}}\",\n                \"url\": \"{{jsonPath originalRequest.body '$.callbackUrl'}}\"\n            }\n        }\n    ]\n}\n</code></pre>"},{"location":"protocols/webhooks_and_callbacks/#adding-delays","title":"Adding delays","text":"<p>A fixed or random delay can be added before the webhook call is made, using the same style of delay parameters as stubs.</p>"},{"location":"protocols/webhooks_and_callbacks/#fixed-delays","title":"Fixed delays","text":"<p>Java:</p> Java<pre><code>wm.stubFor(post(urlPathEqualTo(\"/delayed\"))\n    .willReturn(ok())\n    .withServeEventListener(\"webhook\", webhook()\n      .withFixedDelay(1000)\n      .withMethod(RequestMethod.GET)\n      .withUrl(\"http://my-target-host/callback\")\n    )\n);\n</code></pre> <p>JSON:</p> JSON<pre><code>{\n    \"request\": {\n        \"urlPath\": \"/delayed\",\n        \"method\": \"POST\"\n    },\n    \"response\": {\n        \"status\": 200\n    },\n    \"serveEventListeners\": [\n        {\n            \"name\": \"webhook\",\n            \"parameters\": {\n                \"method\": \"GET\",\n                \"url\": \"http://my-target-host/callback\",\n                \"delay\": {\n                    \"type\": \"fixed\",\n                    \"milliseconds\": 1000\n                }\n            }\n        }\n    ]\n}\n</code></pre>"},{"location":"protocols/webhooks_and_callbacks/#random-delays","title":"Random delays","text":"<p>Java:</p> Java<pre><code>wm.stubFor(post(urlPathEqualTo(\"/delayed\"))\n    .willReturn(ok())\n    .withServeEventListener(\"webhook\", webhook()\n      .withDelay(new UniformDistribution(500, 1000))\n      .withMethod(RequestMethod.GET)\n      .withUrl(\"http://my-target-host/callback\")\n    )\n);\n</code></pre> <p>JSON:</p> JSON<pre><code>{\n    \"request\": {\n        \"urlPath\": \"/delayed\",\n        \"method\": \"POST\"\n    },\n    \"response\": {\n        \"status\": 200\n    },\n    \"serveEventListeners\": [\n        {\n            \"name\": \"webhook\",\n            \"parameters\": {\n                \"method\": \"GET\",\n                \"url\": \"http://my-target-host/callback\",\n                \"delay\": {\n                    \"type\": \"uniform\",\n                    \"lower\": 500,\n                    \"upper\": 1000\n                }\n            }\n        }\n    ]\n}\n</code></pre>"},{"location":"protocols/webhooks_and_callbacks/#observing-webhook-events","title":"Observing webhook events","text":"<p>As of WireMock <code>3.7.0</code>, successful webhook requests and responses are logged as Sub Events in the request log.  Any  errors that happen as part of the webhook request (not able to contact the target site or error in the handlebars template for example) are logged as error Sub Events in the request log. An example of a successful request/response webhook Sub Event:</p> JSON<pre><code>{\n    \"subEvents\": [\n        {\n          \"type\": \"WEBHOOK_REQUEST\",\n          \"timeOffsetNanos\": 0,\n          \"data\": {\n            \"url\": \"/2865e463-1f98-4899-8837-90b89364a5dc\",\n            \"absoluteUrl\": \"https://example.com/2865e463-1f98-4899-8837-90b89364a5dc\",\n            \"method\": \"POST\",\n            \"headers\": {\n              \"Content-Type\": \"application/json\",\n              \"Accept\": \"application/json\"\n            },\n            \"browserProxyRequest\": false,\n            \"loggedDate\": 1719826613928,\n            \"bodyAsBase64\": \"eyJvbGRTdGF0ZSI6IHt9LCAibmV3U3RhdGUiOiB7fX0=\",\n            \"body\": \"{\\\"oldState\\\": {}, \\\"newState\\\": {}}\",\n            \"scheme\": \"https\",\n            \"host\": \"example.com\",\n            \"port\": 443,\n            \"loggedDateString\": \"2024-07-01T09:36:53.928Z\",\n            \"queryParams\": {},\n            \"formParams\": {}\n          }\n        },\n        {\n          \"type\": \"WEBHOOK_RESPONSE\",\n          \"timeOffsetNanos\": 0,\n          \"data\": {\n            \"status\": 200,\n            \"headers\": {\n              \"Transfer-Encoding\": \"chunked\",\n              \"X-Token-Id\": \"2865e463-1f98-4899-8837-90b89364a5dc\",\n              \"Cache-Control\": \"no-cache, private\",\n              \"Server\": \"nginx\",\n              \"X-Request-Id\": \"f530c738-bc00-48f2-8382-2394c25a32c6\",\n              \"Vary\": \"Accept-Encoding\",\n              \"Date\": \"Mon, 01 Jul 2024 09:36:54 GMT\",\n              \"Content-Type\": \"text/html; charset=UTF-8\"\n            },\n            \"bodyAsBase64\": \"\",\n            \"body\": \"\"\n          }\n        }\n      ]\n}\n</code></pre>"},{"location":"protocols/webhooks_and_callbacks/#extending-webhooks","title":"Extending webhooks","text":"<p>Webhook behaviour can be further customised in code via an extension point.</p> <p>This works in a similar fashion to response transformation. The extension class implements the <code>WebhookTransformer</code> interface and is then loaded via the extension mechanism (see Extending WireMock).</p> Java<pre><code>public class MyWebhookTransformer implements WebhookTransformer {\n\n  @Override\n  public WebhookDefinition transform(\n    ServeEvent serveEvent,\n    WebhookDefinition webhookDefinition) {\n    // build and return a new WebhookDefinition with some custom changes\n  }\n}\n</code></pre>"},{"location":"record_and_playback/record_and_playback/","title":"Record and Playback","text":"<p>Documentation / record_and_playback / record_and_playback </p> <p>WireMock Cloud</p> <p>Wiremock Cloud CLI supports simultaneous multi-API recording with advanced customisation of recorded stubs</p> <p>WireMock can create stub mappings from requests it has received. Combined with its proxying feature this allows you to \"record\" stub mappings from interaction with existing APIs.</p> <p>Two approaches are available: Recording or snapshotting. The same results can be achieved with either, so which you choose should depend on whatever fits best with your workflow. If you're new to WireMock, recording is probably the simplest option for getting started.</p> <p>Both approaches are described in more detail below.</p>"},{"location":"record_and_playback/record_and_playback/#quick-start","title":"Quick start","text":"<p>The fastest way to get started with WireMock's recorder is to use the simple web UI provided.</p> <p>First, start an instance of WireMock running standalone. Once that's running visit the recorder UI page at http://localhost:8080/__admin/recorder (assuming you started WireMock on the default port of 8080).</p> <p></p> <p>Enter the URL you wish to record from in the target URL field and click the Record button. You can use <code>http://examples.wiremockapi.cloud</code> to try it out.</p> <p>Now you need to make a request through WireMock to the target API so that it can be recorded. If you're using the example URL, you can generate a request using curl:</p> Bash<pre><code>$ curl http://localhost:8080/recordables/123\n</code></pre> <p>Now click stop. You should see a message indicating that one stub was captured.</p> <p>You should also see that a file has been created called something like <code>recordables_123-40a93c4a-d378-4e07-8321-6158d5dbcb29.json</code> under the <code>mappings</code> directory created when WireMock started up, and that a new mapping has appeared at http://localhost:8080/__admin/mappings.</p> <p>Requesting the same URL again (possibly disabling your wifi first if you want firm proof) will now serve the recorded result:</p> Text Only<pre><code>$ curl http://localhost:8080/recordables/123\n\n{\n  \"message\": \"Congratulations on your first recording!\"\n}\n</code></pre> <p>note</p> <p>Stub mappings will only be created at the point that the recording is stopped.</p> <p>note</p> <p>\"Playback\" doesn't require any explicit action. Recorded stubs will start being served immediately after recording is stopped.</p>"},{"location":"record_and_playback/record_and_playback/#recording","title":"Recording","text":"<p>Recording can also be started and stopped via WireMock's JSON API and Java DSL.</p> <p>Java:</p> Java<pre><code>// Static DSL\nWireMock.startRecording(\"http://examples.wiremockapi.cloud/\");\nList&lt;StubMapping&gt; recordedMappings = WireMock.stopRecording();\n\n// Client instance\nWireMock wireMockClient = new WireMock(8080);\nwireMockClient.startStubRecording(\"http://examples.wiremockapi.cloud/\");\nList&lt;StubMapping&gt; recordedMappings = wireMockClient.stopStubRecording();\n\n// Directly\nWireMockServer wireMockServer = new WireMockServer();\nwireMockServer.start();\nwireMockServer.startRecording(\"http://examples.wiremockapi.cloud/\");\nList&lt;StubMapping&gt; recordedMappings = wireMockServer.stopRecording();\n</code></pre> <p>API:</p> JSON<pre><code>POST /__admin/recordings/start\n{\n  \"targetBaseUrl\": \"http://examples.wiremockapi.cloud/\"\n}\n</code></pre> Text Only<pre><code>POST /__admin/recordings/stop\n</code></pre>"},{"location":"record_and_playback/record_and_playback/#snapshotting","title":"Snapshotting","text":"<p>Snapshotting is effectively \"recording after the fact\". Rather than starting recording at a specific point, snapshotting allows you to convert requests already received by WireMock into stub mappings.</p> <p>An implication of this order of events is that if you want to record an external API, you'll need to have configured proxying before you start generating traffic. See Proxying for details on proxy configuration, but in summary this can be achieved by creating a proxy mapping via the API or Java DSL:</p> <p>Java:</p> Java<pre><code>stubFor(proxyAllTo(\"http://examples.wiremockapi.cloud/\").atPriority(1));\n</code></pre> <p>API:</p> JSON<pre><code>POST /__admin/mappings\n{\n    \"priority\": 1,\n    \"request\": {\n        \"method\": \"ANY\"\n    },\n    \"response\": {\n        \"proxyBaseUrl\" : \"http://examples.wiremockapi.cloud/\"\n    }\n}\n</code></pre> <p>note</p> <p>You can still take snapshots without a proxy stub configured. You might want to do this e.g. if you want to capture requests made by your application under test that you can then modify by hand to provide the appropriate responses.</p> <p>Once you have made some requests through WireMock (which you can view under http://localhost:8080/__admin/requests) you can trigger a snapshot to generate stub mappings:</p> <p>Java:</p> Java<pre><code>// Static DSL\nList&lt;StubMapping&gt; recordedMappings = WireMock.snapshotRecord();\n\n// Client instance\nWireMock wireMockClient = new WireMock(8080);\nList&lt;StubMapping&gt; recordedMappings = wireMockClient.takeSnapshotRecording();\n\n// Directly\nWireMockServer wireMockServer = new WireMockServer();\nwireMockServer.start();\nList&lt;StubMapping&gt; recordedMappings = wireMockServer.snapshotRecord();\n</code></pre> <p>API:</p> Text Only<pre><code>POST /__admin/recordings/snapshot\n{}\n</code></pre>"},{"location":"record_and_playback/record_and_playback/#customising-your-recordings","title":"Customising your recordings","text":"<p>The default recording behaviour can be tweaked in a number of ways by passing a \"record spec\" to the record or snapshot actions.</p> <p>In Java this achieved using the DSL:</p> Java<pre><code>startRecording(\n      recordSpec()\n          .forTarget(\"http://examples.wiremockapi.cloud/\")\n          .onlyRequestsMatching(getRequestedFor(urlPathMatching(\"/api/.*\")))\n          .captureHeader(\"Accept\")\n          .captureHeader(\"Content-Type\", true)\n          .extractBinaryBodiesOver(10240)\n          .extractTextBodiesOver(2048)\n          .makeStubsPersistent(false)\n          .ignoreRepeatRequests()\n          .transformers(\"modify-response-header\")\n          .transformerParameters(Parameters.one(\"headerValue\", \"123\"))\n          .matchRequestBodyWithEqualToJson(false, true)\n  );\n</code></pre> <p>And via the API:</p> JSON<pre><code>POST /__admin/recordings/start\n{\n  \"targetBaseUrl\" : \"http://examples.wiremockapi.cloud/\",\n  \"filters\" : {\n    \"urlPathPattern\" : \"/api/.*\",\n    \"method\" : \"GET\",\n    \"allowNonProxied\": true\n  },\n  \"captureHeaders\" : {\n    \"Accept\" : { },\n    \"Content-Type\" : {\n      \"caseInsensitive\" : true\n    }\n  },\n  \"requestBodyPattern\" : {\n    \"matcher\" : \"equalToJson\",\n    \"ignoreArrayOrder\" : false,\n    \"ignoreExtraElements\" : true\n  },\n  \"extractBodyCriteria\" : {\n    \"textSizeThreshold\" : \"2048\",\n    \"binarySizeThreshold\" : \"10240\"\n  },\n  \"persist\" : false,\n  \"repeatsAsScenarios\" : false,\n  \"transformers\" : [ \"modify-response-header\" ],\n  \"transformerParameters\" : {\n    \"headerValue\" : \"123\"\n  }\n}\n</code></pre> <p>The same specification can also be passed when snapshotting:</p> <p>Java:</p> Java<pre><code>snapshotRecord(\n      recordSpec()\n          .onlyRequestsMatching(getRequestedFor(urlPathMatching(\"/api/.*\")))\n          .onlyRequestIds(singletonList(UUID.fromString(\"40a93c4a-d378-4e07-8321-6158d5dbcb29\")))\n          .allowNonProxied(true)\n          .captureHeader(\"Accept\")\n          .captureHeader(\"Content-Type\", true)\n          .extractBinaryBodiesOver(10240)\n          .extractTextBodiesOver(2048)\n          .makeStubsPersistent(false)\n          .ignoreRepeatRequests()\n          .transformers(\"modify-response-header\")\n          .transformerParameters(Parameters.one(\"headerValue\", \"123\"))\n          .chooseBodyMatchTypeAutomatically()\n  );\n</code></pre> <p>API:</p> JSON<pre><code>POST /__admin/recordings/snapshot\n{\n  \"filters\" : {\n    \"urlPathPattern\" : \"/api/.*\",\n    \"method\" : \"GET\",\n    \"ids\" : [ \"40a93c4a-d378-4e07-8321-6158d5dbcb29\" ]\n  },\n  \"captureHeaders\" : {\n    \"Accept\" : { },\n    \"Content-Type\" : {\n      \"caseInsensitive\" : true\n    }\n  },\n  \"requestBodyPattern\" : {\n    \"matcher\" : \"equalToJson\",\n    \"ignoreArrayOrder\" : false,\n    \"ignoreExtraElements\" : true\n  },\n  \"extractBodyCriteria\" : {\n    \"textSizeThreshold\" : \"2 kb\",\n    \"binarySizeThreshold\" : \"1 Mb\"\n  },\n  \"outputFormat\" : \"FULL\",\n  \"persist\" : false,\n  \"repeatsAsScenarios\" : false,\n  \"transformers\" : [ \"modify-response-header\" ],\n  \"transformerParameters\" : {\n    \"headerValue\" : \"123\"\n  }\n}\n</code></pre> <p>The following sections will detail each parameter in turn:</p>"},{"location":"record_and_playback/record_and_playback/#filtering","title":"Filtering","text":"<p><code>filters</code> supports selection of requests to be recorded according to the same request matcher format used elsewhere in WireMock.</p> <p>Additionally, when snapshotting the <code>ids</code> parameter allows specific serve events to be selected by ID.</p> <p>The <code>allowNonProxied</code> attribute, when set to <code>true</code> will cause requests that did not get proxied to a target service to be recorded/snapshotted. This is useful if you wish to \"teach\" WireMock your API by feeding it requests from your app that initially don't match a stub, then snapshotting to generate the correct stubs.</p>"},{"location":"record_and_playback/record_and_playback/#capturing-request-headers","title":"Capturing request headers","text":"<p>You may want your recorded stub mappings to match on one or more specific request headers. For instance if you're intending to record from an API that supports both XML and JSON responses via content negotiation, then you will need to capture the value of the <code>Accept</code> header sent in each request.</p> <p>The <code>captureHeaders</code> attribute allows you to specify a map of header names to match parameter objects. Currently the only parameter available is <code>caseInsensitive</code>, which defaults to false if absent.</p>"},{"location":"record_and_playback/record_and_playback/#body-files-extraction-size-criteria","title":"Body files extraction size criteria","text":"<p>By default, recorded response bodies will be included directly in the stub mapping response part, via the <code>body</code> attribute for text or <code>base64Body</code> for binary content.</p> <p>However, this can be overridden by setting the <code>textSizeThreshold</code> and <code>binarySizeThreshold</code> values under <code>extractBodyCriteria</code>. The size values are of type string, and support friendly syntax for specifying the order of magnitude e.g.</p> Text Only<pre><code>\"56 kb\"\n\"10 Mb\"\n\"18.2 GB\"\n\"255\" // bytes when no magnitude specified\n</code></pre> <p>In the Java DSL these values are specified as a <code>long</code> number of bytes:</p> Java<pre><code>recordSpec().extractBinaryBodiesOver(204800)\n</code></pre>"},{"location":"record_and_playback/record_and_playback/#output-format","title":"Output format","text":"<p>By default the stop recording and snapshot API calls will return the full JSON of all mappings captured. If you only require the IDs of captured stubs you can specify:</p> JSON<pre><code>{\n    \"outputFormat\": \"IDS\"\n}\n</code></pre>"},{"location":"record_and_playback/record_and_playback/#persist-stubs","title":"Persist stubs","text":"<p>By default generated stubs will be set to persistent, meaning that they will be saved to the file system (or other back-end if you've implemented your own <code>MappingsSource</code>) and will survive calls to reset mappings to default.</p> <p>Setting <code>persist</code> to <code>false</code> means that stubs will not be saved and will be deleted on the next reset.</p>"},{"location":"record_and_playback/record_and_playback/#repeats-as-scenarios","title":"Repeats as scenarios","text":"<p>What happens when the recorder sees two identical requests that produce different results?</p> <p>There are two ways to handle this. Setting <code>repeatsAsScenarios</code> to <code>false</code> means that after the first request, subsequent identical ones will be ignored.</p> <p>However, when set to <code>true</code> (which is the default if omitted), multiple identical requests will be added to a Scenario, meaning that when playing back, a series of requests matching this stub will yield the same series of responses captured during recording. If more requests are made after the end of the series is reached, the last response will continue to be returned.</p>"},{"location":"record_and_playback/record_and_playback/#transforming-generated-stubs","title":"Transforming generated stubs","text":"<p>If you need even more control over how your recorded stubs are generated, you can write one or more custom transformers that will be applied to stubs as they are captured.</p> <p>A transformer is an implementations of <code>StubMappingTransformer</code> and needs to be registered when starting WireMock as described in Extending WireMock.</p> <p>Transformer implementations supply a name, and this is used to identify them in the <code>transformers</code> parameter e.g.</p> JSON<pre><code>\"transformers\": [\"transformer-one\", \"transformer-two\"]\n</code></pre> <p>As with other types of WireMock extension, parameters can be supplied. The exact parameters required depend on the specifics of the transformer (or it may not require any).</p> JSON<pre><code>\"transformerParameters\": {\n    \"simpleParam1\": \"One\",\n    \"arrayParam2\": [1, 2, 3],\n    ...\n}\n</code></pre>"},{"location":"record_and_playback/record_and_playback/#request-body-matching","title":"Request body matching","text":"<p>By default, the body match operator for a recorded stub is based on the <code>Content-Type</code> header of the request. For MIME types containing the string \"json\", the operator will be <code>equalToJson</code> with both the <code>ignoreArrayOrder</code> and <code>ignoreExtraElements</code> options set to <code>true</code>. For MIME types containing <code>xml</code>, it will use <code>equalToXml</code>. Otherwise, it will use <code>equalTo</code> with the <code>caseInsensitive</code> option set to <code>false</code>.</p> <p>This behavior can be customized via the <code>requestBodyPattern</code> parameter, which accepts a <code>matcher</code> (either <code>equalTo</code>, <code>equalToJson</code>, <code>equalToXml</code>, or <code>auto</code>) and any relevant matcher options (<code>ignoreArrayOrder</code>, <code>ignoreExtraElements</code>, or <code>caseInsensitive</code>). For example, here's how to preserve the default behavior, but set <code>ignoreArrayOrder</code> to <code>false</code> when <code>equalToJson</code> is used:</p> JSON<pre><code>\"requestBodyPattern\" : {\n    \"matcher\": \"auto\",\n    \"ignoreArrayOrder\" : false\n  }\n</code></pre> <p>If you want to always match request bodies with <code>equalTo</code> case-insensitively, regardless of the MIME type, use:</p> JSON<pre><code>\"requestBodyPattern\" : {\n    \"matcher\": \"equalTo\",\n    \"caseInsensitive\" : true\n  }\n</code></pre> <p>note</p> <p>The <code>targetBaseUrl</code> parameter will be ignored when snapshotting and the <code>filters/ids</code> parameter will be ignored when recording.</p>"},{"location":"reference/admin-api-reference/","title":"Admin API Reference","text":"<p>Documentation / reference / admin-api-reference</p> <p>WireMock Cloud</p> <p>WireMock Cloud offers secure, publicly hosted mock APIs with nothing to install.</p> <p>The WireMock admin API is described in OpenAPI 3.0. The spec file plus an instance of Swagger UI can be accessed from a running WireMock instance under <code>/__admin/docs/</code>, e.g. <code>http://localhost:8080/__admin/docs/</code>.</p> <p>Below is the full API reference:</p> <p></p>"},{"location":"reference/mock-api-templates/","title":"WireMock API Templates Library","text":"<p>Documentation / reference / mock-api-templates</p> <p>WireMock Cloud</p> <p>To easily share templates across teams or choose from thousands of popular 3rd party templates, learn more about WireMock Cloud.</p> <p>The library.wiremock.org site provides a catalog of API Templates that can be used with both WireMock or WireMock Cloud. You can browse our library of mock API templates and examples, find the API that you need, and get a running mock in seconds - on your local machine or in the cloud.</p> <p></p>"},{"location":"reference/mock-api-templates/#using-templates-in-wiremock","title":"Using templates in WireMock","text":"<ol> <li>Go to the Mock API Templates Library site</li> <li>Choose a template you need. There are categories and search capabilities at your disposal</li> <li>Click the Download WireMock JSON button to download the JSON file</li> <li>Use the JSON file to configure your WireMock instance    See Using Templates</li> </ol>"},{"location":"reference/mock-api-templates/#using-templates-in-wiremock-cloud","title":"Using templates in WireMock Cloud","text":"<p>For WireMock Cloud there is also the Run in WireMock Cloud button that allows you to quickly import the Mock API definition into your project.</p>"},{"location":"reference/mock-api-templates/#editing-and-adding-templates","title":"Editing and Adding templates","text":"<p>Template definitions can be found in another repository: wiremock/api-template-library.</p> <p>If you would like to edit the existing template or to contribute a new API template, feel free to submit a pull request to wiremock/api-template-library. This is a public repository enables WireMock and WireMock Cloud users  to build their own Mock APIs based off a public template, e.g. for your public service.</p> <p>A template can be added to featured list by adding the <code>featured</code> tag in the metadata JSON. If a template is somehow related to WireMock, please also use the <code>wiremock</code> tag.</p> <p>It may take some time to propagate changes to WireMock or WireMock Cloud.</p>"},{"location":"reference/mock-api-templates/#references","title":"References","text":"<ul> <li>Templates Repository</li> <li>WireMock Library Sources</li> </ul>"},{"location":"running_wiremock/administration_api/","title":"Administration API","text":"<p>Documentation / running_wiremock / administration_api</p> <p>WireMock Cloud</p> <p>WireMock Cloud offers secure, publicly hosted mock APIs with nothing to install.</p> <p>WireMock Standalone offers the REST API for administration, troubleshooting and analysis purposes. You can find the key use-cases and the full specification below.</p>"},{"location":"running_wiremock/administration_api/#fetching-all-of-your-stub-mappings-and-checking-wiremock-is-working","title":"Fetching all of your stub mappings (and checking WireMock is working)","text":"<p>A GET request to the mappings admin URL e.g <code>http://localhost:8080/__admin/mappings</code> will return all currently registered stub mappings. This is a useful way to check whether WireMock is running on the host and port you expect.</p>"},{"location":"running_wiremock/administration_api/#shutting-down","title":"Shutting Down","text":"<p>To shutdown the server, post a request with an empty body to <code>http://&lt;host&gt;:&lt;port&gt;/__admin/shutdown</code>.</p>"},{"location":"running_wiremock/administration_api/#full-specification","title":"Full specification","text":"<p>The full specification is available here.</p>"},{"location":"running_wiremock/running_as_a_standalone_process/","title":"Running as a Standalone Process","text":"<p>Documentation / running_wiremock / running_as_a_standalone_process</p> <p>WireMock Cloud</p> <p>WireMock Cloud offers secure, publicly hosted mock APIs with nothing to install.</p> <p>The WireMock server can be run in its own process, and configured via the Java API, JSON over HTTP or JSON files.</p> <p>Once you have downloaded the standalone JAR you can run it simply by doing this:</p> Bash<pre><code>$ java -jar wiremock-standalone-3.13.1.jar\n</code></pre>"},{"location":"running_wiremock/running_as_a_standalone_process/#command-line-options","title":"Command line options","text":"<p>The following can optionally be specified on the command line:</p> <p><code>--admin-api-basic-auth</code> : Require HTTP Basic authentication for admin API calls with the supplied credentials in <code>username:password</code> format</p> <p><code>--admin-api-require-https</code> : Require HTTPS to be used to access the admin API</p> <p><code>--port</code>: Set the HTTP port number e.g. <code>--port 9999</code>. Use <code>--port 0</code> to dynamically determine a port.</p> <p><code>--disable-http</code>: Disable the HTTP listener, option available only if HTTPS is enabled.</p> <p><code>--disable-http2-plain</code>: Disable HTTP/2 over plain text (HTTP).</p> <p><code>--disable-http2-tls</code>: Disable HTTP/2 over TLS (HTTPS).</p> <p><code>--https-port</code>: If specified, enables HTTPS on the supplied port. Note: When you specify this parameter, WireMock will still, additionally, bind to an HTTP port (8080 by default). So when running multiple WireMock servers you will also need to specify the <code>--port</code> parameter in order to avoid conflicts.</p> <p><code>--bind-address</code>: The IP address the WireMock server should serve from. Binds to all local network adapters if unspecified.</p> <p><code>--https-keystore</code>: Path to a keystore file containing an SSL certificate to use with HTTPS. Can be a path to a file or a resource on the classpath. The keystore must have a password of \"password\". This option will only work if <code>--https-port</code> is specified. If this option isn't used WireMock will default to its own self-signed certificate.</p> <p><code>--keystore-type</code>: The HTTPS keystore type. Usually JKS or PKCS12.</p> <p><code>--keystore-password</code>: Password to the keystore, if something other than \"password\". Note: the behaviour of this changed in version 2.27.0. Previously this set Jetty's key manager password, whereas now it sets the keystore password value. The key manager password can be set with the (new) parameter below.</p> <p><code>--key-manager-password</code>: The password used by Jetty to access individual keys in the store, if something other than \"password\".</p> <p><code>--https-truststore</code>: Path to a keystore file containing client public certificates, proxy target public certificates &amp; private keys to use when authenticate with a proxy target that require client authentication. Can be a path to a file or a resource on the classpath. See HTTPS configuration and Running as a browser proxy for details.</p> <p><code>--truststore-type</code>: The HTTPS trust store type. Usually JKS or PKCS12.</p> <p><code>--truststore-password</code>: Optional password to the trust store. Defaults to \"password\" if not specified.</p> <p><code>--https-require-client-cert</code>: Force clients to authenticate with a client certificate. See HTTPS for details.</p> <p><code>--verbose</code>: Turn on verbose logging to stdout</p> <p><code>--root-dir</code>: Sets the root directory, under which <code>mappings</code> and <code>__files</code> reside. This defaults to the current directory.</p> <p><code>--record-mappings</code>: Record incoming requests as stub mappings. See Record and Playback.</p> <p><code>--match-headers</code>: When in record mode, capture request headers with the keys specified. See Record and Playback.</p> <p><code>--proxy-all</code>: Proxy all requests through to another base URL e.g. <code>--proxy-all=\"http://api.someservice.com\"</code> Typically used in conjunction with <code>--record-mappings</code> such that a session on another service can be recorded.</p> <p><code>--preserve-host-header</code>: When in proxy mode, it passes the Host header as it comes from the client through to the proxied service. When this option is not present, the Host header value is deducted from the proxy URL. This option is only available if the <code>--proxy-all</code> option is specified.</p> <p><code>--preserve-user-agent-proxy-header</code>: As of WireMock <code>3.7.0</code>, when in proxy mode, this option will transfer the  original <code>User-Agent</code> header from the client to the proxied service.</p> <p><code>--proxy-via</code>: When proxying requests (either by using --proxy-all or by creating stub mappings that proxy to other hosts), route via another proxy server (useful when inside a corporate network that only permits internet access via an opaque proxy). e.g. <code>--proxy-via webproxy.mycorp.com</code> (defaults to port 80) or <code>--proxy-via webproxy.mycorp.com:8080</code>. Also supports proxy authentication, e.g. <code>--proxy-via http://username:password@webproxy.mycorp.com:8080/</code>.</p> <p><code>--supported-proxy-encodings</code>: The set of acceptable compression methods represented in the <code>accept-encoding</code> request header  sent by WireMock when proxying or recording expressed as a comma-separated list e.g <code>gzip,deflate</code>. This is particularly useful if you want to avoid recording e.g. brotli compresssed responses that can't then be viewed in the request log or served with a different compression scheme on playback, which can be achieved via <code>--supported-proxy-encodings=identity</code>.</p> <p><code>--enable-browser-proxying</code>: Run as a browser proxy. See Running as a browser proxy.</p> <p><code>--ca-keystore</code>: A key store containing a root Certificate Authority private key and certificate that can be used to sign generated certificates when browser proxying https. Defaults to <code>$HOME/.wiremock/ca-keystore.jks</code>.</p> <p><code>--ca-keystore-password</code>: Password to the ca-keystore, if something other than \"password\".</p> <p><code>--ca-keystore-type</code>: Type of the ca-keystore, if something other than <code>jks</code>.</p> <p><code>--trust-all-proxy-targets</code>: Trust all remote certificates when running as a browser proxy and proxying HTTPS traffic.</p> <p><code>--trust-proxy-target</code>: Trust a specific remote endpoint's certificate when running as a browser proxy and proxying HTTPS traffic. Can be specified multiple times. e.g. <code>--trust-proxy-target dev.mycorp.com --trust-proxy-target localhost</code> would allow proxying to <code>https://dev.mycorp.com</code> or <code>https://localhost:8443</code> despite their having invalid certificate chains in some way.</p> <p><code>--no-request-journal</code>: Disable the request journal, which records incoming requests for later verification. This allows WireMock to be run (and serve stubs) for long periods (without resetting) without exhausting the heap. The <code>--record-mappings</code> option isn't available if this one is specified.</p> <p><code>--container-threads</code>: The number of threads created for incoming requests. Defaults to 10.</p> <p><code>--max-request-journal-entries</code>: Set maximum number of entries in request journal (if enabled). When this limit is reached oldest entries will be discarded.</p> <p><code>--max-http-client-connections</code>: Maximum connections for Http Client. Defaults to 1000.</p> <p><code>--jetty-acceptor-threads</code>: The number of threads Jetty uses for accepting requests.</p> <p><code>--jetty-accept-queue-size</code>: The Jetty queue size for accepted requests.</p> <p><code>--jetty-header-buffer-size</code>: Deprecated, use <code>--jetty-header-request-size</code>. The Jetty buffer size for request headers, e.g. <code>--jetty-header-buffer-size 16384</code>, defaults to 8192K.</p> <p><code>--jetty-header-request-size</code>: The Jetty buffer size for request headers, e.g. <code>--jetty-header-request-size 16384</code>, defaults to 8192K.</p> <p><code>--jetty-header-response-size</code>: The Jetty buffer size for response headers, e.g. <code>--jetty-header-response-size 16384</code>, defaults to 8192K.</p> <p><code>--jetty-idle-timeout</code> : Idle timeout in milliseconds for Jetty connections</p> <p><code>--jetty-stop-timeout</code> : Timeout in milliseconds for Jetty to stop</p> <p><code>--async-response-enabled</code>: Enable asynchronous request processing in Jetty. Recommended when using WireMock for performance testing with delays, as it allows much more efficient use of container threads and therefore higher throughput. Defaults to <code>false</code>.</p> <p><code>--async-response-threads</code>: Set the number of asynchronous (background) response threads. Effective only with <code>asynchronousResponseEnabled=true</code>. Defaults to 10.</p> <p><code>--extensions</code>: Extension class names e.g. com.mycorp.HeaderTransformer,com.mycorp.BodyTransformer. See Extending WireMock.</p> <p><code>--print-all-network-traffic</code>: Print all raw incoming and outgoing network traffic to console.</p> <p><code>--global-response-templating</code>: Render all response definitions using Handlebars templates.</p> <p><code>--local-response-templating</code>: Enable rendering of response definitions using Handlebars templates for specific stub mappings.</p> <p><code>--max-template-cache-entries</code>: Set the maximum number of compiled template fragments to cache. Only has any effect when response templating is enabled. As of WireMock <code>3.7.0</code>, this defaults to 1000 cache entries.  Before WireMock <code>3.7.0</code> the default was unlimited.</p> <p><code>--use-chunked-encoding</code>: Set the policy for sending responses with <code>Transfer-Encoding: chunked</code>. Valid values are <code>always</code>, <code>never</code> and <code>body_file</code>. The last of these will cause chunked encoding to be used only when a stub defines its response body from a file.</p> <p><code>--disable-gzip</code>: Prevent response bodies from being gzipped.</p> <p><code>--disable-request-logging</code>: Prevent requests and responses from being sent to the notifier. Use this when performance testing as it will save memory and CPU even when info/verbose logging is not enabled.</p> <p><code>--disable-banner</code>: Prevent WireMock logo from being printed on startup</p> <p><code>--disable-connection-reuse</code>: Disable http connection reuse. Defaults to <code>true</code></p> <p><code>--disable-extensions-scanning</code> : Prevent extensions from being scanned and loaded from the classpath</p> <p><code>--disable-optimize-xml-factories-loading</code> : Whether to disable optimize XML loading factories loading or not.</p> <p><code>--disable-response-templating</code> : Disable processing of responses with Handlebars templates</p> <p><code>--disable-strict-http-headers</code> : Whether to disable strict HTTP header handling of Jetty or not.</p> <p><code>--permitted-system-keys</code>: Comma-separated list of regular expressions for names of permitted environment variables and system properties accessible from response templates. Only has any effect when templating is enabled. Defaults to <code>wiremock.*</code>.</p> <p><code>--enable-stub-cors</code>: Enable automatic sending of cross-origin (CORS) response headers. Defaults to off.</p> <p><code>--logged-response-body-size-limit</code>: Set a limit in bytes beyond which response bodies in the log will be truncated. When enabled this helps avoid out of memory errors when serving large response bodies.</p> <p><code>--allow-proxy-targets</code>: Limit the permitted targets for proxying to and recording from the supplied addressess. This parameter takes a comma-separated list of single IP addresses, IP address ranges and hostname wildcards. See this article for details.</p> <p><code>--deny-proxy-targets</code>: Prevent proxying to and recording from the supplied addressess. This parameter takes a comma-separated list of single IP addresses, IP address ranges and hostname wildcards. Note: if both <code>--allow-proxy-targets</code> and this parameter are set, the allow list will be evaluated first. See this article for details.</p> <p><code>--proxy-timeout</code>: Set the timeout for requests to the proxy in milliseconds</p> <p><code>--proxy-pass-through</code>: Flag used in browser-caching in order to enable or disable pass through unmatched requests to the target indicated by the original requests. By default, this flag is enabled and let the requests pass through.</p> <p><code>--filename-template</code>: Set filename template in handlebar format. For endpoint: <code>GET /pets/{id}</code> using the format: <code>{{{method}}}-{{{url}}}.json</code> output will be <code>get-pets-id.json</code>. Default format: <code>{{{method}}}-{{{path}}}-{{{id}}}.json</code> hence by default template filename will be: <code>get-pets-id-1.json</code>.  Note: introduced in 3.0.0-beta-8.</p> <p><code>--timeout</code> : The default global timeout</p> <p><code>--version</code> : Prints wiremock version information and exits</p> <p><code>--webhook-threadpool-size</code>: The number of threads created for processing webhook requests.  This option is available as of WireMock version <code>3.13.0</code>. Defaults to 10</p> <p><code>--help</code>: Show command line help</p>"},{"location":"running_wiremock/running_as_a_standalone_process/#configuring-wiremock-using-the-java-client","title":"Configuring WireMock using the Java client","text":"<p>The WireMock Java API can be used against a running server on a different host if required. If you're only planning to configure a single remote instance from within your program you can configure the static DSL to point to it:</p> Java<pre><code>WireMock.configureFor(\"my.remote.host\", 8000);\n\n// or for HTTPS\nWireMock.configureFor(\"https\", \"my.remote.host\", 8443);\n</code></pre> <p>Alternatively you can create an instance of the client (or as many as there are servers to configure):</p> Java<pre><code>WireMock wireMock1 = new WireMock(\"1st.remote.host\", 8000);\nWireMock wireMock2 = new WireMock(\"https\", \"2nd.remote.host\", 8001);\n</code></pre>"},{"location":"running_wiremock/running_as_a_standalone_process/#configuring-via-json-over-http","title":"Configuring via JSON over HTTP","text":"<p>You can create a stub mapping by posting to WireMock's HTTP API:</p> Bash<pre><code>$ curl -X POST \\\n--data '{ \"request\": { \"url\": \"/get/this\", \"method\": \"GET\" }, \"response\": { \"status\": 200, \"body\": \"Here it is!\\n\" }}' \\\nhttp://localhost:8080/__admin/mappings\n</code></pre> <p>And then fetch it back:</p> Bash<pre><code>$ curl http://localhost:8080/get/this\nHere it is!\n</code></pre> <p>The full stubbing API syntax is described in Stubbing.</p>"},{"location":"running_wiremock/running_as_a_standalone_process/#json-file-configuration","title":"JSON file configuration","text":"<p>You can also use the JSON API via files. When the WireMock server starts it creates two directories under the current one: <code>mappings</code> and <code>__files</code>.</p> <p>To create a stub like the one above by this method, drop a file with a <code>.json</code> extension under <code>mappings</code> with the following content:</p> JSON<pre><code>{\n    \"request\": {\n        \"method\": \"GET\",\n        \"url\": \"/api/mytest\"\n    },\n    \"response\": {\n        \"status\": 200,\n        \"body\": \"More content\\n\"\n    }\n}\n</code></pre> <p>After restarting the server you should be able to do this:</p> Bash<pre><code>$ curl http://localhost:8080/api/mytest\nMore content\n</code></pre> <p>See stubbing and verifying for more on the JSON API.</p>"},{"location":"running_wiremock/running_as_a_standalone_process/#multi-stub-json-files","title":"Multi-stub JSON files","text":"<p>JSON files containing multiple stub mappings can also be used. These are of the form:</p> JSON<pre><code>{\n    \"mappings\": [\n        {\n            \"request\": {\n                \"method\": \"GET\",\n                \"url\": \"/one\"\n            },\n            \"response\": {\n                \"status\": 200\n            }\n        },\n        {\n            \"id\": \"8c5db8b0-2db4-4ad7-a99f-38c9b00da3f7\",\n            \"request\": {\n                \"url\": \"/two\"\n            },\n            \"response\": {\n                \"body\": \"Updated\"\n            }\n        }\n    ]\n}\n</code></pre> <p>note</p> <p>Stubs loaded from multi-mapping files are read-only, so any attempt to update or remove (including remove all) will cause an error to be thrown.</p>"},{"location":"running_wiremock/running_as_a_standalone_process/#pushing-json-files-to-a-remote-wiremock-instance","title":"Pushing JSON files to a remote WireMock instance","text":"<p>You can push a collection of stub mappings and associated files to a remote WireMock or WireMock Cloud instance via the Java API as follows:</p> Java<pre><code>WireMock wireMock = WireMock.create()\n    .scheme(\"http\")\n    .host(\"my-wiremock.example.com\")\n    .port(80)\n    .build();\n\n// The root directory of the WireMock project, under which the mappings and __files directories should be found\nwireMock.loadMappingsFrom(\"/wiremock-stuff\");\n</code></pre>"},{"location":"running_wiremock/running_as_a_standalone_process/#file-serving","title":"File serving","text":"<p>When running the standalone JAR, files placed under the <code>__files</code> directory will be served up as if from under the docroot, except if stub mapping matching the URL exists. For example if a file exists <code>__files/things/myfile.html</code> and no stub mapping will match <code>/things/myfile.html</code> then hitting <code>http://&lt;host&gt;:&lt;port&gt;/things/myfile.html</code> will serve the file.</p>"},{"location":"running_wiremock/running_as_a_standalone_process/#packaging-the-stubs-into-a-standalone-jar","title":"Packaging the stubs into a standalone JAR","text":"<p>If you want to package your stubs into the standalone JAR, so you can distribute an executable JAR with all the stubs intact, you can do this using the <code>--load-resources-from-classpath</code> option.</p> <p>For example, let's say have the following directory structure:</p> Text Only<pre><code>src/main/resources\nsrc/main/resources/wiremock-stuff\nsrc/main/resources/wiremock-stuff/__files\nsrc/main/resources/wiremock-stuff/mappings\n</code></pre> <p>You could then run the packaged JAR as:</p> Text Only<pre><code>java -jar custom-wiremock.jar --load-resources-from-classpath wiremock-stuff\n</code></pre> <p>Which will load your files and mappings from the packaged JAR.</p> <p>Note that it is not currently possible to load from the root of the classpath.</p>"},{"location":"running_wiremock/running_as_a_standalone_process/#securing-the-wiremock-admin-api","title":"Securing The WireMock Admin API","text":"<p>You can start WireMock with the <code>--admin-api-basic-auth</code> command line option specifying your username and password in the standard <code>username:password</code> format:</p> Text Only<pre><code>java -jar wiremock-standalone.jar --admin-api-basic-auth my-username:my-super-secret-password\n</code></pre> <p>Any call made to the admin API after that will need the correct <code>Authorization</code> header included or a <code>401</code> will be  returned. The correct call will have the <code>Authorization</code> header with the word <code>Basic</code> followed by the Base64  representation of your <code>username:password</code> pair:</p> Text Only<pre><code>curl -X GET --location \"http://localhost:8080/__admin/requests\" \\\n    -H \"Authorization: Basic bXktdXNlcm5hbWU6bXktc3VwZXItc2VjcmV0LXBhc3N3b3Jk\"\n</code></pre>"},{"location":"running_wiremock/running_as_a_standalone_process/#shutting-down","title":"Shutting Down","text":"<p>To shutdown the server, either call <code>WireMock.shutdownServer()</code> or post a request with an empty body to <code>http://&lt;host&gt;:&lt;port&gt;/__admin/shutdown</code>.</p>"},{"location":"running_wiremock/running_in_docker/","title":"Running in Docker","text":"<p>Documentation / running_wiremock / running_in_docker</p> <p>WireMock Cloud</p> <p>WireMock Cloud offers secure, publicly hosted mock APIs with nothing to install.</p> <p>From version 2.31.0 WireMock has an official Docker image.</p>"},{"location":"running_wiremock/running_in_docker/#getting-started","title":"Getting started","text":""},{"location":"running_wiremock/running_in_docker/#start-a-single-wirewock-container-with-default-configuration","title":"Start a single WireWock container with default configuration","text":"Bash<pre><code>docker run -it --rm \\\n  -p 8080:8080 \\\n  --name wiremock \\\n  wiremock/wiremock:3.13.1\n</code></pre> <p>Access http://localhost:8080/__admin/mappings to display the mappings (empty set)</p>"},{"location":"running_wiremock/running_in_docker/#start-with-command-line-arguments","title":"Start with command line arguments","text":"<p>The Docker image supports exactly the same set of command line arguments as the standalone version. These can be passed to the container by appending them to the end of the command e.g.:</p> Bash<pre><code>docker run -it --rm \\\n  -p 8443:8443 \\\n  --name wiremock \\\n  wiremock/wiremock:3.13.1 \\\n  --https-port 8443 --verbose\n</code></pre>"},{"location":"running_wiremock/running_in_docker/#passing-command-line-arguments-as-environment-variable","title":"Passing command line arguments as environment variable","text":"<p>Starting from <code>3.2.0-2</code>, the Docker image supports passing command line arguments standalone version as the environment variable. Environment variable <code>WIREMOCK_OPTIONS</code> can be passed to container consisting of all command line arguments e.g.:</p> Bash<pre><code>docker run -it --rm \\\n  -e WIREMOCK_OPTIONS='--https-port 8443 --verbose' \\\n  -p 8443:8443 \\\n  --name wiremock \\\n  wiremock/wiremock:3.13.1\n</code></pre>"},{"location":"running_wiremock/running_in_docker/#mounting-stub-mapping-files","title":"Mounting stub mapping files","text":"<p>Inside the container, the WireMock uses <code>/home/wiremock</code> as the root from which it reads the <code>mappings</code> and <code>__files</code> directories. This means you can mount a directory containing these from your host machine into Docker and WireMock will load the stub mappings.</p> <p>To mount the current directory use <code>-v $PWD:/home/wiremock</code> e.g.:</p> Bash<pre><code>docker run -it --rm \\\n  -p 8080:8080 \\\n  --name wiremock \\\n  -v $PWD:/home/wiremock \\\n  wiremock/wiremock:3.13.1\n</code></pre>"},{"location":"running_wiremock/running_in_docker/#running-with-extensions","title":"Running with extensions","text":"<p>WireMock extensions are packaged as JAR files. In order to use them they need to be made available at runtime and WireMock must be configured to enable them.</p> <p>For example, to use the Webhooks extension we would first download wiremock-webhooks-extension-3.13.1.jar into the <code>extensions</code> directory under our working directory.</p> <p>Then when starting Docker we would mount the extensions directory to <code>/var/wiremock/extensions</code> and enable the webhooks extension via a CLI parameter:</p> Bash<pre><code>docker run -it --rm \\\n  -p 8080:8080 \\\n  --name wiremock \\\n  -v $PWD/extensions:/var/wiremock/extensions \\\n  wiremock/wiremock \\\n    --extensions org.wiremock.webhooks.Webhooks\n</code></pre>"},{"location":"running_wiremock/running_in_docker/#building-your-own-image","title":"Building your own image","text":"<p>Inside the container, the WireMock uses <code>/home/wiremock</code> as the root from which it reads the <code>mappings</code> and <code>__files</code> directories. This means you can copy your configuration from your host machine into Docker and WireMock will load the stub mappings.</p> <p>Wiremock utilizes a custom entrypoint script that passes all provided arguments as WireMock startup parameters. To modify the WireMock launch parameters it is recommended to override the entrypoint in your custom Docker image. </p> Docker<pre><code># Sample Dockerfile\nFROM wiremock/wiremock:latest\nCOPY wiremock /home/wiremock\nENTRYPOINT [\"/docker-entrypoint.sh\", \"--global-response-templating\", \"--disable-gzip\", \"--verbose\"]\n</code></pre>"},{"location":"running_wiremock/running_in_docker/#docker-compose","title":"Docker Compose","text":"<p>Configuration in compose file is similar to Dockerfile definition</p> YAML<pre><code># Sample compose file\nversion: \"3\"\nservices:\n  wiremock:\n    image: \"wiremock/wiremock:latest\"\n    container_name: my_wiremock\n    entrypoint: [\"/docker-entrypoint.sh\", \"--global-response-templating\", \"--disable-gzip\", \"--verbose\"]\n</code></pre> <p>You can also mount your local <code>__files</code> and <code>mappings</code> files into the container e.g:</p> YAML<pre><code># Sample compose file\nversion: \"3\"\nservices:\n  wiremock:\n    image: \"wiremock/wiremock:latest\"\n    container_name: my_wiremock\n    volumes:\n      - ./extensions:/var/wiremock/extensions\n      - ./__files:/home/wiremock/__files\n      - ./mappings:/home/wiremock/mappings\n    entrypoint: [\"/docker-entrypoint.sh\", \"--global-response-templating\", \"--disable-gzip\", \"--verbose\"]\n</code></pre>"},{"location":"running_wiremock/wiremock_standalone_service/","title":"WireMock Standalone Service","text":"<p>Documentation / running_wiremock / wiremock_standalone_service</p> <p>WireMock Cloud</p> <p>WireMock Cloud offers secure, publicly hosted mock APIs with nothing to install.</p> <p>WireMock can run as a standalone service, configured via the Java API, JSON over HTTP or JSON files. We provide the JAR file and Docker image distributions for it.</p>"},{"location":"running_wiremock/wiremock_standalone_service/#running-wiremock","title":"Running WireMock","text":"<ul> <li>Running as a Docker Image</li> <li>Running as a JAR file</li> </ul>"},{"location":"running_wiremock/wiremock_standalone_service/#management","title":"Management","text":"<p>When WireMock runs as a standalone service, it can be managed through its REST API.</p> <ul> <li>WireMock Administration</li> <li>Admin API Reference</li> </ul>"},{"location":"running_wiremock/wiremock_standalone_service/#api-clients","title":"API Clients","text":"<p>There is a number of API clients that work with the standalone WireMock instance. Check out the Solution pages for more info and pointers.</p>"},{"location":"solutions/android/","title":"Running on Android","text":"<p>Documentation / solutions / android</p> <p>WireMock Cloud</p> <p>Centralize and scale your API mocks with WireMock Cloud.</p>"},{"location":"solutions/android/#guide-by-sam-edwards","title":"Guide by Sam Edwards","text":"<p>As documented by Sam Edwards in 2016, with some effort it is now possible to run WireMock 2.x on Android. Please see this blog post for instructions. This guide is likely no longer applicable to the recent versions.</p> <p>References:</p> <ul> <li>Android Http Mocking Examples</li> <li>Shopping App Demo application with API mocking in test automation</li> <li>Now it is based on Ktor, but there is WireMock Edition in the commit history</li> </ul>"},{"location":"solutions/android/#useful-pages","title":"Useful pages","text":"<ul> <li>WireMock and Kotlin - Android ecosystem embraces Kotlin as a development language,   and there are some additional tooling available</li> <li>WireMock on Java and JVM - Some of JVM generic solutions are applicable to Android development too</li> </ul>"},{"location":"solutions/c_cpp/","title":"WireMock and C/C++","text":"<p>Documentation / solutions / c_cpp</p> <p>WireMock Cloud</p> <p>Centralize and scale your API mocks with WireMock Cloud.</p>"},{"location":"solutions/c_cpp/#testcontainers-for-cc-module","title":"Testcontainers for C/C++ module","text":"<p>Recently we created an experimental WireMock module for Testcontainers for C/C++. It allows provisioning the WireMock server as a standalone container within your tests, based on WireMock Docker. It allows using WireMock with all popular C/C++ testing frameworks like Google Test, CTest, Doctest, QtTest or CppUnit.</p> <p>The module is distributed as a shared library and a header, and hence can be potentially included into other programming languages that support including native C libraries, for example Lua, D, Swift, etc. None of that has been tested yet, so we will appreciate your contributions!</p>"},{"location":"solutions/c_cpp/#examples","title":"Examples","text":"<p>Initializing WireMock:</p> C<pre><code>#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n#include \"testcontainers-c-wiremock.h\"\n\nint main() {\n    printf(\"Creating new container: %s\\n\", DEFAULT_WIREMOCK_IMAGE);\n    int requestId = tc_wm_new_default_container();\n    tc_wm_with_mapping(requestId, \"test_data/hello.json\", \"hello\");\n    tc_with_file(requestId, \"test_data/hello.json\", \"/home/wiremock/mappings/hello2.json\");\n    struct tc_run_container_return ret = tc_run_container(requestId);\n    int containerId = ret.r0;\n    if (!ret.r1) {\n        printf(\"Failed to run the container: %s\\n\", ret.r2);\n        if (containerId != -1) { // Print container log\n            char* log = tc_get_container_log(containerId);\n            if (log != NULL) {\n                printf(\"\\n%s\\n\", log);\n            }\n        }\n        return -1;\n    }\n\n    // ...\n</code></pre> <p>Sending HTTP requests</p> C<pre><code>    //..\n\n    struct WireMock_Mapping mapping = tc_wm_get_mappings(containerId);\n    if (mapping.responseCode != 200) {\n        printf(\"Failed to get WireMock mapping: %s\\n\", mapping.error);\n        return -1;\n    } else {\n        printf(\"WireMock Mapping:\\n%s\\n\", mapping.json);\n    }\n\n    printf(\"Sending HTTP request to the container\\n\");\n    struct tc_send_http_get_return response = tc_send_http_get(containerId, 8080, \"/hello\");\n    if (response.r0 == -1) {\n        printf(\"Failed to send HTTP request: %s\\n\", response.r2);\n        return -1;\n    }\n    if (response.r0 != 200) {\n        printf(\"Received wrong response code: %d instead of %d\\n%s\\n\", response.r0, 200, response.r2);\n        return -1;\n    }\n    printf(\"Server Response: HTTP-%d\\n%s\\n\\n\", response.r0, response.r1);\n    return 0;\n}\n</code></pre>"},{"location":"solutions/dotnet/","title":"WireMock and .NET","text":"<p>Documentation / solutions / dotnet</p> <p>WireMock Cloud</p> <p>Centralize and scale your API mocks with WireMock Cloud.</p>"},{"location":"solutions/dotnet/#wiremocknet","title":"WireMock.Net","text":"<p>A .NET implementation of a API mock server in C# based on mock4net It mimics the functionality from WireMock implemented in Java. WireMock.NET can be used with all .NET based languages, both .NET Framework and .NET Core are supported. It can also be deployed as a standalone server, including Windows service and a container.</p> <p>Compatibility Notice. WireMock.Net is not fully compatible with WireMock in terms of the configuration file formats and Administrative REST API.</p> <p>References:</p> <ul> <li>Main repository</li> <li>WireMock.Net Docker images for Linux and Windows</li> <li>WireMock.Net Examples</li> </ul>"},{"location":"solutions/dotnet/#wiremockinspector","title":"WireMockInspector","text":"<p>WireMockInspector is a cross platform UI app that facilitates WireMock troubleshooting. It presents a list of requests received by the WireMock.Net server, combines request data with associated mapping, presents a list of all available mappings with the definition, generate C# code for defining selected mappings.</p> <p>Compatibility Notice. The tool is designed for WireMock.Net and not fully compatible with WireMock</p> <p>WireMockInspector is distributed as <code>dotnet tool</code> so it can be easily install on Windows/MacOS/Linux.</p> <p>References:</p> <ul> <li>GitHub Repository</li> </ul>"},{"location":"solutions/dotnet/#wiremock-ui","title":"Wiremock UI","text":"<p>Tool for creating mock servers, proxies servers and proxies servers with the option to save the data traffic from an existing API or Site. It is a wrapper over WireMock.</p> <p>Compatibility Notice. The tool is designed for WireMock and not fully compatible with WireMock.Net</p> <p>References:</p> <ul> <li>GitHub repository</li> </ul>"},{"location":"solutions/golang/","title":"WireMock and Go","text":"<p>Documentation / solutions / golang</p> <p>WireMock Cloud</p> <p>Centralize and scale your API mocks with WireMock Cloud.</p>"},{"location":"solutions/golang/#testcontainers-module-for-go","title":"Testcontainers module for Go","text":"<p>The WireMock community provides a Testcontainers for Go module module which allows using WireMock single-shot containers within Golang tests. This module can run any WireMock Docker compatible images, see the documentation for detailed usage guidelines and examples.</p> <p>Example:</p> Go<pre><code>import (\n  \"context\"\n  . \"github.com/wiremock/wiremock-testcontainers-go\"\n  \"testing\"\n)\n\nfunc TestWireMock(t *testing.T) {\n    // Create Container\n    ctx := context.Background()\n    container, err := RunContainerAndStopOnCleanup(ctx,\n        WithMappingFile(\"hello\", \"hello-world.json\"),\n    )\n    if err != nil {\n        t.Fatal(err)\n    }\n\n    // Send the HTTP GET request to the mocked API\n    statusCode, out, err := SendHttpGet(container, \"/hello\", nil)\n    if err != nil {\n        t.Fatal(err, \"Failed to get a response\")\n    }\n    // Verify the response\n    if statusCode != 200 {\n        t.Fatalf(\"expected HTTP-200 but got %d\", statusCode)\n    }\n    if string(out) != \"Hello, world!\" {\n        t.Fatalf(\"expected 'Hello, world!' but got %v\", string(out))\n    }\n}\n</code></pre> <p>References:</p> <ul> <li>GitHub Repository</li> <li>Testcontainers for Go</li> </ul>"},{"location":"solutions/golang/#go-wiremock-wiremock-rest-api-client","title":"Go WireMock - WireMock REST API client","text":"<p>The Golang client library to stub API resources in WireMock using its Administrative REST API. The project connects to the instance and allows setting up stubs and response templating, or using administrative API to extract observability data.</p> <p>References:</p> <ul> <li>Documentation</li> <li>GitHub Repository</li> </ul> <p>Example:</p> Go<pre><code>func TestSome(t *testing.T) {\n    wiremockClient := wiremock.NewClient(\"http://0.0.0.0:8080\")\n    defer wiremockClient.Reset()\n\n    wiremockClient.StubFor(wiremock.Post(wiremock.URLPathEqualTo(\"/user\")).\n    WithQueryParam(\"name\", wiremock.EqualTo(\"John Doe\")).\n    WillReturnResponse(\n        wiremock.NewResponse().\n            WithJSONBody(map[string]interface{}{\n                \"code\":   400,\n                \"detail\": \"detail\",\n            }).\n            WithHeader(\"Content-Type\", \"application/json\").\n            WithStatus(http.StatusBadRequest),\n    ))\n}\n</code></pre>"},{"location":"solutions/golang/#useful-pages","title":"Useful pages","text":"<ul> <li>WireMock and Docker</li> <li>WireMock and Kubernetes</li> </ul>"},{"location":"solutions/graphql/","title":"WireMock and GraphQL","text":"<p>Documentation / solutions / graphql</p> <p>WireMock Cloud</p> <p>Mock your GraphQL endpoints in WireMock Cloud with instant mock data and federated supergraph</p>"},{"location":"solutions/graphql/#wiremock-extension","title":"WireMock Extension","text":"<p>There is a GraphQL extension for WireMock that allows semantically matching GraphQL queries, regardless of the order of the fields in the original request. It brings powers of request matching and response templating to the GraphQL query language.</p> <p>Example:</p> Kotlin<pre><code>import com.github.tomakehurst.wiremock.client.WireMock\nimport com.github.tomakehurst.wiremock.client.WireMock.*\nimport io.github.nilwurtz.GraphqlBodyMatcher\n\nfun registerGraphQLWiremock(json: String) {\n    WireMock(8080).register(\n        post(urlPathEqualTo(endPoint))\n            .andMatching(GraphqlBodyMatcher.extensionName, GraphqlBodyMatcher.withRequest(json))\n            .willReturn(\n                aResponse()\n                    .withStatus(200)\n            )\n    )\n}\n</code></pre>"},{"location":"solutions/graphql/#read-more","title":"Read More","text":"<ul> <li>GraphQL API mocking with the new WireMock extension   blogpost by Eiki Hayashi</li> <li>GitHub repository with documentation</li> </ul>"},{"location":"solutions/groovy/","title":"WireMock and Groovy","text":"<p>Documentation / solutions / groovy</p> <p>WireMock Cloud</p> <p>Centralize and scale your API mocks with WireMock Cloud.</p>"},{"location":"solutions/groovy/#dsl-bindings","title":"DSL Bindings","text":"<p>There is a Groovy DSL binding library  that allows to manage the WireMock JUnit rule via declarative Spock-alike definitions. Note that this library is maintained outside the WireMock organization on GitHub, and likely to be obsolete.</p> Groovy<pre><code>@Rule\nWireMockRule wireMockRule = new WireMockRule()\n\ndef wireMockStub = new WireMockGroovy()\n\ndef \"example verifying test\" () {\n    ...\n    then:\n    1 == wireMockStub.count {\n        method \"GET\"\n        url \"/some/url\"\n    }\n}\n\ndef \"test using groovy truth if you need at least one request and shows example matcher\" () {\n    ...\n    then:\n    wireMockStub.count {\n        method \"POST\"\n        url \"/some/url\"\n        headers {\n            \"Content-Type\" {\n                matches \".*xml\"\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"solutions/groovy/#useful-pages","title":"Useful pages","text":"<ul> <li>WireMock on Java and JVM - Most of JVM generic solutions are applicable to Groovy development too</li> </ul>"},{"location":"solutions/jvm/","title":"WireMock for Java and JVM languages","text":"<p>Documentation / solutions / jvm</p> <p>WireMock Cloud</p> <p>Centralize and scale your API mocks with WireMock Cloud.</p> <p>WireMock was originally created for Java development, and there are plenty of solutions when developing applications powered by the Java Virtual Machine.</p>"},{"location":"solutions/jvm/#wiremock","title":"WireMock","text":"<p>WireMock, also known as WireMock Java is the flagman implementation of WireMock functionality and specifications, maintained on the WireMock GitHub organization. It is included into many distributions (including WireMock Docker), test framework adapters and products. Most of the documentation on this website is about WireMock Java, unless specified explicitly.</p> <p>Usage:</p> <ul> <li>Running WireMock as a Standalone server</li> <li>Using WireMock in plain Java without frameworks</li> </ul> <p>References:</p> <ul> <li>WireMock Java on GitHub</li> </ul>"},{"location":"solutions/jvm/#integrations-with-test-frameworks","title":"Integrations with test frameworks","text":"<p>WireMock has integrations with many popular Java test frameworks for unit and integration testing.</p> <ul> <li>JUnit 5+ and Jupiter</li> <li>JUnit 4 and Vintage</li> <li>Testcontainers Java</li> <li>Spock - maintained outside WireMock's organization on GitHub</li> </ul>"},{"location":"solutions/jvm/#wiremock-extensions","title":"WireMock Extensions","text":"<p>WireMock Java is extensible, and there is a number of available extensions that can be included into WireMock to extend its functionality, including but not limited to request filters, observability, storage, etc.</p> <p>A few popular extensions:</p> <ul> <li>Response Template Transformer</li> <li>Documentation</li> <li>This extension is a built-in part of the WireMock Java, but needs to be enabled explicitly</li> <li>Webhooks</li> <li>Documentation</li> <li>JSON Body Transformer, Callback Simulator, Request time matcher</li> <li>9cookies/wiremock-extensions Active</li> <li>CORS Protection Extension</li> <li>RichieLoco/WiremockCorsExtension</li> </ul>"},{"location":"solutions/jvm/#solutions-specific-to-jvm-technologies","title":"Solutions specific to JVM technologies","text":"<p>Here are references to particular JVM technologies and languages, sorted by alphabet:</p> <ul> <li>Android</li> <li>Clojure</li> <li>Groovy</li> <li>Kotlin</li> <li>Pact</li> <li>Scala</li> <li>Spring Boot</li> </ul>"},{"location":"solutions/kotlin/","title":"WireMock and Kotlin","text":"<p>Documentation / solutions / kotlin</p> <p>WireMock Cloud</p> <p>Centralize and scale your API mocks with WireMock Cloud.</p>"},{"location":"solutions/kotlin/#kotlin-dsl-bindings","title":"Kotlin DSL Bindings","text":"<p>There is a Kotlin WireMock library that provides handy Kotlin DSL bindings for WireMock. Note that this library is maintained outside the WireMock organization on GitHub.</p> <p>Example:</p> Kotlin<pre><code>wiremock.get {\n    url equalTo \"/users/1\"\n} returns {\n    statusCode = 200\n    header = \"Content-Type\" to \"application/json\"\n    body = \"\"\"\n    {\n      \"id\": 1,\n      \"name\": \"Bob\"\n    }\n    \"\"\"\n}\n</code></pre>"},{"location":"solutions/kotlin/#kotest-extension","title":"Kotest Extension","text":"<p>Kotest is a popular Kotlin test framework that provides assertions library, property testing and more. There is a Kotest extension for WireMock that integrates WireMock into the framework. Note that this library is maintained by the Kotest community.</p> <p>Example:</p> Kotlin<pre><code>class SomeTest : FunSpec({\n  val customerServiceServer = WireMockServer(9000)\n  listener(WireMockListener(customerServiceServer, ListenerMode.PER_SPEC))\n\n  test(\"let me get customer information\") {\n    customerServiceServer.stubFor(\n      WireMock.get(WireMock.urlEqualTo(\"/customers/123\"))\n        .willReturn(WireMock.ok())\n    )\n\n    val connection = URL(\"http://localhost:9000/customers/123\").openConnection() as HttpURLConnection\n    connection.responseCode shouldBe 200\n  }\n\n    //  ------------OTHER TEST BELOW ----------------\n})\n</code></pre> <p>References:</p> <ul> <li>Documentation</li> <li>GitHub repo: kotest/kotest-extensions-wiremock</li> </ul>"},{"location":"solutions/kubernetes/","title":"WireMock and Kubernetes","text":"<p>Documentation / solutions / kubernetes</p> <p>WireMock Cloud</p> <p>Centralize and scale your API mocks with WireMock Cloud.</p>"},{"location":"solutions/kubernetes/#wiremock-helm-chart-experimental","title":"WireMock Helm Chart (Experimental)","text":"<p>There is an experimental Helm Chart for WireMock. It allows deploying the official WireMock Docker images and also other charts that extend it.</p> <ul> <li>GitHub Repository</li> <li>Helm Repository</li> </ul>"},{"location":"solutions/kubernetes/#grpc-proxy","title":"gRPC Proxy","text":"<p>grpc-wiremock is a proxy wrapper around the WireMock Standalone server that offers support for the gRPC protocol. It is implemented in Java and runs as a standalone proxy that can be deployed in the same or another container. The project is under active development, and the contributions are welcome!</p> <p>DISCLAIMER: This repository was forked from Adven27/grpc-wiremock which was archived by the maintainer. This fork is used to preserve the repository, and to make it available for experimental use and contributions. See wiremock/wiremock #2148 for the feature request about providing an officially supported implementation</p> <p></p> <p>References:</p> <ul> <li>GitHub Repository</li> </ul>"},{"location":"solutions/kubernetes/#useful-pages","title":"Useful pages","text":"<ul> <li>WireMock and Golang - There's WireMock for Golang developers too!</li> </ul>"},{"location":"solutions/nodejs/","title":"WireMock and Node.js","text":"<p>Documentation / solutions / nodejs</p> <p>WireMock Cloud</p> <p>Centralize and scale your API mocks with WireMock Cloud.</p>"},{"location":"solutions/nodejs/#wiremock-captain","title":"WireMock Captain","text":"<p>WireMock Captain provides an easy interface for testing HTTP-based APIs. Tests are implemented in TypeScript or JavaScript with the Node.js runtime. Mocking is performed by WireMock, which typically runs in a Docker container. Note that this library is maintained outside the WireMock organization on GitHub.</p> <ul> <li>GitHub Repository</li> </ul> <p>Example:</p> JavaScript<pre><code>import { WireMock } from 'wiremock-captain';\n\ndescribe('Integration with WireMock', () =&gt; {\n  // Connect to WireMock\n  const wiremockEndpoint = 'http://localhost:8080';\n  const mock = new WireMock(wiremockEndpoint);\n\n  test('mocks downstream service', async () =&gt; {\n    const request: IWireMockRequest = {\n      method: 'POST',\n      endpoint: '/test-endpoint',\n      body: {\n        hello: 'world',\n      },\n    };\n    const mockedResponse: IWireMockResponse = {\n      status: 200,\n      body: { goodbye: 'world' },\n    };\n    await mock.register(request, mockedResponse);\n\n    // rest of the test\n  });\n});\n</code></pre>"},{"location":"solutions/nodejs/#wiremock-rest-client","title":"WireMock REST Client","text":"<p>The WireMock REST client is a lightweight module to interact with a running WireMock server based on its OpenAPI 3.0 spec via REST API. Note that this library is maintained outside the WireMock organization on GitHub.</p> <ul> <li>GitHUb Repository</li> </ul> JavaScript<pre><code>import { WireMockRestClient } from 'wiremock-rest-client';\n\nconst wireMock = new WireMockRestClient('http://localhost:8080');\nconst stubMappings = await wireMock.mappings.getAllMappings();\nconsole.log(stubMappings);\n\nawait wireMock.global.shutdown();\n</code></pre>"},{"location":"solutions/nodejs/#wiremock-npm-package","title":"WireMock NPM package","text":"<p>The WireMock NPM package is the WireMock standalone JAR packaged inside an NPM package. It has the exact same features as WireMock standalone and uses the same versioning.</p> <p>The main benefit of packaging it inside an NPM package is that the user will only need access to an NPM registry to use it. This is often the situation when working behind firewalls in organizations.</p> <ul> <li>GitHUb Repository</li> </ul>"},{"location":"solutions/pact/","title":"Using WireMock with Pact","text":"<p>Documentation / solutions / pact</p>"},{"location":"solutions/pact/#wiremock-pact","title":"WireMock Pact","text":"<p>WireMock Pact will get the requests from WireMock and create Pact JSON files on the filesystem. The Pact JSON can be published to a Pactflow broker.</p> <p>WireMock Pact contains:</p> <ul> <li><code>wiremock-pact-lib</code> - A library that can transform WireMock ServeEvent:s to Pact JSON.</li> <li><code>wiremock-pact-extension-junit5</code> - A WireMock extension, and JUnit 5, that is intended to ease usage of the library.</li> <li><code>wiremock-pact-example-springboot-app</code> - A SpringBoot application that shows how it can be used.</li> </ul> <p>WireMock Pact is released to Maven Central. And available on GitHub.</p>"},{"location":"solutions/pact/#usage-junit-5","title":"Usage - Junit 5","text":"<p>The extension is both a WireMock extension and a JUnit 5 extension. When using <code>wiremock-spring-boot</code> it can be configured like this in a base class of your tests:</p> Java<pre><code>import com.github.tomakehurst.wiremock.core.WireMockConfiguration;\nimport com.maciejwalkowiak.wiremock.spring.ConfigureWireMock;\nimport com.maciejwalkowiak.wiremock.spring.EnableWireMock;\nimport com.maciejwalkowiak.wiremock.spring.WireMockConfigurationCustomizer;\nimport org.junit.jupiter.api.extension.RegisterExtension;\nimport se.bjurr.wiremockpact.wiremockpactextensionjunit5.WireMockPactExtension;\nimport se.bjurr.wiremockpact.wiremockpactlib.api.WireMockPactConfig;\n\n@EnableWireMock({\n  @ConfigureWireMock(\n      name = \"wiremock-service-name\",\n      property = \"wiremock.server.url\",\n      stubLocation = \"wiremock\",\n      configurationCustomizers = {WireMockPactBaseTest.class})\n})\npublic class WireMockPactBaseTest implements WireMockConfigurationCustomizer {\n  @RegisterExtension\n  static WireMockPactExtension WIREMOCK_PACT_EXTENSION =\n      new WireMockPactExtension(\n          WireMockPactConfig.builder() //\n              .setConsumerDefaultValue(\"WireMockPactExample\") //\n              .setProviderDefaultValue(\"UnknownProvider\") //\n              .setPactJsonFolder(\"src/test/resources/pact-json\"));\n\n  @Override\n  public void customize(\n      final WireMockConfiguration configuration, final ConfigureWireMock options) {\n    configuration.extensions(WIREMOCK_PACT_EXTENSION);\n  }\n}\n</code></pre>"},{"location":"solutions/pact/#usage-library","title":"Usage - Library","text":"<p>It can be used as a library.</p> Java<pre><code>public class ExampleTest {\n  private static WireMockServer server;\n  private static WireMockPactApi wireMockPactApi;\n\n  @BeforeAll\n  public static void beforeEach() throws IOException {\n    server = new WireMockServer();\n    server.start();\n\n    stubFor(\n        post(anyUrl())\n            .willReturn(\n                ok()\n                .withHeader(\"content-type\", \"application/json\")\n                .withBody(\"\"\"\n                {\"a\":\"b\"}\n                \"\"\"))\n            .withMetadata(\n                new Metadata(\n                    Map.of(\n                        WireMockPactMetadata.METADATA_ATTR,\n                        new WireMockPactMetadata()\n                            .setProvider(\"some-specific-provider\")))));\n\n    wireMockPactApi =\n        WireMockPactApi.create(\n            new WireMockPactConfig()\n                .setConsumerDefaultValue(\"my-service\")\n                .setProviderDefaultValue(\"unknown-service\")\n                .setPactJsonFolder(\"the/pact-json/folder\"));\n    wireMockPactApi.clearAllSaved();\n  }\n\n  @Test\n  public void testInvoke() {\n    // Do stuff that invokes WireMock...\n  }\n\n  @AfterAll\n  public static void after() {\n    for (final ServeEvent serveEvent : server.getAllServeEvents()) {\n      wireMockPactApi.addServeEvent(serveEvent);\n    }\n    // Save pact-json to folder given in WireMockPactApi\n    wireMockPactApi.saveAll();\n    server.stop();\n  }\n}\n</code></pre>"},{"location":"solutions/pact/#mappings-metadata-set-provider-in-mapping","title":"Mappings metadata - Set provider in mapping","text":"<p>You can adjust any mappings file like this to specify the provider of a mapping in its metadata field:</p> Diff<pre><code>{\n  \"id\" : \"d68fb4e2-48ed-40d2-bc73-0a18f54f3ece\",\n  \"request\" : {\n    \"urlPattern\" : \"/animals/1\",\n    \"method\" : \"GET\"\n  },\n  \"response\" : {\n    \"status\" : 202\n  },\n  \"uuid\" : \"d68fb4e2-48ed-40d2-bc73-0a18f54f3ece\",\n+  \"metadata\": {\n+   \"wireMockPactSettings\": {\n+     \"provider\":\"some-other-system\"\n+   }\n+  }\n}\n</code></pre> <p>Or programmatically:</p> Java<pre><code>    stubFor(\n        post(anyUrl())\n            .withMetadata(\n                new Metadata(\n                    Map.of(\n                        WireMockPactMetadata.METADATA_ATTR,\n                        new WireMockPactMetadata()\n                            .setProvider(\"some-specific-provider\")))));\n</code></pre>"},{"location":"solutions/pact/#publishing-to-pact-broker","title":"Publishing to Pact broker","text":"<p>Pact has a CLI tool that can be used for publishing the contracts. But it requires Ruby or Docker. If you don't have that, perhaps <code>curl</code> is an option. There is a shell script here that can also be used via NPM.</p> <p>You may want to use something like git-changelog-command-line to get the next version.</p> <p>There is a test-server at https://test.pactflow.io/ that can be accessed with user <code>dXfltyFMgNOFZAxr8io9wJ37iUpY42M</code> and password <code>O5AIZWxelWbLvqMd8PkAVycBJh2Psyg1</code>.</p> Bash<pre><code>current_version=$(npx git-changelog-command-line \\\n  --patch-version-pattern \"^fix.*\" \\\n  --print-current-version)\ngit_hash=`git rev-parse --short HEAD`\nparticipant_version_number=\"$current_version-$git_hash\"\n\nnpx pactflow-publish-sh \\\n --username=dXfltyFMgNOFZAxr8io9wJ37iUpY42M \\\n --password=O5AIZWxelWbLvqMd8PkAVycBJh2Psyg1 \\\n --pactflow-broker-url=https://test.pactflow.io/contracts/publish \\\n --build-url=http://whatever/ \\\n --pact-json-folder=wiremock-pact-example-springboot-app/src/test/resources/pact-json \\\n --participant-version-number=$participant_version_number\n</code></pre>"},{"location":"solutions/pact/#useful-pages","title":"Useful pages","text":"<ul> <li>WireMock on Java and JVM - Most of JVM generic solutions are applicable to Spring Boot  development too</li> </ul>"},{"location":"solutions/python/","title":"WireMock and Python","text":"<p>Documentation / solutions / python</p> <p>WireMock Cloud</p> <p>Centralize and scale your API mocks with WireMock Cloud.</p>"},{"location":"solutions/python/#python-wiremock","title":"Python WireMock","text":"<p>Python WireMock is a library that allows users to interact with a WireMock instance from within a Python project. Key features include:</p> <ul> <li>Testcontainers Python module to easily start WireMock server for your tests</li> <li>REST API Client for a standalone WireMock Java server</li> <li>Support for most of the major WireMock features (more on their way soon)</li> </ul> <p>There is a Python WireMock Admin API Client that connects to a standalone WireMock server. This project is a part of WireMock's GitHub organization.</p> <ul> <li>Documentation</li> <li>Official Repository</li> </ul>"},{"location":"solutions/python/#robot-framework-library","title":"Robot Framework Library","text":"<p>This project implements the Robot Framework keywords to interact with WireMock through HTTP.</p> <ul> <li>Documentation</li> <li>GitHub Repository</li> </ul>"},{"location":"solutions/quarkus/","title":"WireMock and Quarkus","text":"<p>Documentation / solutions / quarkus</p> <p>WireMock Cloud</p> <p>Centralize and scale your API mocks with WireMock Cloud.</p>"},{"location":"solutions/quarkus/#wiremock-extension-for-quarkus","title":"WireMock Extension for Quarkus","text":"<p>There is a WireMock extension in the Quarkiverse! It allows running WireMock for Quarkus projects in the development mode. This is a very basic way of running WireMock together with Quarkus, and only a few configuration options are supported:</p> Properties<pre><code>quarkus.wiremock.devservices.enabled=true\nquarkus.wiremock.devservices.files-mapping=&lt;path to wiremock root dir with mappings and __files folders&gt;\nquarkus.wiremock.devservices.port=8089\nquarkus.wiremock.devservices.reload=true\n</code></pre> <p>References:</p> <ul> <li>GitHub Repository</li> </ul>"},{"location":"solutions/quarkus/#more-info","title":"More info","text":"<ul> <li>Testing a Quarkus application with WireMock and Rest Assured,   by Giuseppe Scaramuzzino</li> <li>Building a Resilient Microservice with Quarkus and WireMock,   by Iain Porter</li> </ul>"},{"location":"solutions/rust/","title":"WireMock and Rust","text":"<p>Documentation / solutions / rust</p> <p>WireMock Cloud</p> <p>Centralize and scale your API mocks with WireMock Cloud.</p>"},{"location":"solutions/rust/#wiremock-rs-server-implementation-in-rust","title":"wiremock-rs. Server implementation in Rust","text":"<p>LukeMathWalker/wiremock-rs is an API Mock Server implementation in Rust. It provides HTTP mocking to perform black-box testing of Rust applications that interact with third-party APIs.</p> <p>This project is inspired by WireMock and has the same name in the documentation, but it is not compatible with WireMock when it comes to CLI, REST API or configuration files. Please refer to its documentation for more details and guidelines.</p> Rust<pre><code>use wiremock::{MockServer, Mock, ResponseTemplate};\nuse wiremock::matchers::{method, path};\n\n#[async_std::main]\nasync fn main() {\n    // Start a background HTTP server on a random local port\n    let mock_server = MockServer::start().await;\n\n    // Arrange the behaviour of the MockServer adding a Mock:\n    // when it receives a GET request on '/hello' it will respond with a 200.\n    Mock::given(method(\"GET\")).and(path(\"/hello\"))\n        .respond_with(ResponseTemplate::new(200))\n        .mount(&amp;mock_server).await;\n\n    // Verify the response\n    let status = surf::get(format!(\"{}/hello\", &amp;mock_server.uri()))\n        .await.unwrap().status();\n    assert_eq!(status.as_u16(), 200);\n}\n</code></pre> <p>References:</p> <ul> <li>Crates: <code>wiremock</code></li> <li>Documentation: docs.rs/wiremock</li> <li>GitHub: LukeMathWalker/wiremock-rs</li> </ul>"},{"location":"solutions/rust/#stubr","title":"Stubr","text":"<p>Stubr is an adaptation of <code>wiremock-rs</code> supporting existing WireMock json stubs as input. It aims at reaching feature parity with WireMock. The project also provides support for gRPC and offers Docker images.</p> Rust<pre><code>use asserhttp::*;\n\n#[tokio::test]\nasync fn getting_started() {\n    // run a mock server with the stub \ud83d\udc47\n    let stubr = stubr::Stubr::start(\"tests/stubs/hello.json\").await;\n    // or use 'start_blocking' for a non-async version\n\n    // the mock server started on a random port e.g. '127.0.0.1:43125'\n    // so we use the stub instance 'path' (or 'uri') method to get the address back\n    let uri = stubr.path(\"/hello\");\n    reqwest::get(uri).await\n        // (optional) use asserhttp for assertions\n        .expect_status_ok()\n        .expect_content_type_text()\n        .expect_body_text_eq(\"Hello stubr\");\n}\n</code></pre> <p>References:</p> <ul> <li>Crates: <code>stubr</code></li> <li>Documentation</li> <li>GitHub Repository</li> </ul>"},{"location":"solutions/rust/#testcontainers-module","title":"Testcontainers module","text":"<p>We are interested in providing a Testcontainers for Rust module that would provide SDK for the official WireMock Docker images. This module is on our roadmap but have not been published yet, see wiremock/ecosystem #8. Contributions are welcome!</p>"},{"location":"solutions/spring-boot-integration/","title":"Using WireMock with Spring Boot","text":"<p>Documentation / solutions / spring-boot-integration</p> <p>WireMock Cloud</p> <p>Centralize and scale your API mocks with WireMock Cloud.</p>"},{"location":"solutions/spring-boot-integration/#wiremock-spring-boot","title":"WireMock Spring Boot","text":"<p>WireMock's official Spring Boot integration library is the simplest way to configure Spring Boot, Junit 5 and WireMock to work together.</p> <p>It includes fully declarative WireMock setup, supports multiple <code>WireMockServer</code> instances, automatically sets Spring environment properties, and does not pollute Spring application context with extra beans.</p> <p>See WireMock Spring Boot Integration for details on installation and usage.</p> <p>You can contribute or log an issue in the GitHub project.</p>"},{"location":"solutions/spring-boot-integration/#spring-cloud-contract","title":"Spring Cloud Contract","text":"<p>WireMock provides the mocking capabilities for the Spring Cloud Contract project (a consumer-driven contract testing tool).</p> <p>See Spring Cloud Contract WireMock for details.</p>"},{"location":"solutions/spring-boot-integration/#jetty-version-issues-when-running-wiremock-and-spring-together","title":"Jetty version issues when running WireMock and Spring together.","text":"<p>WireMock's main artifact is built on Jetty 11, largely so that Java 11 support can be maintained. However, many Spring applications depend on Jetty 12 and the presence of both on the classpath causes WireMock to fail with a <code>ClassNotFoundException</code> or <code>NoClassDefFoundError</code> for Servlet API classes thrown during startup.</p> <p>To rectify this, WireMock now has a dedicated Jetty 12 artifact which can be added to your project's classpath. See the Jetty 12 page for details.</p>"},{"location":"solutions/spring-boot-integration/#useful-pages","title":"Useful pages","text":"<ul> <li>WireMock on Java and JVM - Most of JVM generic solutions are applicable to Spring Boot  development too</li> </ul>"},{"location":"solutions/testcontainers/","title":"WireMock and Testcontainers","text":"<p>Documentation / solutions / testcontainers</p> <p>WireMock Cloud</p> <p>Centralize and scale your API mocks with WireMock Cloud.</p> <p>The WireMock community provides modules for Testcontainers. They allow provisioning the WireMock server as a standalone container within your tests, based on WireMock Docker.</p> <p>All the modules are under active development. If there is no module implemented for your technology stack, a <code>GenericContainer</code> implementation from Testcontainers can be used. For features that are not implemented yet in Module APIs for your language, it is possible to use the Administrative REST API. Feedback and contributions are welcome!</p> <p>See WireMock on the Testcontainers modules listing.</p>"},{"location":"solutions/testcontainers/#official-testcontainers-modules","title":"Official Testcontainers modules","text":"<p>WireMock Inc. partners with AtomicJar Inc, a company stewarding the Testcontainers open source project and providing Testcontainers Cloud and Testcontainers Desktop (Partnership Announcement). As a part of the partnership, the following modules were reviewed and certified as the official modules:</p> <p>Java and other JVM languages. Java implementation is a separate library that is available to all JVM languages, e.g. Java, Kotlin or Scala. See full documentation in the GitHub Repository.</p> <p>Python. The Testcontainers Python module is a part of the Python WireMock library, so a single library integrates bot the CLI client and the Testcontainers module. See this page for all documentation and examples.</p> <p>Golang. Golang implementation is a multi-platform library that includes the Testcontainers module only. The module's full documentation and examples are available in its GitHub Repository. There is a separate library for the CLI, see the Golang Solutions page.</p>"},{"location":"solutions/testcontainers/#experimental-modules","title":"Experimental modules","text":"<p>C/C++ and other native languages. We created a WireMock module for Testcontainers for C/C++. It allows provisioning the WireMock server as a standalone container within your tests, based on WireMock Docker. It allows using WireMock with all popular C/C++ testing frameworks like Google Test, CTest, Doctest, QtTest or CppUnit. Read More: C/C++ Solutions Page.</p>"},{"location":"solutions/testcontainers/#other-languages","title":"Other Languages","text":"<p>All Testcontainers implementations provide API for provisioning custom containers, also known as Generic Container API. It allows using WireMock on platforms where there is no special Testcontainers module implemented yet: Node.js, Rust, Haskell, Ruby, etc.</p>"},{"location":"solutions/testcontainers/#code-examples","title":"Code examples","text":"<p>Examples of using the Testcontainers Modules for different languages and Testcontainers modules:</p> JavaPythonGolang Java<pre><code>import org.junit.jupiter.api.*;\nimport org.testcontainers.junit.jupiter.*;\nimport org.wiremock.integrations.testcontainers.testsupport.http.*;\nimport static org.assertj.core.api.Assertions.assertThat;\n\n@Testcontainers\nclass WireMockContainerJunit5Test {\n\n    @Container\n    WireMockContainer wiremockServer = new WireMockContainer(\"2.35.0\")\n            .withMapping(\"hello\", WireMockContainerJunit5Test.class, \"hello-world.json\");\n\n    @Test\n    void helloWorld() throws Exception {\n        String url = wiremockServer.getUrl(\"/hello\");\n        HttpResponse response = new TestHttpClient().get(url);\n        assertThat(response.getBody())\n                .as(\"Wrong response body\")\n                .contains(\"Hello, world!\");\n    }\n}\n</code></pre> Python<pre><code>import pytest\nfrom wiremock.testing.testcontainer import wiremock_container\n\n@pytest.fixture(scope=\"session\") # (1)\ndef wm_server():\n    with wiremock_container(secure=False) as wm:\n        Config.base_url = wm.get_url(\"__admin\") # (2)=\n        Mappings.create_mapping(\n            Mapping(\n                request=MappingRequest(method=HttpMethods.GET, url=\"/hello\"),\n                response=MappingResponse(status=200, body=\"hello\"),\n                persistent=False,\n            )\n        ) # (3)\n        yield wm\n\ndef test_get_hello_world(wm_server): # (4)\n    resp1 = requests.get(wm_server.get_url(\"/hello\"), verify=False)\n    assert resp1.status_code == 200\n    assert resp1.content == b\"hello\"\n</code></pre> Go<pre><code>package testcontainers_wiremock_quickstart\n\nimport (\n    \"context\"\n    \"testing\"\n\n    . \"github.com/wiremock/wiremock-testcontainers-go\"\n)\n\nfunc TestWireMock(t *testing.T) {\n    ctx := context.Background()\n    mappingFileName := \"hello-world.json\"\n\n    container, err := RunContainerAndStopOnCleanup(ctx, t,\n        WithMappingFile(mappingFileName),\n    )\n    if err != nil {\n        t.Fatal(err)\n    }\n\n    statusCode, out, err := SendHttpGet(container, \"/hello\", nil)\n    if err != nil {\n        t.Fatal(err, \"Failed to get a response\")\n    }\n\n    // Verify the response\n    if statusCode != 200 {\n        t.Fatalf(\"expected HTTP-200 but got %d\", statusCode)\n    }\n\n    if string(out) != \"Hello, world!\" {\n        t.Fatalf(\"expected 'Hello, world!' but got %s\", out)\n    }\n}\n</code></pre>"},{"location":"solutions/testcontainers/#coming-soon","title":"Coming soon","text":"<p>The following modules are under prototyping at the moment: <code>.NET</code>, <code>Rust</code>. A lot more features can be implemented in the listed modules, and any contributions are welcome! If you are interested, join us on the community Slack.</p>"},{"location":"solutions/testcontainers/#learn-more","title":"Learn More","text":""},{"location":"solutions/testcontainers/#references","title":"References","text":"<ul> <li>Devoxx BE talk on API Integration testing with Testcontainers and WireMock, by Oleg Nenashev and Oleg Shelaev: (Video, Slides)</li> </ul>"},{"location":"stubbing_and_verifying/proxying/","title":"Proxying","text":"<p>Documentation / stubbing_and_verifying / proxying </p> <p>WireMock Cloud</p> <p>Create stubs and scenarios with WireMock Cloud's intuitive editor and share with your team.</p> <p>WireMock has the ability to selectively proxy requests through to other hosts. This supports a proxy/intercept setup where requests are by default proxied to another (possibly real, live) service, but where specific stubs are configured these are returned in place of the remote service's response. Responses that the live service can't be forced to generate on demand can thus be injected for testing. Proxying also supports record and playback.</p>"},{"location":"stubbing_and_verifying/proxying/#proxy-stub-mappings","title":"Proxy stub mappings","text":"<p>Proxy responses are defined in exactly the same manner as stubs, meaning that the same request matching criteria can be used.</p> <p>The following code will proxy all GET requests made to <code>http://&lt;host&gt;:&lt;port&gt;/other/service/.*</code> to <code>http://otherservice.com/approot</code>, e.g. when running WireMock locally a request to <code>http://localhost:8080/other/service/doc/123</code> would be forwarded to <code>http://otherservice.com/approot/other/service/doc/123</code>.</p> Java<pre><code>stubFor(get(urlMatching(\"/other/service/.*\"))\n        .willReturn(aResponse().proxiedFrom(\"http://otherhost.com/approot\")));\n</code></pre> <p>The JSON equivalent would be:</p> JSON<pre><code>{\n    \"request\": {\n        \"method\": \"GET\",\n        \"urlPattern\": \"/other/service/.*\"\n    },\n    \"response\": {\n        \"proxyBaseUrl\": \"http://otherhost.com/approot\"\n    }\n}\n</code></pre>"},{"location":"stubbing_and_verifying/proxying/#proxyintercept","title":"Proxy/intercept","text":"<p>The proxy/intercept pattern described above is achieved by adding a low priority proxy mapping with a broad URL match and any number of higher priority stub mappings e.g.</p> Java<pre><code>// Low priority catch-all proxies to otherhost.com by default\nstubFor(get(urlMatching(\".*\")).atPriority(10)\n        .willReturn(aResponse().proxiedFrom(\"http://otherhost.com\")));\n\n\n// High priority stub will send a Service Unavailable response\n// if the specified URL is requested\nstubFor(get(urlEqualTo(\"/api/override/123\")).atPriority(1)\n        .willReturn(aResponse().withStatus(503)));\n</code></pre>"},{"location":"stubbing_and_verifying/proxying/#remove-path-prefix","title":"Remove path prefix","text":"<p>The prefix of a request path can be removed before proxying the request:</p> Java<pre><code>stubFor(get(urlEqualTo(\"/other/service/doc/123\"))\n        .willReturn(aResponse()\n            .proxiedFrom(\"http://otherhost.com/approot\")\n            .withProxyUrlPrefixToRemove(\"/other/service\")));\n</code></pre> <p>or</p> JSON<pre><code>{\n    \"request\": {\n        \"method\": \"GET\",\n        \"url\": \"/other/service/doc/123\"\n    },\n    \"response\": {\n        \"proxyBaseUrl\": \"http://otherhost.com/approot\",\n        \"proxyUrlPrefixToRemove\": \"/other/service\"\n    }\n}\n</code></pre> <p>Requests using the above path will be forwarded to <code>http://otherhost.com/approot/doc/123</code></p>"},{"location":"stubbing_and_verifying/proxying/#additional-headers","title":"Additional headers","text":"<p>It is possible to configure the proxy to add headers before forwarding the request to the destination:</p> Java<pre><code>// Inject user agent to trigger rendering of mobile version of website\nstubFor(get(urlMatching(\".*\"))\n        .willReturn(aResponse()\n            .proxiedFrom(\"http://otherhost.com\")\n            .withAdditionalRequestHeader(\"User-Agent\", \"Mozilla/5.0 (iPhone; U; CPU iPhone)\")));\n</code></pre> <p>or</p> JSON<pre><code>{\n    \"request\": {\n        \"method\": \"GET\",\n        \"urlPattern\": \".*\"\n    },\n    \"response\": {\n        \"proxyBaseUrl\": \"http://otherhost.com\",\n        \"additionalProxyRequestHeaders\": {\n            \"User-Agent\": \"Mozilla/5.0 (iPhone; U; CPU iPhone)\"\n        }\n    }\n}\n</code></pre> <p>You can also add response headers via the same method as for non-proxy responses (see Stubbing).</p>"},{"location":"stubbing_and_verifying/proxying/#remove-headers","title":"Remove headers","text":"<p>It is possible to configure the proxy to remove headers before forwarding the reques to the destination (additional headers matching the removed headers will still be added).</p> Java<pre><code>stubFor(get(urlMatching(\".*\"))\n        .willReturn(aResponse()\n            .proxiedFrom(\"http://otherhost.com\")\n            .withRemoveRequestHeader(\"User-Agent\")));\n</code></pre> <p>or</p> JSON<pre><code>{\n    \"request\": {\n        \"method\": \"GET\",\n        \"urlPattern\": \".*\"\n    },\n    \"response\": {\n        \"proxyBaseUrl\": \"http://otherhost.com\",\n        \"removeProxyRequestHeaders\": [\n            \"User-Agent\"\n        ]\n    }\n}\n</code></pre>"},{"location":"stubbing_and_verifying/proxying/#standalone-shortcut","title":"Standalone shortcut","text":"<p>It is possible to start the standalone running with the catch-all stub already configured:</p> <p>Then it's simply a case of adding your stub mapping <code>.json</code> files under <code>mappings</code> as usual (see Stubbing).</p>"},{"location":"stubbing_and_verifying/proxying/#running-as-a-browser-proxy","title":"Running as a browser proxy","text":"<p>WireMock can be made to work as a forward (browser) proxy.</p> <p>One benefit of this is that it supports a website-based variant of the proxy/intercept pattern described above, allowing you to modify specific AJAX requests or swap out CSS/Javascript files.</p> <p>To configure your browser to proxy via WireMock, first start WireMock with browser proxying enabled:</p> Bash<pre><code>$ java -jar wiremock-standalone-3.13.1.jar --enable-browser-proxying --port 9999\n</code></pre> <p>Then open your browser's proxy settings and point them to the running server: </p> <p>After that, you can configure stubs as described in Running Standalone and then browse to a website. Any resources fetched whose requests are matched by stubs you have configured will be overridden by the stub's response.</p> <p>So for instance, say you're visiting a web page that fetches a user profile via an AJAX call to <code>/users/12345.json</code> and you wanted to test how it responded to a server unavailable response. You could create a stub like this and the response from the server would be swapped for a 503 response:</p> Java<pre><code>stubFor(get(urlEqualTo(\"/users/12345.json\"))\n  .willReturn(aResponse()\n  .withStatus(503)));\n</code></pre> <p>Also, we can enable/disable pass through unmatched requests to the target indicated by the original requests by enabling/disabling proxyPassThrough flag. By default, flag is set to true. </p> <p>This flag can be enabled/disabled at startup either by passing CLI option while running jar as described in Running Standalone or by passing as options in Java client as shown below.</p> Java<pre><code>WireMockServer wireMockServer = new WireMockServer(options().proxyPassThrough(false));\n</code></pre> <p>We can also update this flag without WireMock restart either by using Admin API as described in API section if we are running as standalone or by updating the global settings in Java client.</p> <p>Json payload to update via admin API JSON<pre><code>{\n  ...\n  \"proxyPassThrough\": false\n}\n</code></pre></p> Java<pre><code>WireMock.updateSettings(WireMock.getSettings().copy().proxyPassThrough(false).build());\n</code></pre>"},{"location":"stubbing_and_verifying/proxying/#browser-proxying-of-https","title":"Browser proxying of HTTPS","text":"<p>WireMock allows forward proxying, stubbing &amp; recording of HTTPS traffic.</p> <p>This happens automatically when browser proxying is enabled.</p> <p>We strongly recommend using WireMock over HTTP to proxy HTTPS; there are no associated security concerns, and proxying HTTPS over HTTPS is poorly supported by many clients.</p> <p>Note that when clients / operating systems distinguish between HTTP &amp; HTTPS proxies they are often referring to the scheme of the target server, not the scheme the proxy server is listening on.</p>"},{"location":"stubbing_and_verifying/proxying/#getting-your-client-to-trust-the-certificate-presented-by-wiremock","title":"Getting your client to trust the certificate presented by WireMock","text":"<p>Normally when proxying HTTPS the proxy creates a TCP tunnel between the client and the target server, so the HTTPS session is between the client and the target server. While the proxy passes the bytes back and forward, it cannot understand them because there is end-to-end encryption between the client and the target.</p> <p>WireMock needs to decrypt the traffic in order to record or replace it with stubs. Consequently, there have to be two separate HTTPS sessions - one between WireMock and the target server, and one between the client and WireMock. This means that when you request https://www.example.com proxied via WireMock the HTTPS certificate will be presented by WireMock, not www.example.com. Inevitably it cannot be trusted by default - otherwise no internet traffic would be secure.</p> <p>WireMock uses a root Certificate Authority private key to sign a certificate for each host that it proxies. By default, WireMock will use a CA key store at <code>$HOME/.wiremock/ca-keystore.jks</code>. If this key store does not exist, WireMock will generate it with a new secure private key which should be entirely private to the system on which WireMock is running. You can provide a key store containing such a private key &amp; certificate yourself using the <code>--ca-keystore</code>, <code>--ca-keystore-password</code> &amp; <code>--ca-keystore-type</code> options.</p> <p>See this script for an example of how to build a key &amp; valid self-signed root certificate called ca-cert.crt already imported into a keystore called ca-cert.jks.</p> <p>This CA certificate can be downloaded from WireMock: http://localhost:8080/__admin/certs/wiremock-ca.crt. There's a link to the certificate on the recorder UI page at http://localhost:8080/__admin/recorder. Trusting this certificate will trust all certificates generated by it, allowing you to browse without client warnings.</p> <p>On OS/X a certificate can be trusted by dragging ca-cert.crt onto Keychain Access, double clicking on the certificate and setting SSL to \"always trust\".</p> <p>A few caveats:</p> <ul> <li>This depends on internal sun classes; it works with OpenJDK 1.8 -&gt; 14, but may     stop working in future versions or on other runtimes</li> <li>It's your responsibility to keep the private key &amp; keystore secure - if you     add it to your trusted certs then anyone getting hold of it could potentially     get access to any service you use on the web.</li> </ul>"},{"location":"stubbing_and_verifying/proxying/#trusting-targets-with-invalid-https-certificates","title":"Trusting targets with invalid HTTPS certificates","text":"<p>For convenience when acting as a reverse proxy WireMock ignores HTTPS certificate problems from the target such as untrusted certificates or incorrect hostnames on the certificate. When browser proxying, however, it is normal to proxy all traffic, often for the entire operating system. This would present a substantial security risk, so by default WireMock will verify the target certificates when browser proxying. You can trust specific hosts as follows:</p> Bash<pre><code>$ java -jar wiremock-standalone-3.13.1.jar --enable-browser-proxying --trust-proxy-target localhost --trust-proxy-target dev.mycorp.com\n</code></pre> <p>or if you're not interested in security you can trust all hosts:</p> Bash<pre><code>$ java -jar wiremock-standalone-3.13.1.jar --enable-browser-proxying --trust-all-proxy-targets\n</code></pre> <p>Additional trusted public certificates can also be added to the keystore specified via the <code>--https-truststore</code>, and WireMock will then trust them without needing the <code>--trust-proxy-target</code> parameter (so long as they match the requested host).</p>"},{"location":"stubbing_and_verifying/proxying/#proxying-https-on-the-https-endpoint","title":"Proxying HTTPS on the HTTPS endpoint","text":"<p>The only use case we can think of for this is if you are using WireMock to test a generic HTTPS client, and want that HTTPS client to support proxying HTTPS over HTTPS. It has several problems. However, if you really must, there is limited support for doing so.</p> <p>Please be aware that many clients do not work very well with this configuration. For instance:</p> <p>Postman seems not to cope with an HTTPS proxy even to proxy HTTP traffic.</p> <p>Older versions of curl fail trying to do the CONNECT call because they try to do so over HTTP/2 (newer versions only offer HTTP/1.1 for the CONNECT call). At time of writing it works using <code>curl 7.64.1 (x86_64-apple-darwin19.0) libcurl/7.64.1 (SecureTransport) LibreSSL/2.8.3 zlib/1.2.11 nghttp2/1.39.2</code> as so:</p> Bash<pre><code>curl --proxy-insecure -x https://localhost:8443 -k 'https://www.example.com/'\n</code></pre> <p>You can force HTTP/1.1 in curl as so:</p> Bash<pre><code>curl --http1.1 --proxy-insecure -x https://localhost:8443 -k 'https://www.example.com/'\n</code></pre> <p>Please check your client's behaviour proxying via another https proxy such as https://hub.docker.com/r/wernight/spdyproxy to see if it is a client problem before asking for help:</p> Bash<pre><code>docker run --rm -it -p 44300:44300 wernight/spdyproxy\ncurl --proxy-insecure -x https://localhost:44300 -k 'https://www.example.com/'\n</code></pre>"},{"location":"stubbing_and_verifying/proxying/#security-concerns","title":"Security concerns","text":"<p>Acting as a man in the middle for HTTPS traffic has to be done at your own risk. Whilst best efforts have been taken to reduce your risk, you should be aware you are granting WireMock unencrypted access to all HTTPS traffic proxied via WireMock, and that as part of its normal operation WireMock may store that traffic, in memory or on the file system, or print it to the console. If you choose to trust the root CA certificate WireMock is using, or you choose to bypass HTTPS verification for some or all target servers, you should understand the risk involved.</p>"},{"location":"stubbing_and_verifying/proxying/#proxying-via-another-proxy-server","title":"Proxying via another proxy server","text":"<p>If you're inside a network that only permits HTTP traffic out to the internet via an opaque proxy you might wish to set up proxy mappings that route via this server. This can be configured programmatically by passing a configuration object to the constructor of <code>WireMockServer</code> or the JUnit rules like this:</p> Java<pre><code>WireMockServer wireMockServer = new WireMockServer(options()\n  .proxyVia(\"proxy.mycorp.com\", 8080)\n);\n</code></pre>"},{"location":"stubbing_and_verifying/proxying/#proxying-to-a-target-server-that-requires-client-certificate-authentication","title":"Proxying to a target server that requires client certificate authentication","text":"<p>WireMock's proxy client will send a client certificate if the target service requires it and a trust store containing the certificate is configured:</p> Java<pre><code>@Rule\npublic WireMockRule wireMockRule = new WireMockRule(wireMockConfig()\n    .trustStorePath(\"/path/to/truststore.jks\")\n    .trustStorePassword(\"mostsecret\")); // Defaults to \"password\" if omitted\n</code></pre> <p>See Running as a Standalone Process for command line equivalent.</p>"},{"location":"stubbing_and_verifying/request_matching/","title":"Request Matching","text":"<p>Documentation / stubbing_and_verifying / request_matching</p> <p>WireMock Cloud</p> <p>If you need to protect your mock APIs with Enterprise-grade security options, learn about WireMock Cloud.</p> <p>WireMock enables flexible definition of a mock API by supporting rich matching of incoming requests. Stub matching and verification queries can use the following request attributes:</p> <ul> <li>URL</li> <li>HTTP Method</li> <li>Query parameters</li> <li>Form parameters</li> <li>Headers</li> <li>Basic authentication (a special case of header matching)</li> <li>Cookies</li> <li>Request body</li> <li>Multipart/form-data</li> <li>Client IP (as of WireMock version <code>3.13.0</code>)</li> </ul> <p>Here's an example showing all attributes being matched using WireMock's in-built match operators. It is also possible to write custom matching logic if you need more precise control:</p>"},{"location":"stubbing_and_verifying/request_matching/#request-with-xml-body","title":"Request with XML Body","text":"JavaJSON Java<pre><code>stubFor(any(urlPathEqualTo(\"/everything\"))\n.withHeader(\"Accept\", containing(\"xml\"))\n.withCookie(\"session\", matching(\".*12345.*\"))\n.withQueryParam(\"search_term\", equalTo(\"WireMock\"))\n.withBasicAuth(\"jeff@example.com\", \"jeffteenjefftyjeff\")\n.withRequestBody(equalToXml(\"&lt;search-results /&gt;\"))\n.withRequestBody(matchingXPath(\"//search-results\"))\n.withMultipartRequestBody(\n    aMultipart()\n        .withName(\"info\")\n        .withHeader(\"Content-Type\", containing(\"charset\"))\n        .withBody(equalToJson(\"{}\"))\n)\n.withClientIp(equalTo(\"127.0.0.1\"))\n.willReturn(aResponse()));\n</code></pre> JSON<pre><code>{\n    \"request\": {\n        \"urlPath\": \"/everything\",\n        \"method\": \"ANY\",\n        \"headers\": {\n            \"Accept\": {\n                \"contains\": \"xml\"\n            }\n        },\n        \"queryParameters\": {\n            \"search_term\": {\n                \"equalTo\": \"WireMock\"\n            }\n        },\n        \"cookies\": {\n            \"session\": {\n                \"matches\": \".*12345.*\"\n            }\n        },\n        \"bodyPatterns\": [\n            {\n                \"equalToXml\": \"&lt;search-results /&gt;\"\n            },\n            {\n                \"matchesXPath\": \"//search-results\"\n            }\n        ],\n        \"multipartPatterns\": [\n            {\n                \"matchingType\": \"ANY\",\n                \"headers\": {\n                    \"Content-Disposition\": {\n                        \"contains\": \"name=\\\"info\\\"\"\n                    },\n                    \"Content-Type\": {\n                        \"contains\": \"charset\"\n                    }\n                },\n                \"bodyPatterns\": [\n                    {\n                        \"equalToJson\": \"{}\"\n                    }\n                ]\n            }\n        ],\n        \"basicAuthCredentials\": {\n            \"username\": \"jeff@example.com\",\n            \"password\": \"jeffteenjefftyjeff\"\n        },\n        \"clientIp\": {\n            \"equalTo\": \"127.0.0.1\"\n        }\n    },\n    \"response\": {\n        \"status\": 200\n    }\n}\n</code></pre>"},{"location":"stubbing_and_verifying/request_matching/#request-with-form-parameters","title":"Request with Form Parameters","text":"JavaJSON Java<pre><code>stubFor(post(urlPathEqualTo(\"/mock\"))\n        .withFormParam(\"tool\", equalTo(\"WireMock\")\n).willReturn(ok()));\n</code></pre> JSON<pre><code>{\n\"request\": {\n    \"urlPath\": \"/mock\",\n    \"method\": \"POST\",\n    \"formParameters\": {\n    \"tool\": {\n        \"equalTo\": \"WireMock\"\n    }\n    }\n},\n\"response\": {\n    \"status\": 200\n}\n}\n</code></pre> <p>The following sections describe each type of matching strategy in detail.</p>"},{"location":"stubbing_and_verifying/request_matching/#url-matching","title":"URL matching","text":"<p>URLs can be matched either by equality or by regular expression. You also have a choice of whether to match just the path part of the URL or the path and query together.</p> <p>It is usually preferable to match on path only if you want to match multiple query parameters in an order invariant manner.</p>"},{"location":"stubbing_and_verifying/request_matching/#equality-matching-on-path-and-query","title":"Equality matching on path and query","text":"JavaJSON Java<pre><code>urlEqualTo(\"/your/url?and=query\")\n</code></pre> JSON<pre><code>{\n\"request\": {\n    \"url\": \"/your/url?and=query\"\n    ...\n},\n...\n}\n</code></pre>"},{"location":"stubbing_and_verifying/request_matching/#regex-matching-on-path-and-query","title":"Regex matching on path and query","text":"JavaJSON Java<pre><code>urlMatching(\"/your/([a-z]*)\\\\?and=query\")\n</code></pre> JSON<pre><code>{\n\"request\": {\n    \"urlPattern\": \"/your/([a-z]*)\\\\?and=query\"\n    ...\n},\n...\n}\n</code></pre>"},{"location":"stubbing_and_verifying/request_matching/#equality-matching-on-the-path-only","title":"Equality matching on the path only","text":"JavaJSON Java<pre><code>urlPathEqualTo(\"/your/url\")\n</code></pre> JSON<pre><code>{\n\"request\": {\n    \"urlPath\": \"/your/url\"\n    ...\n},\n...\n}\n</code></pre>"},{"location":"stubbing_and_verifying/request_matching/#regex-matching-on-the-path-only","title":"Regex matching on the path only","text":"JavaJSON Java<pre><code>urlPathMatching(\"/your/([a-z]*)\")\n</code></pre> JSON<pre><code>{\n\"request\": {\n    \"urlPathPattern\": \"/your/([a-z]*)\"\n    ...\n},\n...\n}\n</code></pre>"},{"location":"stubbing_and_verifying/request_matching/#path-templates","title":"Path templates","text":"<p>WireMock from 3.0.0 onwards supports matching on URL path templates conforming to the RFC 6570 standard.</p> <p>When the path template URL match type is used this enables</p> <ol> <li>The ability to match path variables in the same way as query parameters, headers etc.</li> <li>The ability to reference path variables by name in response templates.</li> </ol> <p>To match any request URL that conforms to the path template, you can do the following.</p> JavaJSON Java<pre><code>stubFor(\n    get(urlPathTemplate(\"/contacts/{contactId}/addresses/{addressId}\"))\n    .willReturn(ok()));\n</code></pre> JSON<pre><code>{\n\"request\": {\n    \"urlPathTemplate\": \"/contacts/{contactId}/addresses/{addressId}\"\n    \"method\" : \"GET\"\n},\n\"response\" : {\n    \"status\" : 200\n}\n}\n</code></pre> <p>To further constrain the match to specific values of the path variables you can add match clauses for some or all of the variables in the path expression.</p> JavaJSON Java<pre><code>stubFor(\n    get(urlPathTemplate(\"/contacts/{contactId}/addresses/{addressId}\"))\n    .withPathParam(\"contactId\", equalTo(\"12345\"))\n    .withPathParam(\"addressId\", equalTo(\"99876\"))\n    .willReturn(ok()));\n</code></pre> JSON<pre><code>{\n\"request\" : {\n    \"urlPathTemplate\" : \"/v1/contacts/{contactId}/addresses/{addressId}\",\n    \"method\" : \"GET\",\n    \"pathParameters\" : {\n    \"contactId\" : {\n        \"equalTo\" : \"12345\"\n    },\n    \"addressId\" : {\n        \"equalTo\" : \"99876\"\n    }\n    }\n},\n\"response\" : {\n    \"status\" : 200\n}\n}\n</code></pre>"},{"location":"stubbing_and_verifying/request_matching/#matching-other-attributes","title":"Matching other attributes","text":"<p>All request attributes other than the URL can be matched using the following set of operators.</p>"},{"location":"stubbing_and_verifying/request_matching/#equality","title":"Equality","text":"<p>Deems a match if the entire attribute value equals the expected value.</p> JavaJSON Java<pre><code>.withHeader(\"Content-Type\", equalTo(\"application/json\"))\n</code></pre> JSON<pre><code>{\n\"request\": {\n    ...\n    \"headers\": {\n    \"Content-Type\": {\n        \"equalTo\": \"application/json\"\n    }\n    }\n    ...\n},\n...\n}\n</code></pre>"},{"location":"stubbing_and_verifying/request_matching/#case-insensitive-equality","title":"Case-insensitive equality","text":"<p>Deems a match if the entire attribute value equals the expected value, ignoring case.</p> JavaJSON Java<pre><code>.withHeader(\"Content-Type\", equalToIgnoreCase(\"application/json\"))\n</code></pre> JSON<pre><code>{\n\"request\": {\n    ...\n    \"headers\": {\n    \"Content-Type\": {\n        \"equalTo\": \"application/json\",\n        \"caseInsensitive\": true\n    }\n    }\n    ...\n},\n...\n}\n</code></pre>"},{"location":"stubbing_and_verifying/request_matching/#binary-equality","title":"Binary Equality","text":"<p>Deems a match if the entire binary attribute value equals the expected value. Unlike the above equalTo operator, this compares byte arrays (or their equivalent base64 representation).</p> JavaJSON Java<pre><code>// Specifying the expected value as a byte array\n.withRequestBody(binaryEqualTo(new byte[] { 1, 2, 3 }))\n\n// Specifying the expected value as a base64 String\n.withRequestBody(binaryEqualTo(\"AQID\"))\n</code></pre> JSON<pre><code>{\n\"request\": {\n    ...\n    \"bodyPatterns\" : [{\n        \"binaryEqualTo\" : \"AQID\" // Base 64\n    }]\n    ...\n},\n...\n}\n</code></pre>"},{"location":"stubbing_and_verifying/request_matching/#substring-contains","title":"Substring (contains)","text":"<p>Deems a match if the a portion of the attribute value equals the expected value.</p> JavaJSON Java<pre><code>.withCookie(\"my_profile\", containing(\"johnsmith@example.com\"))\n</code></pre> JSON<pre><code>{\n\"request\": {\n    ...\n    \"cookies\" : {\n    \"my_profile\" : {\n        \"contains\" : \"johnsmith@example.com\"\n    }\n    }\n    ...\n},\n...\n}\n</code></pre>"},{"location":"stubbing_and_verifying/request_matching/#negative-substring-does-not-contain","title":"Negative substring (does not contain)","text":"<p>Deems a match if the attribute value does not contain the expected value.</p> JavaJSON Java<pre><code>.withCookie(\"my_profile\", notContaining(\"johnsmith@example.com\"))\n</code></pre> JSON<pre><code>{\n\"request\": {\n    ...\n    \"cookies\" : {\n    \"my_profile\" : {\n        \"doesNotContain\" : \"johnsmith@example.com\"\n    }\n    }\n    ...\n},\n...\n}\n</code></pre>"},{"location":"stubbing_and_verifying/request_matching/#regular-expression","title":"Regular expression","text":"<p>Deems a match if the entire attribute value matched the expected regular expression.</p> JavaJSON Java<pre><code>.withQueryParam(\"search_term\", matching(\"^(.*)wiremock([A-Za-z]+)$\"))\n</code></pre> JSON<pre><code>{\n\"request\": {\n    ...\n    \"queryParameters\" : {\n    \"search_term\" : {\n        \"matches\" : \"^(.*)wiremock([A-Za-z]+)$\"\n    }\n    }\n    ...\n},\n...\n}\n</code></pre> <p>It is also possible to perform a negative match i.e. the match succeeds when the attribute value does not match the regex:</p> JavaJSON Java<pre><code>.withQueryParam(\"search_term\", notMatching(\"^(.*)wiremock([A-Za-z]+)$\"))\n</code></pre> JSON<pre><code>{\n\"request\": {\n    ...\n    \"queryParameters\" : {\n    \"search_term\" : {\n        \"doesNotMatch\" : \"^(.*)wiremock([A-Za-z]+)$\"\n    }\n    }\n    ...\n},\n...\n}\n</code></pre>"},{"location":"stubbing_and_verifying/request_matching/#json-equality","title":"JSON equality","text":"<p>Deems a match if the attribute (most likely the request body in practice) is valid JSON and is a semantic match for the expected value.</p> JavaJSON Java<pre><code>.withRequestBody(equalToJson(\"{ \\\"total_results\\\": 4 }\"))\n</code></pre> JSON<pre><code>{\n\"request\": {\n    ...\n    \"bodyPatterns\" : [ {\n    \"equalToJson\" : { \"total_results\": 4 }\n    } ]\n    ...\n},\n...\n}\n</code></pre> <p>With string literal:</p> JSON JSON<pre><code>{\n\"request\": {\n    ...\n    \"bodyPatterns\" : [ {\n    \"equalToJson\" : \"{ \\\"total_results\\\": 4 }\"\n    } ]\n    ...\n},\n...\n}\n</code></pre>"},{"location":"stubbing_and_verifying/request_matching/#less-strict-matching","title":"Less strict matching","text":"<p>By default different array orderings and additional object attributes will trigger a non-match. However, both of these conditions can be disabled individually.</p> JavaJSON Java<pre><code>.withRequestBody(equalToJson(\"{ \\\"total_results\\\": 4  }\", true, true))\n</code></pre> JSON<pre><code>{\n\"request\": {\n    ...\n    \"bodyPatterns\" : [ {\n    \"equalToJson\" : \"{ \\\"total_results\\\": 4  }\",\n    \"ignoreArrayOrder\" : true,\n    \"ignoreExtraElements\" : true\n    } ]\n    ...\n},\n...\n}\n</code></pre>"},{"location":"stubbing_and_verifying/request_matching/#placeholders","title":"Placeholders","text":"<p>JSON equality matching is based on JsonUnit and therefore supports placeholders. This allows specific attributes to be treated as wildcards, rather than an exactly value being required for a match.</p> <p>For instance, the following:</p> JSON<pre><code>{ \"id\": \"${json-unit.any-string}\" }\n</code></pre> <p>would match a request with a JSON body of:</p> JSON<pre><code>{ \"id\": \"abc123\" }\n</code></pre> <p>It's also possible to use placeholders that constrain the expected value by type or regular expression. See the JsonUnit placeholders documentation for the full syntax.</p>"},{"location":"stubbing_and_verifying/request_matching/#json-path","title":"JSON Path","text":"<p>Deems a match if the attribute value is valid JSON and matches the JSON Path expression supplied. A JSON body will be considered to match a path expression if the expression returns either a non-null single value (string, integer etc.), or a non-empty object or array.</p>"},{"location":"stubbing_and_verifying/request_matching/#presence-matching","title":"Presence matching","text":"<p>Deems a match if the attribute value is present in the JSON.</p> JavaJSON Java<pre><code>.withRequestBody(matchingJsonPath(\"$.name\"))\n</code></pre> JSON<pre><code>{\n\"request\": {\n    ...\n    \"bodyPatterns\" : [ {\n    \"matchesJsonPath\" : \"$.name\"\n    } ]\n    ...\n},\n...\n}\n</code></pre> <p>Request body example:</p> Text Only<pre><code>// matching\n{ \"name\": \"Wiremock\" }\n// not matching\n{ \"price\": 15 }\n</code></pre>"},{"location":"stubbing_and_verifying/request_matching/#equality-matching","title":"Equality matching","text":"<p>Deems a match if the attribute value equals the expected value.</p> JavaJSON Java<pre><code>.withRequestBody(matchingJsonPath(\"$.things[?(@.name == 'RequiredThing')]\"))\n</code></pre> JSON<pre><code>{\n\"request\": {\n    ...\n    \"bodyPatterns\" : [ {\n    \"matchesJsonPath\" : \"$.things[?(@.name == 'RequiredThing')]\"\n    } ]\n    ...\n},\n...\n}\n</code></pre> <p>Request body example:</p> Text Only<pre><code>// matching\n{ \"things\": { \"name\": \"RequiredThing\" } }\n{ \"things\": [ { \"name\": \"RequiredThing\" }, { \"name\": \"Wiremock\" } ] }\n// not matching\n{ \"price\": 15 }\n{ \"things\": { \"name\": \"Wiremock\" } }\n</code></pre>"},{"location":"stubbing_and_verifying/request_matching/#regex-matching","title":"Regex matching","text":"<p>Deems a match if the attribute value matches the regex expected value.</p> JavaJSON Java<pre><code>.withRequestBody(matchingJsonPath(\"$.things[?(@.name =~ /Required.*/i)]\"))\n</code></pre> JSON<pre><code>{\n\"request\": {\n    ...\n    \"bodyPatterns\" : [ {\n    \"matchesJsonPath\" : \"$.things[?(@.name =~ /Required.*/i)]\"\n    } ]\n    ...\n},\n...\n}\n</code></pre> <p>Request body example:</p> JSON<pre><code>// matching\n{ \"things\": { \"name\": \"RequiredThing\" } }\n{ \"things\": [ { \"name\": \"Required\" }, { \"name\": \"Wiremock\" } ] }\n// not matching\n{ \"price\": 15 }\n{ \"things\": { \"name\": \"Wiremock\" } }\n{ \"things\": [ { \"name\": \"Thing\" }, { \"name\": \"Wiremock\" } ] }\n</code></pre>"},{"location":"stubbing_and_verifying/request_matching/#size-matching","title":"Size matching","text":"<p>Deems a match if the attribute size matches the expected size.</p> JavaJSON Java<pre><code>.withRequestBody(matchingJsonPath(\"$[?(@.things.size() == 2)]\"))\n</code></pre> JSON<pre><code>{\n\"request\": {\n    ...\n    \"bodyPatterns\" : [ {\n    \"matchesJsonPath\" : \"$[?(@.things.size() == 2)]\"\n    } ]\n    ...\n},\n...\n}\n</code></pre> <p>Request body example:</p> JSON<pre><code>// matching\n{ \"things\": [ { \"name\": \"RequiredThing\" }, { \"name\": \"Wiremock\" } ] }\n// not matching\n{ \"things\": [ { \"name\": \"RequiredThing\" } ] }\n</code></pre>"},{"location":"stubbing_and_verifying/request_matching/#nested-value-matching","title":"Nested value matching","text":"<p>The JSONPath matcher can be combined with another matcher, such that the value returned from the JSONPath query is evaluated against it:</p> JavaJSON Java<pre><code>.withRequestBody(matchingJsonPath(\"$..todoItem\", containing(\"wash\")))\n</code></pre> JSON<pre><code>{\n\"request\": {\n    ...\n    \"bodyPatterns\" : [ {\n    \"matchesJsonPath\" : {\n        \"expression\": \"$..todoItem\",\n        \"contains\": \"wash\"\n    }\n    } ]\n    ...\n},\n...\n}\n</code></pre> <p>Since WireMock's matching operators all work on strings, the value selected by the JSONPath expression will be coerced to a string before the match is evaluated. This true even if the returned value is an object or array. A benefit of this is that this allows a sub-document to be selected using JSONPath, then matched using the <code>equalToJson</code> operator. E.g. for the following request body:</p> JSON<pre><code>{\n    \"outer\": {\n        \"inner\": 42\n    }\n}\n</code></pre> <p>The following will match:</p> Java Java<pre><code>.withRequestBody(matchingJsonPath(\"$.outer\", equalToJson(\"{                \\n\" +\n                                                         \"   \\\"inner\\\": 42 \\n\" +\n                                                         \"}\")))\n</code></pre> JSON JSON<pre><code>{\n\"request\": {\n    ...\n    \"bodyPatterns\" : [ {\n    \"matchesJsonPath\" : {\n        \"expression\": \"$.outer\",\n        \"equalToJson\": \"{ \\\"inner\\\": 42 }\"\n    }\n    } ]\n    ...\n},\n...\n}\n</code></pre>"},{"location":"stubbing_and_verifying/request_matching/#json-schema","title":"JSON schema","text":"<p>Deems a match if the value conforms to the expected JSON schema.</p> <p>By default the V202012 version of the JSON schema spec will be used, but this can be changed to one of <code>V4</code>, <code>V6</code>, <code>V7</code>, <code>V201909</code>, <code>V202012</code> via the <code>schemaVersion</code> parameter.</p> JavaJSON Java<pre><code>stubFor(\npost(urlPathEqualTo(\"/schema-match\"))\n    .withRequestBody(matchingJsonSchema(\"{\\n\" +\n        \"  \\\"type\\\": \\\"object\\\",\\n\" +\n        \"  \\\"required\\\": [\\n\" +\n        \"    \\\"name\\\"\\n\" +\n        \"  ],\\n\" +\n        \"  \\\"properties\\\": {\\n\" +\n        \"    \\\"name\\\": {\\n\" +\n        \"      \\\"type\\\": \\\"string\\\"\\n\" +\n        \"    },\\n\" +\n        \"    \\\"tag\\\": {\\n\" +\n        \"      \\\"type\\\": \\\"string\\\"\\n\" +\n        \"    }\\n\" +\n        \"  }\\n\" +\n        \"}\"))\n    .willReturn(ok()));\n</code></pre> <p>(supported in 3.4+):</p> JSON<pre><code>{\n\"request\" : {\n    \"urlPath\" : \"/schema-match\",\n    \"method\" : \"POST\",\n    \"bodyPatterns\" : [ {\n    \"matchesJsonSchema\" : {\n        \"type\": \"object\",\n        \"required\": [\n        \"name\"\n        ],\n        \"properties\": {\n        \"name\": {\n            \"type\": \"string\"\n        },\n        \"tag\": {\n            \"type\": \"string\"\n        }\n        }\n    },\n    \"schemaVersion\" : \"V202012\"\n    } ]\n},\n\"response\" : {\n    \"status\" : 200\n}\n}\n</code></pre> <p>With string literal:</p> JSON<pre><code>{\n  \"request\" : {\n    \"urlPath\" : \"/schema-match\",\n    \"method\" : \"POST\",\n    \"bodyPatterns\" : [ {\n      \"matchesJsonSchema\" : \"{\\n  \\\"type\\\": \\\"object\\\",\\n  \\\"required\\\": [\\n    \\\"name\\\"\\n  ],\\n  \\\"properties\\\": {\\n    \\\"name\\\": {\\n      \\\"type\\\": \\\"string\\\"\\n    },\\n    \\\"tag\\\": {\\n      \\\"type\\\": \\\"string\\\"\\n    }\\n  }\\n}\",\n      \"schemaVersion\" : \"V202012\"\n    } ]\n  },\n  \"response\" : {\n    \"status\" : 200\n  }\n}\n</code></pre>"},{"location":"stubbing_and_verifying/request_matching/#xml-equality","title":"XML equality","text":"<p>Deems a match if the attribute value is valid XML and is semantically equal to the expected XML document. The underlying engine for determining XML equality is XMLUnit.</p> JavaJSON Java<pre><code>.withRequestBody(equalToXml(\"&lt;thing&gt;Hello&lt;/thing&gt;\"))\n</code></pre> JSON<pre><code>{\n\"request\": {\n    ...\n    \"bodyPatterns\" : [ {\n    \"equalToXml\" : \"&lt;thing&gt;Hello&lt;/thing&gt;\"\n    } ]\n    ...\n},\n...\n}\n</code></pre>"},{"location":"stubbing_and_verifying/request_matching/#use-of-placeholders","title":"Use of placeholders","text":"<p>The XMLUnit placeholders feature is supported in WireMock. For example, when comparing the XML documents, you can ignore some text nodes.</p> JavaJSON Java<pre><code>.withRequestBody(\n    equalToXml(\"&lt;message&gt;&lt;id&gt;${xmlunit.ignore}&lt;/id&gt;&lt;content&gt;Hello&lt;/content&gt;&lt;/message&gt;\", true)\n)\n</code></pre> JSON<pre><code>{\n\"request\": {\n    ...\n    \"bodyPatterns\" : [ {\n    \"equalToXml\" : \"&lt;message&gt;&lt;id&gt;${xmlunit.ignore}&lt;/id&gt;&lt;content&gt;Hello&lt;/content&gt;&lt;/message&gt;\",\n    \"enablePlaceholders\" : true\n    } ]\n    ...\n},\n...\n}\n</code></pre> <p>When the actual request body is <code>&lt;message&gt;&lt;id&gt;123456&lt;/id&gt;&lt;content&gt;Hello&lt;/content&gt;&lt;/message&gt;</code>, it will be deemed a match.</p> <p>If the default placeholder delimiters <code>${</code> and <code>}</code> can not be used, you can specify custom delimiters (using regular expressions). For example:</p> JavaJSON Java<pre><code>.withRequestBody(\n    equalToXml(\"&lt;message&gt;&lt;id&gt;[[xmlunit.ignore]]&lt;/id&gt;&lt;content&gt;Hello&lt;/content&gt;&lt;/message&gt;\",\n            true,\n            \"\\\\[\\\\[\",\n            \"]]\"\n    )\n)\n</code></pre> JSON<pre><code>{\n\"request\": {\n    ...\n    \"bodyPatterns\" : [ {\n    \"equalToXml\" : \"&lt;message&gt;&lt;id&gt;[[xmlunit.ignore]]&lt;/id&gt;&lt;content&gt;Hello&lt;/content&gt;&lt;/message&gt;\",\n    \"enablePlaceholders\" : true,\n    \"placeholderOpeningDelimiterRegex\" : \"\\\\[\\\\[\",\n    \"placeholderClosingDelimiterRegex\" : \"]]\"\n    } ]\n    ...\n},\n...\n}\n</code></pre>"},{"location":"stubbing_and_verifying/request_matching/#excluding-specific-types-of-comparison","title":"Excluding specific types of comparison","text":"<p>You can further tune how XML documents are compared for equality by disabling specific XMLUnit comparison types.</p> JavaJSON Java<pre><code>import static org.xmlunit.diff.ComparisonType.*;\n\n...\n\n.withRequestBody(equalToXml(\"&lt;thing&gt;Hello&lt;/thing&gt;\")\n    .exemptingComparisons(NAMESPACE_URI, ELEMENT_TAG_NAME)\n)\n</code></pre> JSON<pre><code>{\n\"request\": {\n    ...\n    \"bodyPatterns\" : [ {\n    \"equalToXml\" : \"&lt;thing&gt;Hello&lt;/thing&gt;\",\n    \"exemptedComparisons\": [\"NAMESPACE_URI\", \"ELEMENT_TAG_NAME\"]\n    } ]\n    ...\n},\n...\n}\n</code></pre> <p>The full list of comparison types used by default is as follows:</p> <p><code>ELEMENT_TAG_NAME</code> <code>SCHEMA_LOCATION</code> <code>NO_NAMESPACE_SCHEMA_LOCATION</code> <code>NODE_TYPE</code> <code>NAMESPACE_PREFIX</code> <code>NAMESPACE_URI</code> <code>TEXT_VALUE</code> <code>PROCESSING_INSTRUCTION_TARGET</code> <code>PROCESSING_INSTRUCTION_DATA</code> <code>ELEMENT_NUM_ATTRIBUTES</code> <code>ATTR_VALUE</code> <code>CHILD_NODELIST_LENGTH</code> <code>CHILD_LOOKUP</code> <code>ATTR_NAME_LOOKUP</code></p>"},{"location":"stubbing_and_verifying/request_matching/#same-child-nodes-with-different-content","title":"Same child nodes with different content","text":"<p>By default, WireMock takes into account an order of identical child nodes. Meaning if actual request has different order of same node on same level than stub it won't be matched. As of WireMock version <code>3.7.0</code>, this can be changed by passing additional argument to the <code>equalToXml</code> method</p> JavaJSON Java<pre><code>    .withRequestBody(equalToXml(\"&lt;body&gt;\" +\n            \"   &lt;entry&gt;1&lt;/entry&gt;\" +\n            \"   &lt;entry&gt;2&lt;/entry&gt;\" +\n            \"&lt;/body&gt;\",false,true))\n</code></pre> JSON<pre><code>{\n\"request\": {\n    ...\n    \"bodyPatterns\" : [ {\n    \"equalToXml\" : \"&lt;body&gt;&lt;entry&gt;1&lt;/entry&gt;&lt;entry&gt;2&lt;/entry&gt;&lt;/body&gt;\",\n    \"ignoreOrderOfSameNode\": true\n    } ]\n    ...\n},\n...\n}\n</code></pre> <p>This will make sure that stub above matches both of following requests: XML<pre><code>&lt;body&gt;\n    &lt;entry&gt;2&lt;/entry&gt;\n    &lt;entry&gt;1&lt;/entry&gt;\n&lt;/body&gt;\n</code></pre> and  XML<pre><code>&lt;body&gt;\n    &lt;entry&gt;1&lt;/entry&gt;\n    &lt;entry&gt;2&lt;/entry&gt;\n&lt;/body&gt;\n</code></pre> If third argument is passed as <code>false</code> then first xml will not match the stub</p>"},{"location":"stubbing_and_verifying/request_matching/#namespace-awareness","title":"Namespace awareness","text":"<p>To configure how XML namespaces are handled, as of WireMock  <code>3.12.0</code>, the <code>namespaceAwareness</code> property can be set.</p> Java Java<pre><code>    .withRequestBody(equalToXml(\"&lt;body&gt;\" +\n            \"   &lt;entry&gt;1&lt;/entry&gt;\" +\n            \"   &lt;entry&gt;2&lt;/entry&gt;\" +\n            \"&lt;/body&gt;\").withNamespaceAwareness(EqualToXmlPattern.NamespaceAwareness.STRICT))\n</code></pre> JSON JSON<pre><code>{\n\"request\": {\n    ...\n    \"bodyPatterns\" : [ {\n    \"equalToXml\" : \"&lt;body&gt;&lt;entry&gt;1&lt;/entry&gt;&lt;entry&gt;2&lt;/entry&gt;&lt;/body&gt;\",\n    \"namespaceAwareness\": \"STRICT\"\n    } ]\n    ...\n},\n...\n}\n</code></pre> <p>The available options for namespace awareness behaviour are <code>STRICT</code>, <code>NONE</code> and <code>LEGACY</code>.</p> <p><code>STRICT</code> adheres to strict XML namespace comparison. Namespace prefixes must be bound to a namespace URI. Namespace prefixes as well as namespace URIs must match (for both elements and attributes), unless explicitly excluded by the <code>exemptedComparisons</code> parameter.</p> <p><code>NONE</code> does not consider XML namespaces when reading and comparing XML documents. Namespace prefixes do not need to be bound to a namespace URI and are not considered a separate part of an element/attribute name (i.e. the entire element/attribute name must match, not just the local name, regardless of the <code>exemptedComparisons</code> parameter). <code>xmlns</code> namespaced attributes are treated no differently to any other attribute.</p> <p><code>LEGACY</code> is not recommended and is only kept as an option for backwards compatibility.</p>"},{"location":"stubbing_and_verifying/request_matching/#xpath","title":"XPath","text":"<p>Deems a match if the attribute value is valid XML and matches the XPath expression supplied. An XML document will be considered to match if any elements are returned by the XPath evaluation. WireMock delegates to Java's in-built XPath engine (via XMLUnit), therefore up to (at least) Java 8 it supports XPath version 1.0.</p> JavaJSON Java<pre><code>.withRequestBody(matchingXPath(\"/todo-list[count(todo-item) = 3]\"))\n</code></pre> JSON<pre><code>{\n\"request\": {\n    ...\n    \"bodyPatterns\" : [ {\n    \"matchesXPath\" : \"/todo-list[count(todo-item) = 3]\"\n    } ]\n    ...\n},\n...\n}\n</code></pre> <p>The above example will select elements based on their local name if used with a namespaced XML document.</p> <p>If you need to be able to select elements based on their namespace in addition to their name you can declare the prefix to namespace URI mappings and use them in your XPath expression:</p> JavaJSON Java<pre><code>.withRequestBody(matchingXPath(\"/stuff:outer/more:inner[.=111]\")\n.withXPathNamespace(\"stuff\", \"http://stuff.example.com\")\n.withXPathNamespace(\"more\", \"http://more.example.com\"))\n</code></pre> JSON<pre><code>{\n\"request\": {\n    ...\n    \"bodyPatterns\" : [ {\n    \"matchesXPath\" : \"/stuff:outer/more:inner[.=111]\",\n    \"xPathNamespaces\" : {\n        \"stuff\" : \"http://stuff.example.com\",\n        \"more\"  : \"http://more.example.com\"\n    }\n    } ]\n    ...\n},\n...\n}\n</code></pre>"},{"location":"stubbing_and_verifying/request_matching/#nested-value-matching_1","title":"Nested value matching","text":"<p>The XPath matcher described above can be combined with another matcher, such that the value returned from the XPath query is evaluated against it:</p> JavaJSON Java<pre><code>.withRequestBody(matchingXPath(\"//todo-item/text()\", containing(\"wash\")))\n</code></pre> JSON<pre><code>{\n\"request\": {\n    ...\n    \"bodyPatterns\" : [ {\n    \"matchesXPath\" : {\n        \"expression\": \"//todo-item/text()\",\n        \"contains\": \"wash\"\n    }\n    } ]\n    ...\n},\n...\n}\n</code></pre> <p>If multiple nodes are returned from the XPath query, all will be evaluated and the returned match will be the one with the shortest distance.</p> <p>If the XPath expression returns an XML element rather than a value, this will be rendered as an XML string before it is passed to the value matcher. This can be usefully combined with the <code>equalToXml</code> matcher e.g.</p> JavaJSON Java<pre><code>.withRequestBody(matchingXPath(\"//todo-item\", equalToXml(\"&lt;todo-item&gt;Do the washing&lt;/todo-item&gt;\")))\n</code></pre> JSON<pre><code>{\n\"request\": {\n    ...\n    \"bodyPatterns\" : [ {\n    \"matchesXPath\" : {\n        \"expression\": \"//todo-item\",\n        \"equalToXml\": \"&lt;todo-item&gt;Do the washing&lt;/todo-item&gt;\"\n    }\n    } ]\n    ...\n},\n...\n}\n</code></pre>"},{"location":"stubbing_and_verifying/request_matching/#absence","title":"Absence","text":"<p>Deems a match if the attribute specified is absent from the request.</p> JavaJSON Java<pre><code>.withCookie(\"session\", absent())\n.withQueryParam(\"search_term\", absent())\n.withHeader(\"X-Absent\", absent())\n</code></pre> JSON<pre><code>{\n\"request\": {\n    ...\n    \"headers\" : {\n    \"X-Absent\" : {\n        \"absent\" : true\n    }\n    },\n    \"queryParameters\" : {\n    \"search_term\" : {\n        \"absent\" : true\n    }\n    },\n    \"cookies\" : {\n    \"session\" : {\n        \"absent\" : true\n    }\n    }\n    ...\n},\n...\n}\n</code></pre>"},{"location":"stubbing_and_verifying/request_matching/#multipartform-data","title":"Multipart/form-data","text":"<p>Deems a match if a multipart value is valid and matches any or all the multipart pattern matchers supplied. As a Multipart is a 'mini' HTTP request in itself all existing Header and Body content matchers can by applied to a Multipart pattern. A Multipart pattern can be defined as matching <code>ANY</code> request multiparts or <code>ALL</code>. The default matching type is <code>ANY</code>.</p> JavaJSON Java<pre><code>stubFor(...)\n...\n.withMultipartRequestBody(\n    aMultipart()\n        .withName(\"info\")\n        .withHeader(\"Content-Type\", containing(\"charset\"))\n        .withMultipartBody(equalToJson(\"{}\"))\n)\n</code></pre> JSON<pre><code>{\n\"request\": {\n    ...\n    \"multipartPatterns\" : [ {\n    \"matchingType\" : \"ANY\",\n    \"headers\" : {\n        \"Content-Disposition\" : {\n        \"contains\" : \"name=\\\"info\\\"\"\n        },\n        \"Content-Type\" : {\n        \"contains\" : \"charset\"\n        }\n    },\n    \"bodyPatterns\" : [ {\n        \"equalToJson\" : \"{}\"\n    } ]\n    } ],\n    ...\n},\n...\n}\n</code></pre>"},{"location":"stubbing_and_verifying/request_matching/#basic-authentication","title":"Basic Authentication","text":"<p>Although matching on HTTP basic authentication could be supported via a correctly encoded <code>Authorization</code> header, you can also do this more simply via the API.</p> JavaJSON Java<pre><code>stubFor(get(urlEqualTo(\"/basic-auth\")).withBasicAuth(\"user\", \"pass\")\n</code></pre> JSON<pre><code>{\n    \"request\": {\n        \"method\": \"GET\",\n        \"url\": \"/basic-auth\",\n        \"basicAuth\": {\n            \"username\": \"user\",\n            \"password\": \"pass\"\n        }\n    },\n    \"response\": {\n        \"status\": 200\n    }\n}\n</code></pre>"},{"location":"stubbing_and_verifying/request_matching/#dates-and-times","title":"Dates and times","text":"<p>Dates and times can be matched in several ways. Three comparison operators are available: <code>before</code>, <code>after</code> and <code>equalToDateTime</code>, all of which have the same set of parameters.</p> <p>Additionally, the expected value can be either literal (fixed) or an offset from the current date. Both the expected and actual dates can be truncated in various ways.</p>"},{"location":"stubbing_and_verifying/request_matching/#literal-datetimes","title":"Literal date/times","text":"<p>You can match an incoming date/time against a fixed value e.g. \"match if the X-Munged-Date request header is after x\":</p> JavaJSON Java<pre><code>stubFor(post(\"/dates\")\n.withHeader(\"X-Munged-Date\", after(\"2021-05-01T00:00:00Z\"))\n.willReturn(ok()));\n\n// You can also use a ZonedDateTime or LocalDateTime object\nstubFor(post(\"/dates\")\n.withHeader(\"X-Munged-Date\", after(ZonedDateTime.parse(\"2021-05-01T00:00:00Z\")))\n.willReturn(ok()));\n</code></pre> JSON<pre><code>{\n    \"request\": {\n        \"url\": \"/dates\",\n        \"method\": \"POST\",\n        \"headers\": {\n            \"X-Munged-Date\": {\n                \"after\": \"2021-05-01T00:00:00Z\"\n            }\n        }\n    },\n    \"response\": {\n        \"status\": 200\n    }\n}\n</code></pre>"},{"location":"stubbing_and_verifying/request_matching/#offset","title":"Offset","text":"<p>You can also match in incoming value against the current date/time or an offset from it:</p> JavaJSON Java<pre><code>stubFor(post(\"/dates\")\n.withHeader(\"X-Munged-Date\", beforeNow().expectedOffset(3, DateTimeUnit.DAYS))\n.withHeader(\"X-Finalised-Date\", before(\"now +2 months\")) // This form and beforeNow() are equivalent\n.willReturn(ok()));\n</code></pre> JSON<pre><code>{\n    \"request\": {\n        \"url\": \"/dates\",\n        \"method\": \"POST\",\n        \"headers\": {\n            \"X-Munged-Date\": {\n                \"before\": \"now +3 days\"\n            },\n            \"X-Finalised-Date\": {\n                // This is equivalent to \"now +2 months\"\n                \"before\": \"now\",\n                \"expectedOffset\": 2,\n                \"expectedOffsetUnit\": \"months\"\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"stubbing_and_verifying/request_matching/#local-vs-zoned","title":"Local vs. Zoned","text":"<p>Both the expected and actual date/time values can either have timezone information or not. For instance a date in ISO8601 format could be zoned: <code>2021-06-24T13:40:27+01:00</code> or <code>2021-06-24T12:40:27Z</code>, or local: <code>2021-06-24T12:40:27</code>.</p> <p>Likewise a date/time in RFC 1123 (HTTP standard) format is also zoned: <code>Tue, 01 Jun 2021 15:16:17 GMT</code>.</p> <p>Whether the expected and actual values are zoned or not affects whether they can be matched and how. Generally, the best approach is to try to ensure you're using the same on both sides - if you're expected a zoned actual date, then use one as the expected date also, plus the equivalent for local dates.</p> <p>If the expected date is zoned and the actual is local, the actual date will assume the system timezone before the comparison is attempted.</p> <p>If the expected date is local and the actual is zoned, the timezone will be stripped from the actual value before the comparison is attempted.</p>"},{"location":"stubbing_and_verifying/request_matching/#date-formats","title":"Date formats","text":"<p>By default these matchers will attempt to parse date/times in ISO8601 format, plus the three standard formats defined by HTTP RFCs 1123, 1036 and asctime (taken from C but also valid for specifying HTTP dates).</p> <p>It is also possible to specify your own format using Java's date format strings.</p> JavaJSON Java<pre><code>stubFor(post(\"/dates\")\n.withHeader(\"X-Munged-Date\",\n    equalToDateTime(\"2021-06-24T00:00:00\").actualFormat(\"dd/MM/yyyy\"))\n.willReturn(ok()));\n</code></pre> JSON<pre><code>{\n    \"request\": {\n        \"url\": \"/dates\",\n        \"method\": \"POST\",\n        \"headers\": {\n            \"X-Munged-Date\": {\n                \"equalToDateTime\": \"2021-06-24T00:00:00\",\n                \"actualFormat\": \"dd/MM/yyyy\"\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"stubbing_and_verifying/request_matching/#truncation","title":"Truncation","text":"<p>Both the expected and actual date/times can be truncated in various ways e.g. to the first hour of the day. When using offset from now as the expected date with truncation, the truncation will be applied first followed by the offsetting.</p> <p>Truncation is useful if you want to create expressions like \"before the end of this month\" or \"equal to the current hour\".</p> <p>It can usefully be combined with offsetting so e.g. if the match required is \"after the 15th of this month\" we could do as follows.</p> JavaJSON Java<pre><code>stubFor(post(\"/dates\")\n.withRequestBody(matchingJsonPath(\n    \"$.completedDate\",\n    after(\"now +15 days\").truncateExpected(FIRST_DAY_OF_MONTH))\n)\n.willReturn(ok()));\n</code></pre> JSON<pre><code>{\n    \"request\": {\n        \"url\": \"/dates\",\n        \"method\": \"POST\",\n        \"bodyPatterns\": [\n            {\n                \"matchesJsonPath\": {\n                    \"expression\": \"$.completedDate\",\n                    \"after\": \"now +15 days\",\n                    \"truncateExpected\": \"first day of month\"\n                }\n            }\n        ]\n    }\n}\n</code></pre> <p>Truncating the actual value can be useful when checking for equality with literal date/times e.g. to say \"is in March 2020\":</p> JavaJSON Java<pre><code>stubFor(post(\"/dates\")\n.withRequestBody(matchingJsonPath(\n    \"$.completedDate\",\n    equalToDateTime(\"2020-03-01T00:00:00Z\").truncateActual(FIRST_DAY_OF_MONTH))\n)\n.willReturn(ok()));\n</code></pre> JSON<pre><code>{\n    \"request\": {\n        \"url\": \"/dates\",\n        \"method\": \"POST\",\n        \"bodyPatterns\": [\n            {\n                \"matchesJsonPath\": {\n                    \"expression\": \"$.completedDate\",\n                    \"equalToDateTime\": \"2020-03-01T00:00:00Z\",\n                    \"truncateActual\": \"first day of month\"\n                }\n            }\n        ]\n    }\n}\n</code></pre> <p>The full list of available truncations is:</p> <ul> <li><code>first minute of hour</code></li> <li><code>first hour of day</code></li> <li><code>first day of month</code></li> <li><code>first day of next month</code></li> <li><code>last day of month</code></li> <li><code>first day of year</code></li> <li><code>first day of next year</code></li> <li><code>last day of year</code></li> </ul>"},{"location":"stubbing_and_verifying/request_matching/#order-of-applying-offset-and-truncation","title":"Order of applying offset and truncation","text":"<p>By default, the date/time truncation is applied first and the offset is applied afterwards. There are scenarios, though, where the order needs to be reversed. For instance, if we want to match with the last day of the next month then the truncation should be applied last. In this case the boolean property <code>applyTruncationLast</code> should be set to true:</p> JavaJSON Java<pre><code>stubFor(get(urlPathEqualTo(\"/resource\"))\n.withQueryParam(\"date\", equalToDateTime(\"now +1 months\").truncateExpected(LAST_DAY_OF_MONTH).applyTruncationLast(true))\n.willReturn(ok()));\n</code></pre> JSON<pre><code>{\n    \"request\": {\n        \"urlPath\": \"/resource\",\n        \"method\": \"GET\",\n        \"queryParameters\": {\n            \"date\": {\n                \"equalToDateTime\": \"now +1 months\",\n                \"truncateExpected\": \"last day of month\",\n                \"applyTruncationLast\": true\n            }\n        }\n    }\n}\n</code></pre> <p>In the example above setting the <code>applyTruncationLast</code> property to true means that the expected date/time value will first be offset by one month and only afterwards truncated to the last day of that month. Which in turn means that if the current date is September 1st then the expected date will first be offset to October 1st and only then truncated to October 31st. Had the <code>applyTruncationLast</code> property been false (the default value) then the resulting expected date would be October 30th, one day off the date we were aiming for. </p>"},{"location":"stubbing_and_verifying/request_matching/#logical-and-and-or","title":"Logical AND and OR","text":"<p>You can combine two or more matchers in an AND expression.</p> JavaJSON Java<pre><code>// Both statements are equivalent\n\nstubFor(get(urlPathEqualTo(\"/and\"))\n    .withHeader(\"X-Some-Value\", and(\n        matching(\"[a-z]+\"),\n        containing(\"magicvalue\"))\n    )\n    .willReturn(ok()));\n\nstubFor(get(urlPathEqualTo(\"/and\"))\n    .withHeader(\"X-Some-Value\", matching(\"[a-z]+\").and(containing(\"magicvalue\")))\n    .willReturn(ok()));\n</code></pre> JSON<pre><code>{\n    \"request\": {\n        \"urlPath\": \"/and\",\n        \"method\": \"GET\",\n        \"headers\": {\n            \"X-Some-Value\": {\n                \"and\": [\n                    {\n                        \"matches\": \"[a-z]+\"\n                    },\n                    {\n                        \"contains\": \"magicvalue\"\n                    }\n                ]\n            }\n        }\n    }\n}\n</code></pre> <p>Similarly you can also construct an OR expression.</p> JavaJSON Java<pre><code>// Both statements are equivalent\n\nstubFor(get(urlPathEqualTo(\"/or\"))\n.withQueryParam(\"search\", or(\n        matching(\"[a-z]+\"),\n        absent())\n)\n.willReturn(ok()));\n\nstubFor(get(urlPathEqualTo(\"/or\"))\n    .withQueryParam(\"search\", matching(\"[a-z]+\").or(absent()))\n    .willReturn(ok()));\n</code></pre> JSON<pre><code>{\n    \"request\": {\n        \"urlPath\": \"/or\",\n        \"method\": \"GET\",\n        \"queryParameters\": {\n            \"search\": {\n                \"or\": [\n                    {\n                        \"matches\": \"[a-z]+\"\n                    },\n                    {\n                        \"absent\": true\n                    }\n                ]\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"stubbing_and_verifying/request_matching/#combining-date-matchers-as-jsonpathxpath-sub-matchers","title":"Combining date matchers as JSONPath/XPath sub-matchers","text":"<p>As an example of how various matchers can be combined, suppose we want to match if a field named <code>date</code> in a JSON request body is a date/time between two points.</p> <p>We can do this by extracting the field using <code>matchesJsonPath</code> then matching the result of this against the <code>before</code> and <code>after</code> matchers AND'd together.</p> JavaJSON Java<pre><code>stubFor(post(\"/date-range\")\n    .withRequestBody(matchingJsonPath(\"$.date\",\n        before(\"2022-01-01T00:00:00\").and(\n        after(\"2020-01-01T00:00:00\"))))\n    .willReturn(ok()));\n</code></pre> JSON<pre><code>{\n    \"request\": {\n        \"url\": \"/date-range\",\n        \"method\": \"POST\",\n        \"bodyPatterns\": [\n            {\n                \"matchesJsonPath\": {\n                    \"expression\": \"$.date\",\n                    \"and\": [\n                        {\n                            \"before\": \"2022-01-01T00:00:00\"\n                        },\n                        {\n                            \"after\": \"2020-01-01T00:00:00\"\n                        }\n                    ]\n                }\n            }\n        ]\n    }\n}\n</code></pre> <p>This would match the following JSON request body:</p> JSON<pre><code>{\n    \"date\": \"2021-01-01T00:00:00\"\n}\n</code></pre>"},{"location":"stubbing_and_verifying/request_matching/#matching-headerquery-parameter-containing-multiple-values","title":"Matching Header/Query parameter containing multiple values","text":"<p>You can match multiple values of a query parameter or header with below provided matchers.</p> <p>Exactly matcher exactly matches multiple values or patterns and make sure that it does not contain any other value.</p> <p>There must be 3 values of id exactly whose values are 1, 2, and 3:</p> JavaJSON Java<pre><code>stubFor(get(urlPathEqualTo(\"/things\"))\n    .withQueryParam(\"id\", havingExactly(\"1\", \"2\", \"3\"))\n    .willReturn(ok()));\n</code></pre> JSON<pre><code>{\n\"mapping\": {\n    \"request\" : {\n    \"urlPath\" : \"/things\",\n    \"method\" : \"GET\",\n    \"queryParameters\" : {\n        \"id\" : {\n        \"hasExactly\" : [\n            {\n            \"equalTo\": \"1\"\n            },\n            {\n            \"equalTo\": \"2\"\n            },\n            {\n            \"equalTo\": \"3\"\n            }\n        ]\n        }\n    }\n    },\n    \"response\" : {\n    \"status\" : 200\n    }\n}\n}\n</code></pre> <p>There must be 3 values of id exactly whose values conform to the match expressions</p> JavaJSON Java<pre><code>stubFor(get(urlPathEqualTo(\"/things\"))\n    .withQueryParam(\"id\", havingExactly(\n        equalTo(\"1\"),\n        containing(\"2\"),\n        notContaining(\"3\")\n    )).willReturn(ok()));\n</code></pre> JSON<pre><code>{\n\"mapping\": {\n    \"request\" : {\n    \"urlPath\" : \"/things\",\n    \"method\" : \"GET\",\n    \"queryParameters\" : {\n        \"id\" : {\n        \"hasExactly\" : [\n            {\n            \"equalTo\": \"1\"\n            },\n            {\n            \"contains\": \"2\"\n            },\n            {\n            \"doesNotContain\": \"3\"\n            }\n        ]\n        }\n    }\n    },\n    \"response\" : {\n    \"status\" : 200\n    }\n}\n}\n</code></pre> <p>Includes matcher matches multiple values or patterns specified and may contain other values as well.</p> <p>The values of id must include 1, 2, and 3:</p> JavaJSON Java<pre><code>stubFor(get(urlPathEqualTo(\"/things\"))\n    .withQueryParam(\"id\", including(\"1\", \"2\", \"3\")) \n    .willReturn(ok()));\n</code></pre> JSON<pre><code>{\n\"mapping\": {\n    \"request\" : {\n    \"urlPath\" : \"/things\",\n    \"method\" : \"GET\",\n    \"queryParameters\" : {\n        \"id\" : {\n        \"includes\" : [\n            {\n            \"equalTo\": \"1\"\n            },\n            {\n            \"equalTo\": \"2\"\n            },\n            {\n            \"equalTo\": \"3\"\n            }\n        ]\n        }\n    }\n    },\n    \"response\" : {\n    \"status\" : 200\n    }\n}\n}\n</code></pre> <p>Values of id must conform to the match expressions:</p> JavaJSON Java<pre><code>stubFor(get(urlPathEqualTo(\"/things\"))\n    .withQueryParam(\"id\", including(\n        equalTo(\"1\"),\n        containing(\"2\"),\n        notContaining(\"3\")\n    )).willReturn(ok()));\n</code></pre> JSON<pre><code>{\n\"mapping\": {\n    \"request\" : {\n    \"urlPath\" : \"/things\",\n    \"method\" : \"GET\",\n    \"queryParameters\" : {\n        \"id\" : {\n        \"includes\" : [\n            {\n            \"equalTo\": \"1\"\n            },\n            {\n            \"contains\": \"2\"\n            },\n            {\n            \"doesNotContain\": \"3\"\n            }\n        ]\n        }\n    }\n    },\n    \"response\" : {\n    \"status\" : 200\n    }\n}\n}\n</code></pre>"},{"location":"stubbing_and_verifying/request_matching/#logical-not-negating-matchers","title":"Logical NOT - negating matchers","text":"<p>You can negate any matcher using the logical NOT matcher.</p> JavaJSON Java<pre><code>stubFor(\n    get(urlPathEqualTo(\"/not\"))\n    .withHeader(\"X-Some-Value\", not(matching(\"[a-z]+\")))\n    .willReturn(ok()));\n</code></pre> JSON<pre><code>{\n    \"request\": {\n        \"urlPath\": \"/and\",\n        \"method\": \"GET\",\n        \"headers\": {\n            \"X-Some-Value\": {\n                \"not\": {\n                \"matches\": \"[a-z]+\"\n                }\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"stubbing_and_verifying/response_templating/","title":"Response Templating","text":"<p>Documentation / stubbing_and_verifying / response_templating </p> <p>Response headers and bodies, as well as proxy URLs, can optionally be rendered using Handlebars templates. This enables attributes of the request to be used in generating the response e.g. to pass the value of a request ID header as a response header or render an identifier from part of the URL in the response body.</p>"},{"location":"stubbing_and_verifying/response_templating/#enablingdisabling-response-templating","title":"Enabling/disabling response templating","text":"<p>Response templating is enabled by default in local mode when WireMock is started programmatically, meaning that it will only be applied to stubs that have the <code>response-template</code> transformer added to them (see below for details).</p> <p>Templating can be applied globally (without having to explicitly add <code>response-template</code>) via a startup option:</p> Java<pre><code>WireMockServer wm =\n    new WireMockServer(options().globalTemplating(true));\n</code></pre> <p>It can also be disabled completely via a startup option:</p> Java<pre><code>WireMockServer wm =\n    new WireMockServer(options().templatingEnabled(false));\n</code></pre> <p>See the command line docs for the standalone equivalents of these parameters.</p> <p>Response templating can also be disabled on a per-stub basis when using the <code>bodyFileName</code> element by adding the  <code>disableBodyFileTemplating</code> parameter to the <code>transformerParameters</code> object in the stub response definition.</p> JSON<pre><code>{\n  \"request\": {\n    \"method\": \"GET\",\n    \"urlPath\": \"/test\"\n  },\n  \"response\": {\n    \"status\": 200,\n    \"bodyFileName\": \"response.json\",\n    \"transformerParameters\": {\n      \"disableBodyFileTemplating\": true\n    }\n  }\n}\n</code></pre>"},{"location":"stubbing_and_verifying/response_templating/#customising-and-extending-the-template-engine","title":"Customising and extending the template engine","text":"<p>Custom Handlebars helpers can be registered via an extension point. See Adding Template Helpers for details.</p> <p>Similarly custom model data providers can be registered as extensions. See Adding Template Model Data for details.</p>"},{"location":"stubbing_and_verifying/response_templating/#applying-templating-in-local-mode","title":"Applying templating in local mode","text":"<p>When templating is enabled in local mode you must add it to each stub to which you require templating to be applied. This is done by adding <code>response-template</code> to the set of transformers on the response.</p>"},{"location":"stubbing_and_verifying/response_templating/#java","title":"Java","text":"Java<pre><code>wm.stubFor(get(urlPathEqualTo(\"/templated\"))\n  .willReturn(aResponse()\n      .withBody(\"{{request.path.[0]}}\")\n      .withTransformers(\"response-template\")));\n</code></pre>"},{"location":"stubbing_and_verifying/response_templating/#json","title":"JSON","text":"JSON<pre><code>{\n    \"request\": {\n        \"urlPath\": \"/templated\"\n    },\n    \"response\": {\n        \"body\": \"{{request.path.[0]}}\",\n        \"transformers\": [\"response-template\"]\n    }\n}\n</code></pre>"},{"location":"stubbing_and_verifying/response_templating/#template-caching","title":"Template caching","text":"<p>All templated fragments (headers, bodies and proxy URLs) are cached in their compiled form for performance, since compilation can be expensive for larger templates.</p> <p>By default the capacity of this cache is not limited but a limit can be set via the startup options:</p> Java<pre><code>WireMockServer wm =\n    new WireMockServer(options().withMaxTemplateCacheEntries(10000));\n</code></pre> <p>See the command line docs for the equivalent configuration setting when running standalone.</p>"},{"location":"stubbing_and_verifying/response_templating/#proxying","title":"Proxying","text":"<p>Templating also works when defining proxy URLs, e.g.</p>"},{"location":"stubbing_and_verifying/response_templating/#java_1","title":"Java","text":"Java<pre><code>wm.stubFor(get(urlPathEqualTo(\"/templated\"))\n  .willReturn(aResponse()\n      .proxiedFrom(\"{{request.headers.X-WM-Proxy-Url}}\")\n      .withTransformers(\"response-template\")));\n</code></pre>"},{"location":"stubbing_and_verifying/response_templating/#json_1","title":"JSON","text":"JSON<pre><code>{\n    \"request\": {\n        \"urlPath\": \"/templated\"\n    },\n    \"response\": {\n        \"proxyBaseUrl\": \"{{request.headers.X-WM-Proxy-Url}}\",\n        \"transformers\": [\"response-template\"]\n    }\n}\n</code></pre>"},{"location":"stubbing_and_verifying/response_templating/#templated-body-file","title":"Templated body file","text":"<p>The body file for a response can be selected dynamically by templating the file path:</p>"},{"location":"stubbing_and_verifying/response_templating/#java_2","title":"Java","text":"Java<pre><code>wm.stubFor(get(urlPathMatching(\"/static/.*\"))\n  .willReturn(ok()\n    .withBodyFile(\"files/{{request.pathSegments.[1]}}\")));\n</code></pre>"},{"location":"stubbing_and_verifying/response_templating/#json_2","title":"JSON","text":"JSON<pre><code>{\n    \"request\": {\n        \"urlPathPattern\": \"/static/.*\",\n        \"method\": \"GET\"\n    },\n    \"response\": {\n        \"status\": 200,\n        \"bodyFileName\": \"files/{{request.pathSegments.[1]}}\"\n    }\n}\n</code></pre>"},{"location":"stubbing_and_verifying/response_templating/#the-request-model","title":"The request model","text":"<p>The model of the request is supplied to the header and body templates. The following request attributes are available:</p> <p><code>request.id</code> - The unique ID of each request (introduced in WireMock version <code>3.7.0</code>)</p> <p><code>request.url</code> - URL path and query</p> <p><code>request.path</code> - URL path. This can be referenced in full or it can be treated as an array of path segments (like below) e.g. <code>request.path.3</code>. When the path template URL match type has been used you can additionally reference path variables by name e.g. <code>request.path.contactId</code>.</p> <p><code>request.pathSegments.[&lt;n&gt;]</code>- URL path segment (zero indexed) e.g. <code>request.pathSegments.2</code></p> <p><code>request.query.&lt;key&gt;</code>- First value of a query parameter e.g. <code>request.query.search</code></p> <p><code>request.query.&lt;key&gt;.[&lt;n&gt;]</code>- nth value of a query parameter (zero indexed) e.g. <code>request.query.search.5</code></p> <p><code>request.method</code>- request method e.g. <code>POST</code></p> <p><code>request.host</code>- hostname part of the URL e.g. <code>my.example.com</code></p> <p><code>request.port</code>- port number e.g. <code>8080</code></p> <p><code>request.scheme</code>- protocol part of the URL e.g. <code>https</code></p> <p><code>request.baseUrl</code>- URL up to the start of the path e.g. <code>https://my.example.com:8080</code></p> <p><code>request.headers.&lt;key&gt;</code>- First value of a request header e.g. <code>request.headers.X-Request-Id</code></p> <p><code>request.headers.[&lt;key&gt;]</code>- Header with awkward characters e.g. <code>request.headers.[$?blah]</code></p> <p><code>request.headers.&lt;key&gt;.[&lt;n&gt;]</code>- nth value of a header (zero indexed) e.g. <code>request.headers.ManyThings.1</code></p> <p><code>request.cookies.&lt;key&gt;</code> - First value of a request cookie e.g. <code>request.cookies.JSESSIONID</code></p> <p><code>request.cookies.&lt;key&gt;.[&lt;n&gt;]</code> - nth value of a request cookie e.g. <code>request.cookies.JSESSIONID.2</code></p> <p><code>request.body</code> - Request body text (avoid for non-text bodies)</p> <p><code>request.bodyAsBase64</code> - As of WireMock <code>3.8.0</code>, the Base64 representation of the request body.</p> <p><code>request.multipart</code> - As of WireMock <code>3.8.0</code>, if the request is a multipart request (boolean).</p> <p><code>request.parts</code> - As of WireMock <code>3.8.0</code>, the individual parts of a multipart request are exposed via the template model. Each part can be referenced by its name and exposes a number of properties in the template model.  For example,  a multipart request with a name of <code>text</code> has the following properties available: * <code>request.parts.text.binary</code> - if the part is a binary type. * <code>request.parts.text.headers.&lt;key&gt;</code> - first value of a part header - <code>request.parts.text.headers.content-type</code> * <code>request.parts.text.body</code> - part body as text. * <code>request.parts.text.bodyAsBase64</code> - part body as base64.</p>"},{"location":"stubbing_and_verifying/response_templating/#values-that-can-be-one-or-many","title":"Values that can be one or many","text":"<p>A number of HTTP elements (query parameters, form fields, headers) can be single or multiple valued. The template request model and built-in helpers attempt to make this easy to work with by wrapping these in a \"list or single\" type that returns the first (and often only) value when no index is specified, but also support index access.</p> <p>For instance, given a request URL like <code>/multi-query?things=1&amp;things=2&amp;things=3</code> I can extract the query data in the following ways:</p> Handlebars<pre><code>{{request.query.things}} // Will return 1\n{{request.query.things.0}} // Will return 1\n{{request.query.things.first}} // Will return 1\n{{request.query.things.1}} // Will return 2\n{{request.query.things.[-1]}} // Will return 2\n{{request.query.things.last}} // Will return 3\n</code></pre> <p>Note</p> <p>When using the <code>eq</code> helper with one-or-many values, it is necessary to use the indexed form, even if only one value is present. The reason for this is that the non-indexed form returns the wrapper type and not a String, and will therefore fail any comparison with another String value.</p>"},{"location":"stubbing_and_verifying/response_templating/#getting-values-with-keys-containing-special-characters","title":"Getting values with keys containing special characters","text":"<p>Certain characters have special meaning in Handlebars and therefore can't be used in key names when referencing values. If you need to access keys containing these characters you can use the <code>lookup</code> helper, which permits you to pass the key name as a string literal and thus avoid the restriction.</p> <p>Probably the most common occurrence of this issue is with array-style query parameters, so for instance if your request URLs you're matching are of the form <code>/stuff?ids[]=111&amp;ids[]=222&amp;ids[]=333</code> then you can access these values like:</p> Handlebars<pre><code>{{lookup request.query 'ids[].1'}} // Will return 222\n</code></pre>"},{"location":"stubbing_and_verifying/response_templating/#using-transformer-parameters","title":"Using transformer parameters","text":"<p>Parameter values can be passed to the transformer as shown below (or dynamically added to the parameters map programmatically in custom transformers).</p>"},{"location":"stubbing_and_verifying/response_templating/#java_3","title":"Java","text":"Java<pre><code>wm.stubFor(get(urlPathEqualTo(\"/templated\"))\n  .willReturn(aResponse()\n      .withBody(\"{{request.path.[0]}}\")\n      .withTransformers(\"response-template\")\n      .withTransformerParameter(\"MyCustomParameter\", \"Parameter Value\")));\n</code></pre>"},{"location":"stubbing_and_verifying/response_templating/#json_3","title":"JSON","text":"JSON<pre><code>{\n    \"request\": {\n        \"urlPath\": \"/templated\"\n    },\n    \"response\": {\n        \"body\": \"{{request.path.[0]}}\",\n        \"transformers\": [\"response-template\"],\n        \"transformerParameters\": {\n            \"MyCustomParameter\": \"Parameter Value\"\n        }\n    }\n}\n</code></pre> <p>These parameters can be referenced in template body content using the <code>parameters.</code> prefix:</p> Handlebars<pre><code>&lt;h1&gt;The MyCustomParameter value is {{parameters.MyCustomParameter}}&lt;/h1&gt;\n</code></pre>"},{"location":"stubbing_and_verifying/response_templating/#handlebars-helpers","title":"Handlebars helpers","text":"<p>All of the standard helpers (template functions) provided by the Java Handlebars implementation by jknack plus all of the string helpers and the conditional helpers are available e.g.</p> Handlebars<pre><code>{{capitalize request.query.search}}\n</code></pre>"},{"location":"stubbing_and_verifying/response_templating/#number-and-assignment-helpers","title":"Number and assignment helpers","text":"<p>Variable assignment and number helpers are available:</p> Handlebars<pre><code>{{#assign 'myCapitalisedQuery'}}{{capitalize request.query.search}}{{/assign}}\n\n{{isOdd 3}}\n{{isOdd 3 'rightBox'}}\n\n{{isEven 2}}\n{{isEven 4 'leftBox'}}\n\n{{stripes 3 'row-even' 'row-odd'}}\n</code></pre>"},{"location":"stubbing_and_verifying/response_templating/#val-helper","title":"Val helper","text":"<p>Released in WireMock version <code>3.6.0</code>, the <code>val</code> helper can be used to access values or provide a default if the value  is not present. It can also be used to assign a value to a variable much like the <code>assign</code> helper.  The main difference  between <code>val</code> and <code>assign</code> is that <code>val</code> will maintain the type of the date being assigned whereas <code>assign</code> will always  assign a string.</p> Handlebars<pre><code>{{val request.query.search or='default'}} // the value of request.query.search or 'default' if it's not present\n{{val request.query.search default='default'}} // the value of request.query.search or 'default' if it's not present\n{{val request.query.search}} // the value of request.query.search or null if it's not present\n{{val request.query.search or='default' assign='myVar'}} // assign the value of request.query.search or 'default' to myVar\n{{val request.query.search assign='myVar'}} // assign the value of request.query.search to myVar\n\n\n{{val (array 1 2 3) default='123'}} // [1, 2, 3]\n{{val 'value for myVar' assign='myVar'}}{{myVar}} // value for myVar\n{{val null or='other value for myVar' assign='myVar'}}{{myVar}} // other value for myVar\n{{val 10 assign='myVar'}}{{#lt myVar 20}}Less Than{{else}}More Than{{/lt}} // Less Than\n</code></pre>"},{"location":"stubbing_and_verifying/response_templating/#xpath-helpers","title":"XPath helpers","text":"<p>Additionally some helpers are available for working with JSON and XML.</p> <p>When the incoming request contains XML, the <code>xPath</code> helper can be used to extract values or sub documents via an XPath 1.0 expression. For instance, given the XML</p> XML<pre><code>&lt;outer&gt;\n    &lt;inner&gt;Stuff&lt;/inner&gt;\n&lt;/outer&gt;\n</code></pre> <p>The following will render \"Stuff\" into the output:</p> Handlebars<pre><code>{{xPath request.body '/outer/inner/text()'}}\n</code></pre> <p>And given the same XML the following will render <code>&lt;inner&gt;Stuff&lt;/inner&gt;</code>:</p> Handlebars<pre><code>{{xPath request.body '/outer/inner'}}\n</code></pre> <p>As a convenience the <code>soapXPath</code> helper also exists for extracting values from SOAP bodies e.g. for the SOAP document:</p> XML<pre><code>&lt;soap:Envelope xmlns:soap=\"http://www.w3.org/2003/05/soap-envelope/\"&gt;\n    &lt;soap:Body&gt;\n        &lt;m:a&gt;\n            &lt;m:test&gt;success&lt;/m:test&gt;\n        &lt;/m:a&gt;\n    &lt;/soap:Body&gt;\n&lt;/soap:Envelope&gt;\n</code></pre> <p>The following will render \"success\" in the output:</p> Handlebars<pre><code>{{soapXPath request.body '/a/test/text()'}}\n</code></pre>"},{"location":"stubbing_and_verifying/response_templating/#using-the-output-of-xpath-in-other-helpers","title":"Using the output of <code>xPath</code> in other helpers","text":"<p>Since version 2.27.0 the XPath helper returns collections of node objects rather than a single string, meaning that the result can be used in further helpers.</p> <p>The returned node objects have the following properties:</p> <p><code>name</code> - the local XML element name.</p> <p><code>text</code> - the text content of the element.</p> <p><code>attributes</code> - a map of the element's attributes (name: value)</p> <p>Referring to the node itself will cause it to be printed.</p> <p>A common use case for returned node objects is to iterate over the collection with the <code>each</code> helper:</p> Handlebars<pre><code>{{#each (xPath request.body '/things/item') as |node|}}\n  name: {{node.name}}, text: {{node.text}}, ID attribute: {{node.attributes.id}}\n{{/each}}\n</code></pre>"},{"location":"stubbing_and_verifying/response_templating/#format-xml-helper","title":"Format XML helper","text":"<p>Introduced in WireMock version <code>3.10.0</code>, the <code>formatXml</code> helper will rewrite the input XML into a format of your choice.</p> Handlebars<pre><code>{{#formatXml}}\n&lt;foo&gt;&lt;bar\n&gt;wh&lt;/bar&gt;&lt;/foo\n&gt;\n{{/formatXml}}\n</code></pre> <p>By default, the input will be rewritten to a \"pretty\" format (new lines and indentation):</p> XML<pre><code>&lt;foo&gt;\n    &lt;bar&gt;wh&lt;/bar&gt;\n&lt;/foo&gt;\n</code></pre> <p>The format can be controlled by supplying a <code>format</code> option:</p> Handlebars<pre><code>{{#formatXml format='compact'}}\n&lt;foo&gt;&lt;bar\n&gt;wh&lt;/bar&gt;&lt;/foo\n&gt;\n{{/formatXml}}\n</code></pre> <p>The available <code>format</code> options are <code>compact</code> (all whitespace removed) and <code>pretty</code>.</p> <p>The input XML can alternatively be supplied inline, or as a variable:</p> Handlebars<pre><code>{{formatXml ' &lt;foo&gt;  &lt;bar&gt;wh&lt;/bar&gt;  &lt;/foo&gt; '}}\n\n{{#assign 'someXml'}} &lt;foo&gt;  &lt;bar&gt;wh&lt;/bar&gt;  &lt;/foo&gt; {{/assign}}\n{{formatXml someXml format='compact'}}\n</code></pre>"},{"location":"stubbing_and_verifying/response_templating/#jsonpath-helper","title":"JSONPath helper","text":"<p>Like the <code>xPath</code> helper, it is similarly possible to extract JSON values or sub documents via JSONPath using the <code>jsonPath</code> helper. Given the JSON</p> JSON<pre><code>{\n    \"outer\": {\n        \"inner\": \"Stuff\"\n    }\n}\n</code></pre> <p>The following will render \"Stuff\" into the output:</p> Handlebars<pre><code>{{jsonPath request.body '$.outer.inner'}}\n</code></pre> <p>And for the same JSON the following will render <code>{ \"inner\": \"Stuff\" }</code>:</p> Handlebars<pre><code>{{jsonPath request.body '$.outer'}}\n</code></pre> <p>Default value can be specified if the path evaluates to null or undefined:</p> Handlebars<pre><code>{{jsonPath request.body '$.size' default='M'}}\n</code></pre>"},{"location":"stubbing_and_verifying/response_templating/#parse-json-helper","title":"Parse JSON helper","text":"<p>The <code>parseJson</code> helper will parse the input into a map-of-maps. It will assign the result to a variable if a name is specified, otherwise the result will be returned.</p> <p>It can accept the JSON from a block:</p> Handlebars<pre><code>{{#parseJson 'parsedObj'}}\n{\n  \"name\": \"transformed\"\n}\n{{/parseJson}}\n\n{{!- Now we can access the object as usual --}}\n{{parsedObj.name}}\n</code></pre> <p>Or as a parameter:</p> Handlebars<pre><code>{{parseJson request.body 'bodyJson'}}\n{{bodyJson.name}}\n</code></pre> <p>Without assigning to a variable:</p> Handlebars<pre><code>{{lookup (parseJson request.body) 'name'}}\n</code></pre>"},{"location":"stubbing_and_verifying/response_templating/#write-as-json-helper","title":"Write as JSON helper","text":"<p>Introduced in WireMock version <code>3.10.0</code>, the <code>toJson</code> helper will convert any object into a JSON string.</p> Handlebars<pre><code>{{toJson (array 1 2 3)}}\n</code></pre> <p>emits</p> JSON<pre><code>[ 1, 2, 3 ]\n</code></pre> <p>Given a request with the following headers:</p> Text Only<pre><code>Authorization: whatever\nContent-Type: text/plain\n</code></pre> Handlebars<pre><code>{{toJson request.headers}}\n</code></pre> <p>will produce</p> JSON<pre><code>{\n  \"Authorization\" : \"whatever\",\n  \"Content-Type\" : \"text/plain\"\n}\n</code></pre>"},{"location":"stubbing_and_verifying/response_templating/#format-json-helper","title":"Format JSON helper","text":"<p>As of WireMock version <code>3.10.0</code>, the <code>formatJson</code> helper will rewrite the input JSON into a format of your choice.</p> Handlebars<pre><code>{{#formatJson}}{\"foo\":true,\"bar\":{\"baz\":false}}{{/formatJson}}\n</code></pre> <p>By default, the input will be rewritten to a \"pretty\" format (new lines and indentation):</p> JSON<pre><code>{\n  \"foo\" : true,\n  \"bar\" : {\n    \"baz\" : false\n  }\n}\n</code></pre> <p>The format can be controlled by supplying a <code>format</code> option:</p> Handlebars<pre><code>{{#formatJson format='compact'}}\n{\n    \"foo\" : true,\n    \"bar\" : {\n        \"baz\" : false\n    }\n}\n{{/formatJson}}\n</code></pre> <p>The available <code>format</code> options are <code>compact</code> (all whitespace removed) and <code>pretty</code>.</p> <p>The input JSON can alternatively be supplied inline, or as a variable:</p> Handlebars<pre><code>{{formatJson '{\"foo\":true,\"bar\":{\"baz\":false}}'}}\n\n{{#assign 'someJson'}} { \"foo\": true, \"bar\": { \"baz\": false } } {{/assign}}\n{{formatJson someJson format='compact'}}\n</code></pre>"},{"location":"stubbing_and_verifying/response_templating/#adding-to-a-json-array","title":"Adding to a JSON Array","text":"<p>Introduced in WireMock version <code>3.10.0</code>, the <code>jsonArrayAdd</code> helper allows you to append an element to an existing json array.</p> <p>Its simplest form just takes two parameters, the JSON array to append to and the JSON item to be added:</p> Handlebars<pre><code>{{#assign 'existingArray'}}\n[\n    {\n        \"id\": 123,\n        \"name\": \"alice\"\n    }\n]\n{{/assign}}\n\n{{#assign 'newItem'}}\n{\n    \"id\": 321,\n    \"name\": \"sam\"\n}\n{{/assign}}\n\n{{jsonArrayAdd existingArray newItem}}\n</code></pre> <p>The above template will produce the following JSON:</p> JSON<pre><code>[\n    {\n        \"id\": 123,\n        \"name\": \"alice\"\n    },\n    {\n        \"id\": 321,\n        \"name\": \"sam\"\n    }\n]\n</code></pre> <p>You can also use it in block form to parse the contents of the block as the new item to add:</p> Handlebars<pre><code>{{#jsonArrayAdd existingArray}}\n{\n    \"id\": 321,\n    \"name\": \"sam\"\n}\n{{/jsonArrayAdd}}\n</code></pre> <p>It may be convenient to default the array to an empty array if it does not exist:</p> Handlebars<pre><code>{{#jsonArrayAdd (val existingArray or='[]')}}\n{\n    \"id\": 321,\n    \"name\": \"sam\"\n}\n{{/jsonArrayAdd}}\n</code></pre> <p>The number of items in the array can be limited by using the <code>maxItems</code> parameter:</p> Handlebars<pre><code>{{#assign 'existingArray'}}\n[\n    {\n        \"id\": 123,\n        \"name\": \"alice\"\n    },\n    {\n        \"id\": 321,\n        \"name\": \"sam\"\n    }\n]\n{{/assign}}\n\n{{#jsonArrayAdd existingArray maxItems=2}}\n{\n    \"id\": 456,\n    \"name\": \"bob\"\n}\n{{/jsonArrayAdd}}\n</code></pre> <p>The above template will produce the following JSON.  The first item in the array has been removed to maintain the number of items in the array as specified by the <code>maxItems</code> parameter:</p> JSON<pre><code>[\n  {\n    \"id\": 321,\n    \"name\": \"sam\"\n  },\n  {\n    \"id\": 456,\n    \"name\": \"bob\"\n  }\n]\n</code></pre> <p>You can add arrays to the existing json array using this helper:</p> Handlebars<pre><code>{{#assign 'existingArray'}}\n[\n    {\n        \"id\": 123,\n        \"name\": \"alice\"\n    },\n    {\n        \"id\": 321,\n        \"name\": \"sam\"\n    }\n]\n{{/assign}}\n\n{{#jsonArrayAdd existingArray}}\n[\n    {\n        \"id\": 456,\n        \"name\": \"bob\"\n    }\n]\n{{/jsonArrayAdd}}\n</code></pre> <p>The above template will produce the following JSON:</p> JSON<pre><code>[\n  {\n    \"id\": 123,\n    \"name\": \"alice\"\n  },\n  {\n    \"id\": 321,\n    \"name\": \"sam\"\n  },\n  [\n    {\n      \"id\": 456,\n      \"name\": \"bob\"\n    }\n  ]\n]\n</code></pre> <p>If you want the end result to be a single json array, you can use the <code>flatten</code> attribute:</p> Handlebars<pre><code>{{#assign 'existingArray'}}\n[\n    {\n        \"id\": 123,\n        \"name\": \"alice\"\n    },\n    {\n        \"id\": 321,\n        \"name\": \"sam\"\n    }\n]\n{{/assign}}\n\n{{#jsonArrayAdd existingArray flatten=true}}\n[\n    {\n        \"id\": 456,\n        \"name\": \"bob\"\n    }\n]\n{{/jsonArrayAdd}}\n</code></pre> <p>The above template will produce the following JSON:</p> JSON<pre><code>[\n  {\n    \"id\": 123,\n    \"name\": \"alice\"\n  },\n  {\n    \"id\": 321,\n    \"name\": \"sam\"\n  },\n  {\n    \"id\": 456,\n    \"name\": \"bob\"\n  }\n]\n</code></pre> <p>You can use the <code>jsonArrayAdd</code> helper to add items to a nested array.  This is achieved using the <code>jsonPath</code> property and referencing the array you want to add an item to:</p> Handlebars<pre><code>{{#assign 'existingArray'}}\n[\n    {\n        \"id\": 123,\n        \"names\":[\"alice\", \"sam\"]\n    },\n    {\n        \"id\": 321,\n        \"names\":[\"fred\", \"neil\"]\n    }\n]\n{{/assign}}\n\n{{#assign 'itemToAdd'}}\"bob\"{{/assign}}\n\n{{jsonArrayAdd existingArray itemToAdd jsonPath='$[0].names'}}\n</code></pre> <p>The above template will produce the following JSON:</p> JSON<pre><code>[\n  {\n    \"id\": 123,\n    \"names\": [ \"alice\", \"sam\", \"bob\" ]\n  },\n  {\n    \"id\": 321,\n    \"names\": [ \"fred\", \"neil\" ]\n  }\n]\n</code></pre>"},{"location":"stubbing_and_verifying/response_templating/#merging-json-objects","title":"Merging JSON objects","text":"<p>Introduced in WireMock version <code>3.10.0</code>, the <code>jsonMerge</code> helper allows you to merge two json objects. Merging will recurse into any common keys where the values are both objects, but not into any array values, where the value in the second object will overwrite that in the first.</p> <p>Given these two objects:</p> Handlebars<pre><code>{{#assign 'object1'}}\n{\n    \"id\": 456,\n    \"forename\": \"Robert\",\n    \"surname\": \"Smith\",\n    \"address\": {\n        \"number\": \"12\"\n    },\n    \"hobbies\": [ \"chess\", \"football\" ]\n}\n{{/assign}}\n{{#assign 'object2'}}\n{\n    \"forename\": \"Robert\",\n    \"nickname\": \"Bob\",\n    \"address\": {\n        \"street\": \"High Street\"\n    },\n    \"hobbies\": [ \"rugby\" ]\n}\n{{/assign}}\n</code></pre> Handlebars<pre><code>{{jsonMerge object1 object2}}\n</code></pre> <p>will return this object:</p> JSON<pre><code>{\n    \"id\": 456,\n    \"forename\": \"Robert\",\n    \"surname\": \"Smith\",\n    \"nickname\": \"Bob\",\n    \"address\": {\n        \"number\": \"12\",\n        \"street\": \"High Street\"\n    },\n    \"hobbies\": [ \"rugby\" ]\n}\n</code></pre> <p>Like the <code>jsonArrayAdd</code> helper, the second object can be provided as a block:</p> Handlebars<pre><code>{{#jsonMerge object1}}\n{\n    \"forename\": \"Robert\",\n    \"nickname\": \"Bob\",\n    \"address\": {\n        \"street\": \"High Street\"\n    },\n    \"hobbies\": [ \"rugby\" ]\n}\n{{/jsonMerge}}\n</code></pre>"},{"location":"stubbing_and_verifying/response_templating/#removing-attributes","title":"Removing attributes","text":"<p>Starting with WireMock version <code>3.12.0</code>, the <code>jsonMerge</code> helper has an optional <code>removeNulls</code> parameter which, when  set to true will remove any attributes from the resulting JSON that have null values in the second JSON document.</p> <p>So for instance, given the following template:</p> Handlebars<pre><code>{{#assign 'object1'}}\n{\n    \"keepMe\": 1,\n    \"removeMe\": 2\n}\n{{/assign}}\n\n{{#jsonMerge object1 removeNulls=true}}\n{\n    \"removeMe\": null\n}\n{{/jsonMerge}}\n</code></pre> <p>The resulting JSON would be:</p> JSON<pre><code>{\n    \"keepMe\": 1\n}\n</code></pre>"},{"location":"stubbing_and_verifying/response_templating/#removing-from-a-json-array-or-object","title":"Removing from a JSON Array or Object","text":"<p>The <code>jsonRemove</code> helper was introduced in WireMock <code>3.10.0</code> and allows you to remove an element from an existing json  array, or remove a key from an existing json object, by identifying it using a json path expression.</p> <p>For instance, given an existing array like this:</p> Handlebars<pre><code>{{#assign 'existingArray'}}\n[\n    { \"id\": 456, \"name\": \"bob\"},\n    { \"id\": 123, \"name\": \"alice\"},\n    { \"id\": 321, \"name\": \"sam\"}\n]\n{{/assign}}\n</code></pre> <p>application of this helper, which selects the object with id <code>123</code>:</p> Handlebars<pre><code>{{jsonRemove existingArray '$.[?(@.id == 123)]'}}\n</code></pre> <p>will return this array:</p> JSON<pre><code>[\n    { \"id\": 456, \"name\": \"bob\"},\n    { \"id\": 321, \"name\": \"sam\"}\n]\n</code></pre> <p>Given an object like this:</p> Handlebars<pre><code>{{#assign 'existingObject'}}\n    { \"id\": 456, \"name\": \"bob\"}\n{{/assign}}\n</code></pre> <p>application of this helper, which selects the key name:</p> Handlebars<pre><code>{{jsonRemove existingObject '$.name'}}\n</code></pre> <p>will return this object:</p> JSON<pre><code>{ \"id\": 456 }\n</code></pre>"},{"location":"stubbing_and_verifying/response_templating/#date-and-time-helpers","title":"Date and time helpers","text":"<p>A helper is present to render the current date/time, with the ability to specify the format (via Java's SimpleDateFormat) and offset.</p> Handlebars<pre><code>{{now}}\n{{now offset='3 days'}}\n{{now offset='-24 seconds'}}\n{{now offset='1 years'}}\n{{now offset='10 years' format='yyyy-MM-dd'}}\n</code></pre> <p>Dates can be rendered in a specific timezone (the default is UTC):</p> Handlebars<pre><code>{{now timezone='Australia/Sydney' format='yyyy-MM-dd HH:mm:ssZ'}}\n</code></pre> <p>Pass <code>epoch</code> as the format to render the date as UNIX epoch time (in milliseconds), or <code>unix</code> as the format to render the UNIX timestamp in seconds.</p> Handlebars<pre><code>{{now offset='2 years' format='epoch'}}\n{{now offset='2 years' format='unix'}}\n</code></pre> <p>Dates can be parsed using the <code>parseDate</code> helper:</p> Handlebars<pre><code>// Attempts parsing using ISO8601, RFC 1123, RFC 1036 and ASCTIME formats.\n// We wrap in the date helper in order to print the result as a string.\n{{date (parseDate request.headers.MyDate)}}\n\n// Parse using a custom date format\n{{date (parseDate request.headers.MyDate format='dd/MM/yyyy')}}\n\n// Format can also be unix (epoch seconds) or epoch (epoch milliseconds)\n{{date (parseDate request.headers.MyDate format='unix')}}\n</code></pre> <p>Dates can be truncated to e.g. first day of month using the <code>truncateDate</code> helper:</p> Handlebars<pre><code>// If the MyDate header is Tue, 15 Jun 2021 15:16:17 GMT\n// then the result of the following will be 2021-06-01T00:00:00Z\n{{date (truncateDate (parseDate request.headers.MyDate) 'first day of month')}}\n</code></pre> <p>See the full list of truncations here.</p>"},{"location":"stubbing_and_verifying/response_templating/#random-value-helper","title":"Random value helper","text":"<p>Random strings of various kinds can be generated:</p> Handlebars<pre><code>{{randomValue length=33 type='ALPHANUMERIC'}}\n{{randomValue length=12 type='ALPHANUMERIC' uppercase=true}}\n{{randomValue length=55 type='ALPHABETIC'}}\n{{randomValue length=27 type='ALPHABETIC' uppercase=true}}\n{{randomValue length=10 type='NUMERIC'}}\n{{randomValue length=5 type='ALPHANUMERIC_AND_SYMBOLS'}}\n{{randomValue type='UUID'}}\n{{randomValue length=32 type='HEXADECIMAL' uppercase=true}}\n</code></pre>"},{"location":"stubbing_and_verifying/response_templating/#pick-random-helper","title":"Pick random helper","text":"<p>A value can be randomly selected from a literal list:</p> Handlebars<pre><code>{{pickRandom '1' '2' '3'}}\n</code></pre> <p>Or from a list passed as a parameter:</p> Handlebars<pre><code>{{pickRandom (jsonPath request.body '$.names')}}\n</code></pre> <p>If you desire multiple unique elements to be randomly pulled from the list, a <code>count</code> option can be supplied to the helper. In this case, the result will be a list, instead of a single value. For example, the following template:</p> Handlebars<pre><code>{{pickRandom 1 2 3 4 5 count=3}}\n</code></pre> <p>will produce a list similar to the following:</p> Text Only<pre><code>[3, 5, 2]\n</code></pre>"},{"location":"stubbing_and_verifying/response_templating/#random-number-helpers","title":"Random number helpers","text":"<p>These helpers produce random numbers of the desired type. By returning actual typed numbers rather than strings we can use them for further work e.g. by doing arithemetic with the <code>math</code> helper or randomising the bound in a <code>range</code>.</p> <p>Random integers can be produced with lower and/or upper bounds, or neither:</p> Handlebars<pre><code>{{randomInt}}\n{{randomInt lower=5 upper=9}}\n{{randomInt upper=54323}}\n{{randomInt lower=-24}}\n</code></pre> <p>Likewise decimals can be produced with or without bounds:</p> Handlebars<pre><code>{{randomDecimal}}\n{{randomDecimal lower=-10.1 upper=-0.9}}\n{{randomDecimal upper=12.5}}\n{{randomDecimal lower=-24.01}}\n</code></pre>"},{"location":"stubbing_and_verifying/response_templating/#formatting-numbers","title":"Formatting numbers","text":"<p>The <code>numberFormat</code> helper allows you to specify how numbers are printed. It supports a number of predefined formats, custom format strings and various other options including rounding mode, decimal places and locale.</p>"},{"location":"stubbing_and_verifying/response_templating/#predefined-formats","title":"Predefined formats","text":"<p><code>numberFormat</code> supports the following predefined formats:</p> <ul> <li><code>integer</code></li> <li><code>currency</code></li> <li><code>percent</code></li> </ul> <p>Predefined formats can be affected by locale, so it's usually a good idea to explicitly specify this.</p> <p>For example, to format a decimal number as currency, specifically British pounds:</p> Handlebars<pre><code>{{{numberFormat 123.4567 'currency' 'en_GB'}}}\n</code></pre> <p>Output: <code>\u00a3123.46</code>.</p> <p>Alternatively, if we wanted to output the number as a percentage:</p> Handlebars<pre><code>{{{numberFormat 123.4567 'percent' 'en_GB'}}}\n</code></pre> <p>Output: <code>12,346%</code>.</p>"},{"location":"stubbing_and_verifying/response_templating/#custom-format-string","title":"Custom format string","text":"<p>For maximum control over the number format you can specify a format string:</p> Handlebars<pre><code>{{{numberFormat 123.4567 '###.000000' 'en_GB'}}}\n</code></pre> <p>Output: <code>123.456700</code>.</p> <p>See the Java DecimalFormat documentation for details on how to use format strings.</p>"},{"location":"stubbing_and_verifying/response_templating/#configuring-number-of-digits","title":"Configuring number of digits","text":"<p>Separate from the format parameter, the number of digits before and after the decimal place can be bounded using one or more of four parameters: <code>maximumFractionDigits</code>, <code>minimumFractionDigits</code>, <code>maximumIntegerDigits</code>, <code>minimumIntegerDigits</code>.</p> Handlebars<pre><code>{{{numberFormat 1234.567 maximumIntegerDigits=3 minimumFractionDigits=6}}}\n</code></pre> <p>Output: <code>234.567000</code>.</p>"},{"location":"stubbing_and_verifying/response_templating/#disabling-grouping","title":"Disabling grouping","text":"<p>By default <code>numberFormat</code> will insert commas, periods etc. per the locale between groups of digits e.g. <code>1,234.5</code>.</p> <p>This behaviour can be disabled with <code>groupingUsed</code>.</p> Handlebars<pre><code>{{{numberFormat 12345.678 groupingUsed=false}}}\n</code></pre> <p>Output: <code>12345.678</code>.</p>"},{"location":"stubbing_and_verifying/response_templating/#rounding-mode","title":"Rounding mode","text":"<p>The <code>roundingMode</code> parameter affects how numbers will be rounded up or down when it's necessary to do so.</p> <p>For instance, to always round down:</p> Handlebars<pre><code>{{{numberFormat 1.239 roundingMode='down' maximumFractionDigits=2}}}\n</code></pre> <p>Output: <code>1.23</code>.</p> <p>Available rounding modes are:</p> <ul> <li><code>up</code></li> <li><code>down</code></li> <li><code>half_up</code></li> <li><code>half_down</code></li> <li><code>half_even</code></li> <li><code>ceiling</code></li> <li><code>floor</code>.</li> </ul> <p>See the Java RoundingMode documentation for the exact meaning of each of these.</p>"},{"location":"stubbing_and_verifying/response_templating/#fake-data-helpers","title":"Fake data helpers","text":"<p>This helper produces random fake data of the desired types available in the Data Faker library. Due to the size of this library, this helper has been provided via <code>RandomExtension</code>.    </p> Handlebars<pre><code>{{random 'Name.first_name'}}\n{{random 'Address.postcode_by_state.AL' }}\n</code></pre>"},{"location":"stubbing_and_verifying/response_templating/#math-helper","title":"Math helper","text":"<p>The <code>math</code> (or maths, depending where you are) helper performs common arithmetic operations. It can accept integers, decimals or strings as its operands and will always yield a number as its output rather than a string.</p> <p>Addition, subtraction, multiplication, division and remainder (mod) are supported:</p> Handlebars<pre><code>{{math 1 '+' 2}}\n{{math 4 '-' 2}}\n{{math 2 '*' 3}}\n{{math 8 '/' 2}}\n{{math 10 '%' 3}}\n</code></pre>"},{"location":"stubbing_and_verifying/response_templating/#range-helper","title":"Range helper","text":"<p>The <code>range</code> helper will produce an array of integers between the bounds specified:</p> Handlebars<pre><code>{{range 3 8}}\n{{range -2 2}}\n</code></pre> <p>This can be usefully combined with <code>randomInt</code> and <code>each</code> to output random length, repeating pieces of content e.g.</p> Handlebars<pre><code>{{#each (range 0 (randomInt lower=1 upper=10)) as |index|}}\nid: {{index}}\n{{/each}}\n</code></pre>"},{"location":"stubbing_and_verifying/response_templating/#array-literal-helper","title":"Array literal helper","text":"<p>The <code>array</code> helper will produce an array from the list of parameters specified. The values can be any valid type. Providing no parameters will result in an empty array.</p> Handlebars<pre><code>{{array 1 'two' true}}\n{{array}}\n</code></pre>"},{"location":"stubbing_and_verifying/response_templating/#array-add-remove-helpers","title":"Array add &amp; remove helpers","text":"<p>As of WireMock version <code>3.6.0</code>, the <code>arrayAdd</code> and <code>arrayRemove</code> helpers can be used to add or remove elements from an  array based on a position value or the <code>start</code> or <code>end</code> keywords. If no position is specified, the element will be  added or removed from the end of the array.</p> Handlebars<pre><code>{{arrayAdd (array 1 'three') 2 position=1}} // [1, 2, three]\n{{arrayAdd (array 1 'three') 2 position='start'}} // [2, 1, three]\n{{arrayAdd (array 1 'three') 2 position='end'}} // [1, three, 2]\n{{arrayAdd (array 1 'three') 2}} // [1, three, 2]\n\n{{arrayRemove (array 1 2 'three') position=1}} // [1, three]\n{{arrayRemove (array 1 2 'three') position='start'}} // [2, three]\n{{arrayRemove (array 1 2 'three') position='end'}} // [1, 2]\n{{arrayRemove (array 1 2 'three')}} // [1, 2]\n</code></pre>"},{"location":"stubbing_and_verifying/response_templating/#arrayjoin-helper","title":"arrayJoin helper","text":"<p>Released in WireMock version <code>3.6.0</code>, the <code>arrayJoin</code> helper will concatenate the values passed to it with the  separator specified:</p> Handlebars<pre><code>{{arrayJoin ',' (array 'One' 'Two' 'Three')}} // One,Two,Three\n{{arrayJoin ' - ' 'a' 'b' 'c'}} // a - b - c\n{{arrayJoin ', ' (range 1 5)}} // 1, 2, 3, 4, 5\n{{arrayJoin (pickRandom ':') (array 'One' 'Two' 'Three')}} // One:Two:Three\n{{arrayJoin '' (array 'W' 'i' 'r' 'e' 'M' 'o' 'c' 'k' ' ' 'R' 'o' 'c' 'k' 's')}} // WireMock Rocks\n</code></pre> <p>You can also specify a <code>prefix</code> and <code>suffix</code> to be added to the start and end of the result:</p> Handlebars<pre><code>{{arrayJoin ',' (array 'One' 'Two' 'Three') prefix='[' suffix=']'}} // [One,Two,Three]\n{{arrayJoin ' * ' (array 1 2 3) prefix='(' suffix=')'}} // (1 * 2 * 3)\n</code></pre> <p>The <code>arrayJoin</code> helper can also be used as a block helper:</p> Handlebars<pre><code>{{#parseJson 'myThings'}}\n[\n  { \"id\": 1, \"name\": \"One\" },\n  { \"id\": 2, \"name\": \"Two\" },\n  { \"id\": 3, \"name\": \"Three\" }\n]\n{{/parseJson}}\n[{{#arrayJoin ',' myThings as |item|}}\n{\n\"name{{item.id}}\": \"{{item.name}}\"\n}\n{{/arrayJoin}}] // [{ \"name1\": \"One\" }, { \"name2\": \"Two\" }, { \"name3\": \"Three\" }]\n\n\n// or the same example with the prefix and suffix parameters\n{{#parseJson 'myThings'}}\n    [\n    { \"id\": 1, \"name\": \"One\" },\n    { \"id\": 2, \"name\": \"Two\" },\n    { \"id\": 3, \"name\": \"Three\" }\n    ]\n{{/parseJson}}\n{{#arrayJoin ',' myThings prefix='[' suffix=']' as |item|}}\n    {\n    \"name{{item.id}}\": \"{{item.name}}\"\n    }\n{{/arrayJoin}} // [{ \"name1\": \"One\" }, { \"name2\": \"Two\" }, { \"name3\": \"Three\" }]\n</code></pre>"},{"location":"stubbing_and_verifying/response_templating/#contains-helper","title":"Contains helper","text":"<p>The <code>contains</code> helper returns a boolean value indicating whether the string or array passed as the first parameter contains the string passed in the second.</p> <p>It can be used as parameter to the <code>if</code> helper:</p> Handlebars<pre><code>{{#if (contains 'abcde' 'abc')}}YES{{/if}}\n{{#if (contains (array 'a' 'b' 'c') 'a')}}YES{{/if}}\n</code></pre> <p>Or as a block element on its own:</p> Handlebars<pre><code>{{#contains 'abcde' 'abc'}}YES{{/contains}}\n{{#contains (array 'a' 'b' 'c') 'a'}}YES{{/contains}}\n</code></pre>"},{"location":"stubbing_and_verifying/response_templating/#matches-helper","title":"Matches helper","text":"<p>The <code>matches</code> helper returns a boolean value indicating whether the string passed as the first parameter matches the regular expression passed in the second:</p> <p>Like the <code>contains</code> helper it can be used as parameter to the <code>if</code> helper:</p> Handlebars<pre><code>{{#if (matches '123' '[0-9]+')}}YES{{/if}}\n</code></pre> <p>Or as a block element on its own:</p> Handlebars<pre><code>{{#matches '123' '[0-9]+'}}YES{{/matches}}\n</code></pre>"},{"location":"stubbing_and_verifying/response_templating/#string-trim-helper","title":"String trim helper","text":"<p>Use the <code>trim</code> helper to remove whitespace from the start and end of the input:</p> Handlebars<pre><code>{{trim request.headers.X-Padded-Header}}\n\n{{#trim}}\n\n    Some stuff with whitespace\n\n{{/trim}}\n</code></pre>"},{"location":"stubbing_and_verifying/response_templating/#base64-helper","title":"Base64 helper","text":"<p>The <code>base64</code> helper can be used to base64 encode and decode values:</p> Handlebars<pre><code>{{base64 request.headers.X-Plain-Header}}\n{{base64 request.headers.X-Encoded-Header decode=true}}\n\n{{#base64}}\nContent to encode\n{{/base64}}\n\n{{#base64 padding=false}}\nContent to encode without padding\n{{/base64}}\n\n{{#base64 decode=true}}\nQ29udGVudCB0byBkZWNvZGUK\n{{/base64}}\n</code></pre>"},{"location":"stubbing_and_verifying/response_templating/#url-encoding-helper","title":"URL encoding helper","text":"<p>The <code>urlEncode</code> helper can be used to URL encode and decode values:</p> Handlebars<pre><code>{{urlEncode request.headers.X-Plain-Header}}\n{{urlEncode request.headers.X-Encoded-Header decode=true}}\n\n{{#urlEncode}}\nContent to encode\n{{/urlEncode}}\n\n{{#urlEncode decode=true}}\nContent%20to%20decode\n{{/urlEncode}}\n</code></pre>"},{"location":"stubbing_and_verifying/response_templating/#form-helper","title":"Form helper","text":"<p>The <code>formData</code> helper parses its input as an HTTP form, returning an object containing the individual fields as attributes. The helper takes the input string and variable name as its required parameters, with an optional <code>urlDecode</code> parameter indicating that values should be URL decoded. The folowing example will parse the request body as a form, then output a single field <code>formField3</code>:</p> Handlebars<pre><code>{{formData request.body 'form' urlDecode=true}}{{form.formField3}}\n</code></pre> <p>If the form submitted has multiple values for a given field, these can be accessed by index:</p> Handlebars<pre><code>{{formData request.body 'form' urlDecode=true}}{{form.multiValueField.1}}, {{form.multiValueField.2}}\n{{formData request.body 'form' urlDecode=true}}{{form.multiValueField.first}}, {{form.multiValueField.last}}\n</code></pre>"},{"location":"stubbing_and_verifying/response_templating/#regular-expression-extract-helper","title":"Regular expression extract helper","text":"<p>The <code>regexExtract</code> helper supports extraction of values matching a regular expresson from a string.</p> <p>A single value can be extracted like this:</p> Handlebars<pre><code>{{regexExtract request.body '[A-Z]+'}}\"\n</code></pre> <p>Regex groups can be used to extract multiple parts into an object for later use (the last parameter is a variable name to which the object will be assigned):</p> Handlebars<pre><code>{{regexExtract request.body '([a-z]+)-([A-Z]+)-([0-9]+)' 'parts'}}\n{{parts.0}},{{parts.1}},{{parts.2}}\n</code></pre> <p>Optionally, a default value can be specified for when there is no match. When the regex does not match and no default is specified, an error will be thrown instead.</p> Handlebars<pre><code>{{regexExtract 'abc' '[0-9]+' default='my default value'}}\n</code></pre>"},{"location":"stubbing_and_verifying/response_templating/#size-helper","title":"Size helper","text":"<p>The <code>size</code> helper returns the size of a string, list or map:</p> Handlebars<pre><code>{{size 'abcde'}}\n{{size request.query.things}}\n</code></pre>"},{"location":"stubbing_and_verifying/response_templating/#hostname-helper","title":"Hostname helper","text":"<p>The local machine's hostname can be printed:</p> Handlebars<pre><code>{{hostname}}\n</code></pre>"},{"location":"stubbing_and_verifying/response_templating/#system-property-helper","title":"System property helper","text":"<p>Environment variables and system properties can be printed:</p> Handlebars<pre><code>{{systemValue key='PATH'}} &lt;!-- type defaults to ENVIRONMENT --&gt;\n{{systemValue type='ENVIRONMENT' key='PATH'}}\n{{systemValue type='PROPERTY' key='os.path'}}\n</code></pre> <p>Since 3.5 a default value can be supplied:</p> Handlebars<pre><code>{{systemValue key='PATH' default='DEFAULT'}} &lt;!-- type defaults to ENVIRONMENT --&gt;\n{{systemValue type='ENVIRONMENT' key='PATH' default='DEFAULT'}}\n{{systemValue type='PROPERTY' key='os.path' default='DEFAULT'}}\n</code></pre> <p>If you want to add permitted extensions to your rule, then you can use the <code>ResponseTemplateTransformer</code> when constructing the response template extension.</p> <p>The <code>ResponseTemplateTransformer</code> accepts four arguments: 1. The <code>TemplateEngine</code> 2. If templating can be applied globally 3. The <code>FileSource</code> which is a list of files that can be used for relative references in stub definitions 4. A list of <code>TemplateModelDataProviderExtension</code> objects which are additional metadata providers which will be injected into the model and consumed in the downstream resolution if needed</p> Java<pre><code>@Rule\npublic WireMockRule wm = new WireMockRule(options()\n        .dynamicPort()\n        .withRootDirectory(defaultTestFilesRoot())\n        .extensions(new ResponseTemplateTransformer(\n              getTemplateEngine(),\n              options.getResponseTemplatingGlobal(),\n              getFiles(),\n              templateModelProviders\n            )\n        )\n);\n</code></pre> <p>The regular expressions are matched in a case-insensitive manner. If no permitted system key patterns are set, a single default of <code>wiremock.*</code> will be used.</p>"},{"location":"stubbing_and_verifying/simulating_faults/","title":"Simulating Faults","text":"<p>Documentation / stubbing_and_verifying / simulating_faults</p> <p>WireMock Cloud</p> <p>To go beyond simulating faults and test product reliability in unexpected fault scenarios using Chaos Engineering, learn about WireMock Cloud.</p> <p>One of the main reasons it's beneficial to use web service fakes when testing is to inject faulty behaviour that might be difficult to get the real service to produce on demand. In addition to being able to send back any HTTP response code indicating an error, WireMock is able to generate a few other types of problem.</p>"},{"location":"stubbing_and_verifying/simulating_faults/#per-stub-fixed-delays","title":"Per-stub fixed delays","text":"<p>A stub response can have a fixed delay attached to it, such that the response will not be returned until after the specified number of milliseconds:</p> Java<pre><code>stubFor(get(urlEqualTo(\"/delayed\")).willReturn(\n        aResponse()\n                .withStatus(200)\n                .withFixedDelay(2000)));\n</code></pre> <p>Or</p> JSON<pre><code>{\n    \"request\": {\n        \"method\": \"GET\",\n        \"url\": \"/delayed\"\n    },\n    \"response\": {\n        \"status\": 200,\n        \"fixedDelayMilliseconds\": 2000\n    }\n}\n</code></pre>"},{"location":"stubbing_and_verifying/simulating_faults/#global-fixed-stub-delays","title":"Global fixed stub delays","text":"<p>A fixed delay can be added to all stubs either by calling <code>WireMock.setGlobalFixedDelay()</code> or posting a JSON document of the following form to <code>http://&lt;host&gt;:&lt;port&gt;/__admin/settings</code>:</p> JSON<pre><code>{\n    \"fixedDelay\": 500\n}\n</code></pre>"},{"location":"stubbing_and_verifying/simulating_faults/#per-stub-random-delays","title":"Per-stub random delays","text":"<p>In addition to fixed delays, a delay can be sampled from a random distribution. This allows simulation of more specific downstream latencies, such as a long tail.</p> <p>Use <code>#withRandomDelay</code> on the stub to pass in the desired distribution:</p> Java<pre><code>stubFor(get(urlEqualTo(\"/random/delayed\")).willReturn(\n        aResponse()\n                .withStatus(200)\n                .withLogNormalRandomDelay(90, 0.1)));\n</code></pre> <p>Or set it on the <code>delayDistribution</code> field via the JSON api:</p> JSON<pre><code>{\n    \"request\": {\n        \"method\": \"GET\",\n        \"url\": \"/random/delayed\"\n    },\n    \"response\": {\n        \"status\": 200,\n        \"delayDistribution\": {\n            \"type\": \"lognormal\",\n            \"median\": 80,\n            \"sigma\": 0.4\n        }\n    }\n}\n</code></pre>"},{"location":"stubbing_and_verifying/simulating_faults/#global-random-stub-delays","title":"Global random stub delays","text":"<p>You can set a random delay globally with <code>WireMock.setGlobalRandomDelay()</code> or the JSON api at <code>http://&lt;host&gt;:&lt;port&gt;/__admin/settings</code>:</p> JSON<pre><code>{\n    \"delayDistribution\": {\n        \"type\": \"lognormal\",\n        \"median\": 90,\n        \"sigma\": 0.1\n    }\n}\n</code></pre>"},{"location":"stubbing_and_verifying/simulating_faults/#available-distributions","title":"Available distributions","text":""},{"location":"stubbing_and_verifying/simulating_faults/#lognormal-delay","title":"Lognormal delay","text":"<p>A lognormal distribution is a pretty good approximation of long tailed latencies centered on the 50th percentile. It takes two mandatory parameters plus an optional third:</p> <ul> <li>median - The 50th percentile of latencies.</li> <li>sigma - Standard deviation of the underlying normal distribution. The larger the      value, the longer the tail.</li> <li>maxValue - (Optional) The maximum value to return. If this value is specified, it      must greater than or equal to the median otherwise an <code>IllegalArgumentException</code> will      be thrown. If a value greater than this value is generated, it will be resampled.      This is useful for shortening potential long tails that might otherwise cause timeouts     in calling clients. This option is only available from WireMock version <code>3.13.0</code></li> </ul> <p>Try different values to find a good approximation.</p> <p>To use, instantiate a <code>new LogNormal(median, sigma)</code> or <code>new LogNormal(median, sigma, maxValue)</code>, or via JSON:</p> JSON<pre><code>\"delayDistribution\": {\n        \"type\": \"lognormal\",\n        \"median\": 80,\n        \"sigma\": 0.4\n}\n</code></pre> <p>or with a maximum value:</p> JSON<pre><code>\"delayDistribution\": {\n        \"type\": \"lognormal\",\n        \"median\": 80,\n        \"sigma\": 0.4,\n        \"maxValue\": 100\n}\n</code></pre>"},{"location":"stubbing_and_verifying/simulating_faults/#uniform-delay","title":"Uniform delay","text":"<p>A uniform distribution can be used for simulating a stable latency with a fixed amount of jitter. It takes two parameters:</p> <ul> <li>lower - Lower bound of the range, inclusive.</li> <li>upper - Upper bound of the range, inclusive.</li> </ul> <p>For instance, to simulate a stable latency of 20ms +/- 5ms, use lower = 15 and upper = 25.</p> <p>To use, instantiate a <code>new UniformDistribution(15, 25)</code>, or via JSON:</p> JSON<pre><code>\"delayDistribution\": {\n        \"type\": \"uniform\",\n        \"lower\": 15,\n        \"upper\": 25\n}\n</code></pre>"},{"location":"stubbing_and_verifying/simulating_faults/#chunked-dribble-delay","title":"Chunked Dribble Delay","text":"<p>In addition to fixed and random delays, you can dribble your response back in chunks. This is useful for simulating a slow network and testing deterministic timeouts.</p> <p>Use <code>#withChunkedDribbleDelay</code> on the stub to pass in the desired chunked response, it takes two parameters:</p> <ul> <li><code>numberOfChunks</code> - how many chunks you want your response body divided up into</li> <li><code>totalDuration</code> - the total duration you want the response to take in milliseconds</li> </ul> Java<pre><code>stubFor(get(\"/chunked/delayed\").willReturn(\n        aResponse()\n                .withStatus(200)\n                .withBody(\"Hello world!\")\n                .withChunkedDribbleDelay(5, 1000)));\n</code></pre> <p>Or set it on the <code>chunkedDribbleDelay</code> field via the JSON API:</p> JSON<pre><code>{\n    \"request\": {\n        \"method\": \"GET\",\n        \"url\": \"/chunked/delayed\"\n    },\n    \"response\": {\n        \"status\": 200,\n        \"body\": \"Hello world!\",\n        \"chunkedDribbleDelay\": {\n            \"numberOfChunks\": 5,\n            \"totalDuration\": 1000\n        }\n    }\n}\n</code></pre> <p>With the above settings the <code>Hello world!</code> response body will be broken into five chunks and returned one at a time with a 200ms gap between each.</p>"},{"location":"stubbing_and_verifying/simulating_faults/#bad-responses","title":"Bad responses","text":"<p>It is also possible to create several kinds of corrupted responses:</p> Java<pre><code>stubFor(get(urlEqualTo(\"/fault\"))\n        .willReturn(aResponse().withFault(Fault.MALFORMED_RESPONSE_CHUNK)));\n</code></pre> <p>The <code>Fault</code> enum has the following options:</p> <p><code>EMPTY_RESPONSE</code>: Return a completely empty response.</p> <p><code>MALFORMED_RESPONSE_CHUNK</code>: Send an OK status header, then garbage, then close the connection.</p> <p><code>RANDOM_DATA_THEN_CLOSE</code>: Send garbage then close the connection.</p> <p><code>CONNECTION_RESET_BY_PEER</code>: Close the connection, setting <code>SO_LINGER</code> to 0 and thus preventing the <code>TIME_WAIT</code> state being entered. Typically causes a \"Connection reset by peer\" type error to be thrown by the client. Note: this only seems to work properly on *nix OSs. On Windows it will most likely cause the connection to hang rather than reset.</p> <p>In JSON (fault values are the same as the ones listed above):</p> JSON<pre><code>{\n    \"request\": {\n        \"method\": \"GET\",\n        \"url\": \"/fault\"\n    },\n    \"response\": {\n        \"fault\": \"MALFORMED_RESPONSE_CHUNK\"\n    }\n}\n</code></pre>"},{"location":"stubbing_and_verifying/stateful_behaviour/","title":"Stateful Behaviour","text":"<p>Documentation / stubbing_and_verifying / stateful_behaviour </p> <p>WireMock Cloud</p> <p>Create stubs and scenarios with WireMock Cloud's intuitive editor and share with your team.</p> <p>Most web services tend to have some state, which changes as you and others interact with it. So it's pretty useful to be able to simulate this when you've swapped a real service for a test double.</p>"},{"location":"stubbing_and_verifying/stateful_behaviour/#scenarios","title":"Scenarios","text":"<p>WireMock supports state via the notion of scenarios. A scenario is essentially a state machine whose states can be arbitrarily assigned. Its starting state is always <code>Scenario.STARTED</code>. Stub mappings can be configured to match on scenario state, such that stub A can be returned initially, then stub B once the next scenario state has been triggered.</p> <p>For example, suppose we're writing a to-do list application consisting of a rich client of some kind talking to a REST service. We want to test that our UI can read the to-do list, add an item and refresh itself, showing the updated list.</p> <p>In Java this could be set up like this:</p> Java<pre><code>@Test\npublic void toDoListScenario() {\n    stubFor(get(urlEqualTo(\"/todo/items\")).inScenario(\"To do list\")\n            .whenScenarioStateIs(STARTED)\n            .willReturn(aResponse()\n                    .withBody(\"&lt;items&gt;\" +\n                            \"   &lt;item&gt;Buy milk&lt;/item&gt;\" +\n                            \"&lt;/items&gt;\")));\n\n    stubFor(post(urlEqualTo(\"/todo/items\")).inScenario(\"To do list\")\n            .whenScenarioStateIs(STARTED)\n            .withRequestBody(containing(\"Cancel newspaper subscription\"))\n            .willReturn(aResponse().withStatus(201))\n            .willSetStateTo(\"Cancel newspaper item added\"));\n\n    stubFor(get(urlEqualTo(\"/todo/items\")).inScenario(\"To do list\")\n            .whenScenarioStateIs(\"Cancel newspaper item added\")\n            .willReturn(aResponse()\n                    .withBody(\"&lt;items&gt;\" +\n                            \"   &lt;item&gt;Buy milk&lt;/item&gt;\" +\n                            \"   &lt;item&gt;Cancel newspaper subscription&lt;/item&gt;\" +\n                            \"&lt;/items&gt;\")));\n\n    WireMockResponse response = testClient.get(\"/todo/items\");\n    assertThat(response.content(), containsString(\"Buy milk\"));\n    assertThat(response.content(), not(containsString(\"Cancel newspaper subscription\")));\n\n    response = testClient.postWithBody(\"/todo/items\", \"Cancel newspaper subscription\", \"text/plain\", \"UTF-8\");\n    assertThat(response.statusCode(), is(201));\n\n    response = testClient.get(\"/todo/items\");\n    assertThat(response.content(), containsString(\"Buy milk\"));\n    assertThat(response.content(), containsString(\"Cancel newspaper subscription\"));\n}\n</code></pre> <p>The JSON equivalent for the above three stubs is:</p> JSON<pre><code>{\n    \"mappings\": [\n        {\n            \"scenarioName\": \"To do list\",\n            \"requiredScenarioState\": \"Started\",\n            \"request\": {\n                \"method\": \"GET\",\n                \"url\": \"/todo/items\"\n            },\n            \"response\": {\n                \"status\": 200,\n                \"body\": \"&lt;items&gt;&lt;item&gt;Buy milk&lt;/item&gt;&lt;/items&gt;\"\n            }\n        },\n        {\n            \"scenarioName\": \"To do list\",\n            \"requiredScenarioState\": \"Started\",\n            \"newScenarioState\": \"Cancel newspaper item added\",\n            \"request\": {\n                \"method\": \"POST\",\n                \"url\": \"/todo/items\",\n                \"bodyPatterns\": [\n                    { \"contains\": \"Cancel newspaper subscription\" }\n                ]\n            },\n            \"response\": {\n                \"status\": 201\n            }\n        },\n        {\n            \"scenarioName\": \"To do list\",\n            \"requiredScenarioState\": \"Cancel newspaper item added\",\n            \"request\": {\n                \"method\": \"GET\",\n                \"url\": \"/todo/items\"\n            },\n            \"response\": {\n                \"status\": 200,\n                \"body\": \"&lt;items&gt;&lt;item&gt;Buy milk&lt;/item&gt;&lt;item&gt;Cancel newspaper subscription&lt;/item&gt;&lt;/items&gt;\"\n            }\n        }\n    ]\n}\n</code></pre>"},{"location":"stubbing_and_verifying/stateful_behaviour/#getting-scenario-state","title":"Getting scenario state","text":"<p>The names, current state and possible states of all scenarios can be fetched.</p> <p>Java:</p> Java<pre><code>List&lt;Scenario&gt; allScenarios = getAllScenarios();\n</code></pre> <p>JSON:</p> JSON<pre><code>GET /__admin/scenarios\n{\n  \"scenarios\" : [ {\n    \"id\" : \"my_scenario\",\n    \"name\" : \"my_scenario\",\n    \"state\" : \"Started\",\n    \"possibleStates\" : [ \"Started\", \"state_2\", \"state_3\" ]\n  } ]\n}\n</code></pre>"},{"location":"stubbing_and_verifying/stateful_behaviour/#resetting-scenarios","title":"Resetting scenarios","text":"<p>The state of all configured scenarios can be reset back to <code>Scenario.START</code> either by calling</p> <p>Java:</p> Java<pre><code>WireMock.resetAllScenarios()\n</code></pre> <p>To do the equivalent via the HTTP API, send an empty <code>POST</code> request to <code>/__admin/scenarios/reset</code>.</p>"},{"location":"stubbing_and_verifying/stateful_behaviour/#resetting-a-single-scenario","title":"Resetting a single scenario","text":"<p>You can reset the state of an individual scenario.</p> <p>Java:</p> Java<pre><code>WireMock.resetScenario(\"my_scenario\");\n</code></pre> <p>The do the equivalent via the HTTP API, send an empty <code>PUT</code> to <code>/__admin/scenarios/my_scenario/state</code>.</p>"},{"location":"stubbing_and_verifying/stateful_behaviour/#setting-the-state-of-an-individual-scenario","title":"Setting the state of an individual scenario","text":"<p>You can also set the state of an individual scenario to a specific value.</p> <p>Java:</p> Java<pre><code>WireMock.setScenarioState(\"my_scenario\", \"state_2\");\n</code></pre> <p>HTTP:</p> JSON<pre><code>PUT /__admin/scenarios/my_scenario/state\n{\n    \"state\": \"state_2\"\n}\n</code></pre>"},{"location":"stubbing_and_verifying/stubbing/","title":"Stubbing","text":"<p>Documentation / stubbing_and_verifying / stubbing</p> <p>WireMock Cloud</p> <p>Create stubs and scenarios with WireMock Cloud's intuitive editor and share with your team.</p> <p>A core feature of WireMock API mocking is the ability to return canned HTTP responses for requests matching criteria. These are described in detail in Request Matching.</p>"},{"location":"stubbing_and_verifying/stubbing/#basic-stubbing","title":"Basic stubbing","text":"<p>You can configure stubs using JSON configuration files or code:</p> <ol> <li>Via a <code>.json</code> file under the <code>mappings</code> directory</li> <li>Via a POST request to <code>http://&lt;host&gt;:&lt;port&gt;/__admin/mappings</code> with the JSON as a body</li> <li>From code using one of the SDKs</li> </ol> <p>Example. To configure a response with a status of 200 to be returned when the relative URL exactly matches <code>/some/thing</code> (including query parameters). The body of the response will be \"Hello world!\" and a <code>Content-Type</code> header will be sent with a value of <code>text-plain</code>.</p> JSONJavaPythonGolang JSON<pre><code>{\n\"request\": {\n    \"method\": \"GET\",\n    \"url\": \"/some/thing\"\n},\n\n\"response\": {\n    \"status\": 200,\n    \"body\": \"Hello, world!\",\n    \"headers\": {\n        \"Content-Type\": \"text/plain\"\n    }\n}\n}\n</code></pre> Java<pre><code>@Test\npublic void exactUrlOnly() {\n    stubFor(get(urlEqualTo(\"/some/thing\"))\n            .willReturn(aResponse()\n                .withHeader(\"Content-Type\", \"text/plain\")\n                .withBody(\"Hello world!\")));\n\n    assertThat(testClient.get(\"/some/thing\").statusCode(), is(200));\n    assertThat(testClient.get(\"/some/thing/else\").statusCode(), is(404));\n}\n</code></pre> Python<pre><code>Mappings.create_mapping(\n    Mapping(\n        request=MappingRequest(method=HttpMethods.GET, url=\"/some/thing\"),\n        response=MappingResponse(status=200, body=\"Hello, world!\", headers=(\"Content-Type\", \"text/plain\")),\n    )\n)\n</code></pre> Go<pre><code>wiremockClient.StubFor(wiremock.Get(wiremock.URLPathEqualTo(\"/some/thing\")).\n        WillReturnResponse(\n            wiremock.NewResponse().\n                WithStatus(http.StatusOK).\n                WithBody(\"Hello, world!\").\n                WithHeader(\"Content-Type\", \"text/plain\")))\n</code></pre> <p>In Java, if you'd prefer to use slightly more BDDish language in your tests, you can replace <code>stubFor</code> with <code>givenThat</code>.</p>"},{"location":"stubbing_and_verifying/stubbing/#java-shortcuts","title":"Java Shortcuts","text":"<p>Some common request and response patterns can be expressed in Java in abbreviated forms.</p> <p>Requests matching an exact URL plus one of the most common HTTP methods (GET, POST, PUT, DELETE) can be stubbed like this:</p> Java<pre><code>stubFor(get(\"/some/thing\")\n    .willReturn(aResponse().withStatus(200)));\n</code></pre> <p>Common responses can also be abbreviated e.g.:</p> Java<pre><code>stubFor(delete(\"/fine\")\n    .willReturn(ok()));\n\nstubFor(get(\"/fine-with-body\")\n    .willReturn(ok(\"body content\")));\n\nstubFor(get(\"/json\")\n    .willReturn(okJson(\"{ \\\"message\\\": \\\"Hello\\\" }\")));\n\nstubFor(post(\"/redirect\")\n    .willReturn(temporaryRedirect(\"/new/place\")));\n\nstubFor(post(\"/sorry-no\")\n    .willReturn(unauthorized()));\n\nstubFor(put(\"/status-only\")\n    .willReturn(status(418)));\n</code></pre> <p>More DSL examples can be found here.</p> <p>HTTP methods currently supported are: <code>GET, POST, PUT, DELETE, HEAD, TRACE, OPTIONS, GET_OR_HEAD</code>. You can specify <code>ANY</code> if you want the stub mapping to match on any request method. <code>GET_OR_HEAD</code> is a special method that could be used to match incoming requests for both <code>GET</code> or <code>HEAD</code> http method. A <code>HEAD</code> request will result in the same behaviour expected from a web server i.e. the <code>Content-Type</code> and <code>Content-Length</code> headers will be emitted but no response body. A detailed guide about various HTTP methods can be found here. <code>GET_OR_HEAD</code> can be used the following way</p> Java<pre><code>@Test\npublic void getOrHeadDemo() {\n    stubFor(getOrHead(urlEqualTo(\"/get-or-head-test\"))\n            .willReturn(okJson(\"{\\\"key\\\": \\\"value\\\"}\")));\n\n    assertThat(testClient.get(\"/get-or-head-test\").statusCode(), is(200));\n}\n</code></pre>"},{"location":"stubbing_and_verifying/stubbing/#setting-the-response-status-message","title":"Setting the response status message","text":"<p>In addition to the status code, the status message can optionally also be set.</p> JavaJSON Java<pre><code>@Test\npublic void statusMessage() {\n    stubFor(get(urlEqualTo(\"/some/thing\"))\n            .willReturn(aResponse()\n                .withStatus(200)\n                .withStatusMessage(\"Everything was just fine!\")\n                .withHeader(\"Content-Type\", \"text/plain\")));\n\n    assertThat(testClient.get(\"/some/thing\").statusCode(), is(200));\n    assertThat(testClient.get(\"/some/thing/else\").statusCode(), is(404));\n}\n</code></pre> JSON<pre><code>{\n    \"request\": {\n        \"method\": \"GET\",\n        \"url\": \"/some/thing\"\n    },\n    \"response\": {\n        \"status\": 200,\n        \"statusMessage\": \"Everything was just fine!\"\n    }\n}\n</code></pre>"},{"location":"stubbing_and_verifying/stubbing/#stub-priority","title":"Stub priority","text":"<p>It is sometimes the case that you'll want to declare two or more stub mappings that \"overlap\", in that a given request would be a match for more than one of them. By default, WireMock will use the most recently added matching stub to satisfy the request. However, in some cases it is useful to exert more control.</p> <p>One example of this might be where you want to define a catch-all stub for any URL that doesn't match any more specific cases. Adding a priority to a stub mapping facilitates this:</p> JavaJson Java<pre><code>//Catch-all case\nstubFor(get(urlMatching(\"/api/.*\")).atPriority(5)\n    .willReturn(aResponse().withStatus(401)));\n\n//Specific case\nstubFor(get(urlEqualTo(\"/api/specific-resource\")).atPriority(1) //1 is highest\n    .willReturn(aResponse()\n            .withStatus(200)\n            .withBody(\"Resource state\")));\n</code></pre> JSON<pre><code>{\n    \"priority\": 1,\n    \"request\": {\n        \"method\": \"GET\",\n        \"url\": \"/api/specific-resource\"\n    },\n    \"response\": {\n        \"status\": 200\n    }\n}\n</code></pre> <p>When unspecified, stubs default to a priority of <code>5</code><sup>^</sup> where <code>1</code> is the highest priority and Java <code>Integer.MAX_VALUE</code> (i.e., <code>2147483647</code>) is the minimum priority.</p>"},{"location":"stubbing_and_verifying/stubbing/#sending-response-headers","title":"Sending response headers","text":"<p>In addition to matching on request headers, it's also possible to send response headers.</p> JavaJSON Java<pre><code>stubFor(get(urlEqualTo(\"/whatever\"))\n        .willReturn(aResponse()\n                .withStatus(200)\n                .withHeader(\"Content-Type\", \"application/json\")\n                .withHeader(\"Set-Cookie\", \"session_id=91837492837\")\n                .withHeader(\"Set-Cookie\", \"split_test_group=B\") // You can call withHeader more than once for the same header if multiple values are required\n                .withHeader(\"Cache-Control\", \"no-cache\")));\n</code></pre> JSON<pre><code>{\n    \"request\": {\n        \"method\": \"GET\",\n        \"url\": \"/whatever\"\n    },\n    \"response\": {\n        \"status\": 200,\n        \"headers\": {\n            \"Content-Type\": \"text/plain\",\n            \"Set-Cookie\": [\"session_id=91837492837\", \"split_test_group=B\"],\n            \"Cache-Control\": \"no-cache\"\n        }\n    }\n}\n</code></pre>"},{"location":"stubbing_and_verifying/stubbing/#specifying-the-response-body","title":"Specifying the response body","text":"<p>The simplest way to specify a response body is as a string literal.</p> JavaJSON Java<pre><code>stubFor(get(urlEqualTo(\"/body\"))\n        .willReturn(aResponse()\n                .withBody(\"Literal text to put in the body\")));\n</code></pre> JSON<pre><code>{\n    \"request\": {\n        \"method\": \"GET\",\n        \"url\": \"/body\"\n    },\n    \"response\": {\n        \"status\": 200,\n        \"body\": \"Literal text to put in the body\"\n    }\n}\n</code></pre> <p>If you're specifying a JSON body via the JSON API, you can avoid having to escape it like this:</p> JSON<pre><code>    \"response\": {\n        \"status\": 200,\n        \"jsonBody\": {\n          \"arbitrary_json\": [1, 2, 3]\n        }\n    }\n</code></pre> <p>To read the body content from a file, place the file under the <code>__files</code> directory. By default this is expected to be under <code>src/test/resources</code> when running from the JUnit rule. When running standalone it will be under the current directory in which the server was started. To make your stub use the file, simply call <code>bodyFile()</code> on the response builder with the file's path relative to <code>__files</code>:</p> JavaJSON Java<pre><code>stubFor(get(urlEqualTo(\"/body-file\"))\n        .willReturn(aResponse()\n                .withBodyFile(\"path/to/myfile.xml\")));\n</code></pre> JSON<pre><code>{\n    \"request\": {\n        \"method\": \"GET\",\n        \"url\": \"/body-file\"\n    },\n    \"response\": {\n        \"status\": 200,\n        \"bodyFileName\": \"path/to/myfile.xml\"\n    }\n}\n</code></pre> <p>note</p> <p>Body file paths should always be relative i.e. not have a leading /</p> <p>note</p> <p>All strings used by WireMock, including the contents of body files are expected to be in <code>UTF-8</code> format. Passing strings in other character sets, whether by JVM configuration or body file encoding will most likely produce strange behaviour.</p> <p>A response body in binary format can be specified as a <code>byte[]</code> via an  overloaded <code>body()</code> in Java.</p> <p>JSON API accepts this as a base64 string (to avoid stupidly long JSON documents):</p> JavaJSON Java<pre><code>stubFor(get(urlEqualTo(\"/binary-body\"))\n        .willReturn(aResponse()\n                .withBody(new byte[] { 1, 2, 3, 4 })));\n</code></pre> JSON<pre><code>{\n    \"request\": {\n        \"method\": \"GET\",\n        \"url\": \"/binary-body\"\n    },\n    \"response\": {\n        \"status\": 200,\n        \"base64Body\": \"WUVTIElOREVFRCE=\"\n    }\n}\n</code></pre>"},{"location":"stubbing_and_verifying/stubbing/#default-response-for-unmapped-requests","title":"Default response for unmapped requests","text":"<p>When a request cannot be mapped to a response, Wiremock returns an HTML response with a 404 status code.</p> <p>It is possible to customize the response by catching all URLs with a low priority.</p> JavaJSON Java<pre><code>stubFor(any(anyUrl())\n                .atPriority(10)\n                .willReturn(aResponse()\n                        .withStatus(404)\n                        .withBody(\"{\\\"status\\\":\\\"Error\\\",\\\"message\\\":\\\"Endpoint not found\\\"}\")));\n</code></pre> JSON<pre><code>{\n    \"priority\": 10,\n    \"request\": {\n        \"method\": \"ANY\",\n        \"urlPattern\": \".*\"\n    },\n    \"response\": {\n        \"status\": 404,\n        \"jsonBody\": { \"status\": \"Error\", \"message\": \"Endpoint not found\" },\n        \"headers\": {\n            \"Content-Type\": \"application/json\"\n        }\n    }\n}\n</code></pre>"},{"location":"stubbing_and_verifying/stubbing/#saving-stubs","title":"Saving stubs","text":"<p>Stub mappings which have been created can be persisted to the <code>mappings</code> directory via a call to <code>WireMock.saveAllMappings</code> in Java or posting a request with an empty body to <code>http://&lt;host&gt;:&lt;port&gt;/__admin/mappings/save</code>.</p> <p>note Note that this feature is not available when running WireMock from a servlet container.</p>"},{"location":"stubbing_and_verifying/stubbing/#editing-stubs","title":"Editing stubs","text":"<p>In Java, Existing stub mappings can be modified, provided they have been assigned an ID.</p> <p>To do the equivalent via the JSON API, <code>PUT</code> the edited stub mapping to <code>/__admin/mappings/{id}</code></p> JavaJSON Java<pre><code>wireMockServer.stubFor(get(urlEqualTo(\"/edit-this\"))\n    .withId(id)\n    .willReturn(aResponse()\n        .withBody(\"Original\")));\n\nassertThat(testClient.get(\"/edit-this\").content(), is(\"Original\"));\n\nwireMockServer.editStub(get(urlEqualTo(\"/edit-this\"))\n    .withId(id)\n    .willReturn(aResponse()\n        .withBody(\"Modified\")));\n\nassertThat(testClient.get(\"/edit-this\").content(), is(\"Modified\"));\n</code></pre> JSON<pre><code>{\n    \"request\": {\n        \"urlPath\": \"/edit-me\",\n        \"method\": \"ANY\"\n    },\n    \"response\": {\n        \"status\": 200\n    }\n}\n</code></pre>"},{"location":"stubbing_and_verifying/stubbing/#file-serving","title":"File serving","text":"<p>When running the standalone JAR, files placed under the <code>__files</code> directory will be served up as if from under the docroot, except if stub mapping matching the URL exists. For example if a file exists <code>__files/things/myfile.html</code> and no stub mapping will match <code>/things/myfile.html</code> then hitting <code>http://&lt;host&gt;:&lt;port&gt;/things/myfile.html</code> will serve the file.</p> <p>This feature is also available with the standard JAR. To use it, define the filesRoot using <code>options.withRootDirectory()</code>, i.e. <code>options.withRootDirectory(getClass.getResource(\"/wiremock\").getPath)</code></p>"},{"location":"stubbing_and_verifying/stubbing/#removing-stubs","title":"Removing stubs","text":"<p>Stub mappings can be deleted via the Java API, either by passing the stub object or the stub ID:</p> Java<pre><code>UUID stubId = UUID.randomUUID();\nStubMapping stubMapping = stubFor(get(\"/delete-me\")\n        .withId(stubId)\n        .willReturn(ok()));\n\nremoveStub(stubMapping);\n\n// or\n\nremoveStub(stubId);\n</code></pre> <p>Where stubs have metadata set on them this can be used to remove them:</p> Java<pre><code>stubFor(get(\"/delete-me\")\n    .withMetadata(metadata().attr(\"tag\", \"payments\"))\n    .willReturn(ok()));\n\nremoveStubsByMetadata(matchingJsonPath(\"$.tag\", equalTo(\"payments\")));\n</code></pre> <p>They can be deleted via the HTTP API by issuing a <code>DELETE</code> to <code>http://&lt;host&gt;:&lt;port&gt;/__admin/mappings/{id}</code> where <code>id</code> is the UUID of the stub mapping, found in its <code>id</code> field.</p>"},{"location":"stubbing_and_verifying/stubbing/#reset","title":"Reset","text":"<p>The WireMock server can be reset at any time, removing all stub mappings and deleting the request log. If you're using either of the JUnit rules this will happen automatically at the start of every test case. However you can do it yourself via a call to <code>WireMock.reset()</code> in Java or sending a <code>POST</code> request with an empty body to <code>http://&lt;host&gt;:&lt;port&gt;/__admin/reset</code>.</p> <p>To reset just the stub mappings leaving the request log intact send a <code>DELETE</code> to <code>http://&lt;host&gt;:&lt;port&gt;/__admin/mappings</code>.</p> <p>If you've created some file based stub mappings to be loaded at startup and you don't want these to disappear when you do a reset you can call <code>WireMock.resetToDefault()</code> instead, or post an empty request to <code>http://&lt;host&gt;:&lt;port&gt;/__admin/mappings/reset</code>.</p>"},{"location":"stubbing_and_verifying/stubbing/#getting-all-currently-registered-stub-mappings","title":"Getting all currently registered stub mappings","text":"<p>All stub mappings can be fetched in Java by calling <code>WireMock.listAllStubMappings()</code>.</p> <p>To fetch them via the HTTP API send a <code>GET</code> to <code>http://&lt;host&gt;:&lt;port&gt;/__admin/mappings</code>.</p> <p>Optionally limit and offset parameters can be specified to constrain the set returned e.g. <code>GET http://localhost:8080/__admin/mappings?limit=10&amp;offset=50</code></p>"},{"location":"stubbing_and_verifying/stubbing/#unmatched-stub-mappings","title":"Unmatched stub mappings","text":"<p>As of WireMock version <code>3.13.0</code>, stub mappings that haven't matched any requests in the the journal can be retrieved in Java by calling <code>WireMock.findUnmatchedStubs()</code>.</p> <p>This can be useful when combined with record and playback to prune unused stub mappings.</p> <p>Via the HTTP API, send a <code>GET</code> or <code>DELETE</code> request to <code>http://&lt;host&gt;:&lt;port&gt;/__admin/mappings/unmatched</code> to fetch or remove them, respectively. Note that a <code>DELETE</code> request will not remove any associated body files under the <code>__files</code> directory.</p>"},{"location":"stubbing_and_verifying/stubbing/#getting-a-single-stub-mapping-by-id","title":"Getting a single stub mapping by ID","text":"<p>A single stub mapping can be retrieved by ID in Java by calling <code>WireMock.getSingleStubMapping(id)</code> where <code>id</code> is the UUID of the stub mapping.</p> <p>Via the HTTP client a mapping can be retrieved by sending a <code>GET</code> to <code>http://&lt;host&gt;:&lt;port&gt;/__admin/mappings/{id}</code>.</p>"},{"location":"stubbing_and_verifying/stubbing/#bulk-importing-stubs","title":"Bulk importing stubs","text":"<p>In Java, Multiple stubs can be imported in one call. </p> <p>The equivalent can be carried out Via the JSON API, <code>POST</code> the to <code>/__admin/mappings/import</code>:</p> JavaJSON Java<pre><code>WireMock.importStubs(stubImport()\n    .stub(get(\"/one\").willReturn(ok()))\n    .stub(post(\"/two\").willReturn(ok(\"Body content\")))\n    .stub(put(\"/three\").willReturn(ok()))\n    .ignoreExisting()\n    .deleteAllExistingStubsNotInImport());\n</code></pre> JSON<pre><code>{\n    \"mappings\": [\n        {\n            \"request\": {\n                \"method\": \"GET\",\n                \"url\": \"/one\"\n            },\n            \"response\": {\n                \"status\": 200\n            }\n        },\n        {\n            \"id\": \"8c5db8b0-2db4-4ad7-a99f-38c9b00da3f7\",\n            \"request\": {\n                \"url\": \"/two\"\n            },\n            \"response\": {\n                \"status\": 200,\n                \"body\": \"Body content\"\n            }\n        }\n    ],\n\n    \"importOptions\": {\n        \"duplicatePolicy\": \"IGNORE\",\n        \"deleteAllNotInImport\": true\n    }\n}\n</code></pre>"},{"location":"stubbing_and_verifying/stubbing/#existing-stubs-policy","title":"Existing stubs policy","text":"<p>By default, if a stub in an import already exists (has an ID of a stub already loaded), then the existing stub will be overwritten. This can be changed by setting <code>duplicatePolicy</code> in the JSON to <code>IGNORE</code> or calling <code>ignoreExisting()</code> on the Java builder.</p>"},{"location":"stubbing_and_verifying/stubbing/#replacing-all-stubs-with-the-import","title":"Replacing all stubs with the import","text":"<p>If you want to ensure that the only stubs loaded after the import has completed are the ones it contains, you can set <code>\"deleteAllNotInImport\": true</code> in the JSON or call <code>deleteAllExistingStubsNotInImport()</code> on the Java builder.</p>"},{"location":"stubbing_and_verifying/stubbing/#disabling-gzip-at-the-responsedefinitionbuilder","title":"Disabling Gzip at the ResponseDefinitionBuilder","text":"<p>If you want to user Gzip disabled response option at the ResponseDefinitionBuilder level. You can use <code>.withGzipDisabled(true)</code></p> Java<pre><code>wireMockServer.stubFor(get(urlEqualTo(\"/todo/items\"))\n        .willReturn(aResponse()\n        .withStatus(200)\n        .withGzipDisabled(true)\n        .withBody(\n        \"Here is some kind of response body\"\n        + \"Here is some kind of response body\"\n        + \"Here is some kind of response body\")));\n</code></pre>"},{"location":"stubbing_and_verifying/verifying/","title":"Verifying","text":"<p>Documentation / stubbing_and_verifying / verifying </p> <p>WireMock Cloud</p> <p>If you are interesting in auto-generating OpenAPI specs and documentation for collaborative prototying, learn about WireMock Cloud.</p> <p>The WireMock server records all requests it receives in memory (at least until it is reset). This makes it possible to verify that a request matching a specific pattern was received, and also to fetch the requests' details.</p> <p>Verifying and querying requests relies on the request journal, which is an in-memory log of received requests. This can be disabled for load testing - see the Configuration section for details.</p> <p>Like stubbing, verification also uses WireMock's Request Matching system to filter and query requests.</p>"},{"location":"stubbing_and_verifying/verifying/#verification-failures-console-output-and-intellij","title":"Verification failures, console output and IntelliJ","text":"<p>When verifying via the Java API all failed verifications will result in a <code>VerificationException</code> being thrown. </p> <p>The message text in the exception is formatted to enable IntelliJ's failure comparison view: </p>"},{"location":"stubbing_and_verifying/verifying/#verifying-in-java","title":"Verifying in Java","text":"<p>To verify that a request matching some criteria was received by WireMock at least once:</p> Java<pre><code>verify(postRequestedFor(urlEqualTo(\"/verify/this\"))\n        .withHeader(\"Content-Type\", equalTo(\"text/xml\")));\n</code></pre> <p>The criteria part in the parameter to <code>postRequestedFor()</code> uses the same builder as for stubbing, so all of the same predicates are available. See Stubbing for more details.</p> <p>To check for a precise number of requests matching the criteria, use this form:</p> Java<pre><code>verify(3, postRequestedFor(urlEqualTo(\"/three/times\")));\n</code></pre> <p>Or you can use some more advanced comparison operators:</p> Java<pre><code>verify(lessThan(5), postRequestedFor(urlEqualTo(\"/many\")));\nverify(lessThanOrExactly(5), postRequestedFor(urlEqualTo(\"/many\")));\nverify(exactly(5), postRequestedFor(urlEqualTo(\"/many\")));\nverify(moreThanOrExactly(5), postRequestedFor(urlEqualTo(\"/many\")));\nverify(moreThan(5), postRequestedFor(urlEqualTo(\"/many\")));\n</code></pre>"},{"location":"stubbing_and_verifying/verifying/#verifying-via-the-json-http-api","title":"Verifying via the JSON + HTTP API","text":"<p>There isn't a direct JSON equivalent to the above Java API. However, it's possible to achieve the same effect by requesting a count of the number of requests matching the specified criteria (and in fact this is what the Java method does under the hood).</p> <p>This can be done by posting a JSON document containing the criteria to <code>http://&lt;host&gt;:&lt;port&gt;/__admin/requests/count</code>:</p> JSON<pre><code>{\n    \"method\": \"POST\",\n    \"url\": \"/resource/to/count\",\n    \"headers\": {\n        \"Content-Type\": {\n            \"matches\": \".*/xml\"\n        }\n    }\n}\n</code></pre> <p>A response of this form will be returned:</p> JSON<pre><code>{ \"count\": 4 }\n</code></pre>"},{"location":"stubbing_and_verifying/verifying/#querying-the-request-journal","title":"Querying the request journal","text":""},{"location":"stubbing_and_verifying/verifying/#getting-all-requests","title":"Getting all requests","text":"<p>All requests received by WireMock since the last reset can be fetched, along with additional data about whether the request was matched by a stub mapping and the resulting response definition.</p> <p>In Java:</p> Java<pre><code>List&lt;ServeEvent&gt; allServeEvents = getAllServeEvents();\n</code></pre> <p>And via the HTTP API by sending a <code>GET</code> to <code>http://&lt;host&gt;:&lt;port&gt;/__admin/requests</code>:</p> JSON<pre><code>{\n    \"requests\": [\n        {\n            \"id\": \"95bd9a40-82d4-47ce-9383-25a9e972f05d\",\n            \"request\": {\n                \"url\": \"/received-request/7\",\n                \"absoluteUrl\": \"http://localhost:51490/received-request/7\",\n                \"method\": \"GET\",\n                \"clientIp\": \"127.0.0.1\",\n                \"headers\": {\n                    \"Connection\": \"keep-alive\",\n                    \"User-Agent\": \"Apache-HttpClient/4.5.1 (Java/1.8.0_45)\",\n                    \"Host\": \"localhost:51490\"\n                },\n                \"cookies\": {},\n                \"browserProxyRequest\": false,\n                \"loggedDate\": 1475495213275,\n                \"bodyAsBase64\": \"\",\n                \"body\": \"\",\n                \"loggedDateString\": \"2016-10-03T11:46:53Z\"\n            },\n            \"responseDefinition\": {\n                \"status\": 200,\n                \"body\": \"This was matched\"\n            },\n            \"wasMatched\": true\n        },\n        {\n            \"id\": \"aa1a4250-f87c-4a17-82e3-79c83441ce03\",\n            \"request\": {\n                \"url\": \"/received-request/6\",\n                \"absoluteUrl\": \"http://localhost:51490/received-request/6\",\n                \"method\": \"GET\",\n                \"clientIp\": \"127.0.0.1\",\n                \"headers\": {\n                    \"Connection\": \"keep-alive\",\n                    \"User-Agent\": \"Apache-HttpClient/4.5.1 (Java/1.8.0_45)\",\n                    \"Host\": \"localhost:51490\"\n                },\n                \"cookies\": {},\n                \"browserProxyRequest\": false,\n                \"loggedDate\": 1475495213268,\n                \"bodyAsBase64\": \"\",\n                \"body\": \"\",\n                \"loggedDateString\": \"2016-10-03T11:46:53Z\"\n            },\n            \"responseDefinition\": {\n                \"status\": 404,\n                \"transformers\": [],\n                \"fromConfiguredStub\": false,\n                \"transformerParameters\": {}\n            },\n            \"wasMatched\": false\n        }\n    ],\n    \"meta\": {\n        \"total\": 2\n    },\n    \"requestJournalDisabled\": false\n}\n</code></pre>"},{"location":"stubbing_and_verifying/verifying/#filtering-events","title":"Filtering events","text":"<p>Optionally the results can be filtered to those occuring after a specififed (ISO8601) date-time. Also, the result set can optionally be limited in size e.g. to return the most recent three results after the 7th of June 2016 12pm send: <code>GET http://localhost:8080/__admin/requests?since=2016-06-06T12:00:00&amp;limit=3</code></p> <p>Results can also be filtered to include only unmatched requests via a query parameter:</p> <p><code>GET http://localhost:8080/__admin/requests?unmatched=true</code></p> <p>In Java:</p> Java<pre><code>List&lt;ServeEvent&gt; serveEvents = getAllServeEvents(ServeEventQuery.ALL_UNMATCHED);\n</code></pre> <p>Likewise, the results can be filtered to include only requests matching a specific stub ID:</p> <p><code>GET http://localhost:8080/__admin/requests?matchingStub=59651373-6deb-4707-847c-9e8caf63266e</code></p> <p>In Java:</p> Java<pre><code>List&lt;ServeEvent&gt; serveEvents =\n  getAllServeEvents(ServeEventQuery.forStubMapping(myStubId));\n</code></pre>"},{"location":"stubbing_and_verifying/verifying/#criteria-queries","title":"Criteria queries","text":"<p>The request journal can also be queried, taking a request pattern as the filter criteria. In Java:</p> Java<pre><code>List&lt;LoggedRequest&gt; requests = findAll(putRequestedFor(urlMatching(\"/api/.*\")));\n</code></pre> <p>And in JSON + HTTP by posting a criteria document (of the same form as for request counting) to <code>http://&lt;host&gt;:&lt;port&gt;/__admin/requests/find</code>, which will return a response like this:</p> JSON<pre><code>{\n    \"requests\": [\n        {\n            \"url\": \"/my/url\",\n            \"absoluteUrl\": \"http://mydomain.com/my/url\",\n            \"method\": \"GET\",\n            \"headers\": {\n                \"Accept-Language\": \"en-us,en;q=0.5\",\n                \"User-Agent\": \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10.6; rv:9.0) Gecko/20100101 Firefox/9.0\",\n                \"Accept\": \"image/png,image/*;q=0.8,*/*;q=0.5\"\n            },\n            \"body\": \"\",\n            \"browserProxyRequest\": true,\n            \"loggedDate\": 1339083581823,\n            \"loggedDateString\": \"2012-06-07 16:39:41\"\n        },\n        {\n            \"url\": \"/my/other/url\",\n            \"absoluteUrl\": \"http://my.other.domain.com/my/other/url\",\n            \"method\": \"POST\",\n            \"headers\": {\n                \"Accept\": \"text/plain\",\n                \"Content-Type\": \"text/plain\"\n            },\n            \"body\": \"My text\",\n            \"browserProxyRequest\": false,\n            \"loggedDate\": 1339083581823,\n            \"loggedDateString\": \"2012-06-07 16:39:41\"\n        }\n    ]\n}\n</code></pre>"},{"location":"stubbing_and_verifying/verifying/#removing-items-from-the-journal","title":"Removing items from the journal","text":""},{"location":"stubbing_and_verifying/verifying/#by-id","title":"By ID","text":"<p>An individual journal event can be removed via the Java API:</p> Java<pre><code>removeServeEvent(id);\n</code></pre> <p>Or via the HTTP API by issuing a <code>DELETE</code> to <code>http://&lt;host&gt;:&lt;port&gt;/__admin/requests/{id}</code>.</p>"},{"location":"stubbing_and_verifying/verifying/#by-criteria","title":"By criteria","text":"<p>Events can also be removed from the request journal by criteria (in the same manner as for finding them described in Criteria queries).</p> <p>Using the Java DSL:</p> Java<pre><code>removeServeEvents(putRequestedFor(urlMatching(\"/api/.*\")\n    .withHeader(\"X-Trace-Id\", equalTo(\"123\"))));\n</code></pre> <p>Or via the HTTP API:</p> Text Only<pre><code>POST http://&lt;host&gt;:&lt;port&gt;/__admin/requests/remove\n\n{\n    \"method\": \"PUT\",\n    \"urlPattern\": \"/api/.*\",\n    \"headers\": {\n        \"X-Trace-Id\": {\n            \"equalTo\": \"123\"\n        }\n    }\n}\n</code></pre>"},{"location":"stubbing_and_verifying/verifying/#by-stub-metadata","title":"By stub metadata","text":"<p>In situations where it isn't possible to precisely identify log events for removal from request attributes alone, the metadata associated with stubs matching requests can be used for selection. For instance, your test code might create stubs tagged with test case identifiers, then use these to clean up events created by the test:</p> Java<pre><code>stubFor(get(\"/api/dosomething/123\")\n    .withMetadata(metadata()\n        .list(\"tags\", \"test-57\")\n    ));\n\ntestClient.get(\"/api/dosomething/123\");\n\nList&lt;ServeEvent&gt; removedServeEvents = removeEventsByStubMetadata(matchingJsonPath(\"$.tags[0]\", equalTo(\"test-57\")));\n</code></pre> Text Only<pre><code>POST /__admin/requests/remove-by-metadata\n\n{\n    \"matchesJsonPath\" : {\n      \"expression\" : \"$.tags[0]\",\n      \"equalTo\" : \"test-57\"\n    }\n}\n</code></pre> <p>For more info about stub metadata see Stub Metadata</p>"},{"location":"stubbing_and_verifying/verifying/#resetting-the-request-journal","title":"Resetting the request journal","text":"<p>The request log can be reset at any time. If you're using either of the JUnit rules this will happen automatically at the start of every test case. However you can do it yourself via a call to <code>WireMock.resetAllRequests()</code> in Java or sending a <code>DELETE</code> request to <code>http://&lt;host&gt;:&lt;port&gt;/__admin/requests</code>.</p>"},{"location":"stubbing_and_verifying/verifying/#finding-unmatched-requests","title":"Finding unmatched requests","text":"<p>To find all requests which were received but not matched by a configured stub (i.e. received the default 404 response) do the following in Java:</p> Java<pre><code>List&lt;LoggedRequest&gt; unmatched = WireMock.findUnmatchedRequests();\n</code></pre> <p>To find unmatched requests via the HTTP API, make a <code>GET</code> request to <code>/__admin/requests/unmatched</code>:</p> Bash<pre><code>GET http://localhost:8080/__admin/requests/unmatched\n{\n  \"requests\" : [ {\n    \"url\" : \"/nomatch\",\n    \"absoluteUrl\" : \"http://localhost:8080/nomatch\",\n    \"method\" : \"GET\",\n    \"clientIp\" : \"0:0:0:0:0:0:0:1\",\n    \"headers\" : {\n      \"User-Agent\" : \"curl/7.30.0\",\n      \"Accept\" : \"*/*\",\n      \"Host\" : \"localhost:8080\"\n    },\n    \"cookies\" : { },\n    \"browserProxyRequest\" : false,\n    \"loggedDate\" : 1467402464520,\n    \"bodyAsBase64\" : \"\",\n    \"body\" : \"\",\n    \"loggedDateString\" : \"2016-07-01T19:47:44Z\"\n  } ],\n  \"requestJournalDisabled\" : false\n}\n</code></pre>"},{"location":"stubbing_and_verifying/verifying/#near-misses","title":"Near misses","text":"<p>\"Near Misses\" are enabled by the new \"distance\" concept added to the matching system. A near miss is essentially a pairing of a request and request pattern that are not an exact match for each other, that can be ranked by distance. This is useful when debugging test failures as it is quite common for a request not to be matched to a stub due to a minor difference e.g. a miscapitalised character.</p> <p>Near misses can either represent the closest stubs to a given request, or the closest requests to a given request pattern depending on the type of query submitted.</p> <p>To find near misses representing stub mappings closest to the specified request in Java:</p> Java<pre><code>List&lt;NearMiss&gt; nearMisses = WireMock.findNearMissesFor(myLoggedRequest);\n</code></pre> <p>To do the same via the HTTP API:</p> Bash<pre><code>POST /__admin/near-misses/request\n\n{\n  \"url\": \"/actual\",\n  \"absoluteUrl\": \"http://localhost:8080/actual\",\n  \"method\": \"GET\",\n  \"clientIp\": \"0:0:0:0:0:0:0:1\",\n  \"headers\": {\n    \"User-Agent\": \"curl/7.30.0\",\n    \"Accept\": \"*/*\",\n    \"Host\": \"localhost:8080\"\n  },\n  \"cookies\": {},\n  \"browserProxyRequest\": false,\n  \"loggedDate\": 1467402464520,\n  \"bodyAsBase64\": \"\",\n  \"body\": \"\",\n  \"loggedDateString\": \"2016-07-01T19:47:44Z\"\n}\n</code></pre> <p>will return a response like:</p> JSON<pre><code>{\n    \"nearMisses\": [\n        {\n            \"request\": {\n                \"url\": \"/actual\",\n                \"absoluteUrl\": \"http://localhost:8080/nomatch\",\n                \"method\": \"GET\",\n                \"clientIp\": \"0:0:0:0:0:0:0:1\",\n                \"headers\": {\n                    \"User-Agent\": \"curl/7.30.0\",\n                    \"Accept\": \"*/*\",\n                    \"Host\": \"localhost:8080\"\n                },\n                \"cookies\": {},\n                \"browserProxyRequest\": false,\n                \"loggedDate\": 1467402464520,\n                \"bodyAsBase64\": \"\",\n                \"body\": \"\",\n                \"loggedDateString\": \"2016-07-01T19:47:44Z\"\n            },\n            \"stubMapping\": {\n                \"uuid\": \"42aedcf2-1f8d-4009-ac7b-9870e4ab2316\",\n                \"request\": {\n                    \"url\": \"/expected\",\n                    \"method\": \"GET\"\n                },\n                \"response\": {\n                    \"status\": 200\n                }\n            },\n            \"matchResult\": {\n                \"distance\": 0.12962962962962962\n            }\n        }\n    ]\n}\n</code></pre> <p>To find near misses representing stub mappings closest to the specified request in Java:</p> Java<pre><code>List&lt;NearMiss&gt; nearMisses = WireMock.findNearMissesFor(\n    getRequestedFor(urlEqualTo(\"/thing-url\"))\n        .withRequestBody(containing(\"thing\"))\n);\n</code></pre> <p>The equivalent via the HTTP API:</p> Bash<pre><code>POST /__admin/near-misses/request-pattern\n\n{\n    \"url\": \"/almostmatch\",\n    \"method\": \"GET\"\n}\n</code></pre> <p>will return a response like:</p> JSON<pre><code>{\n    \"nearMisses\": [\n        {\n            \"request\": {\n                \"url\": \"/nomatch\",\n                \"absoluteUrl\": \"http://localhost:8080/nomatch\",\n                \"method\": \"GET\",\n                \"clientIp\": \"0:0:0:0:0:0:0:1\",\n                \"headers\": {\n                    \"User-Agent\": \"curl/7.30.0\",\n                    \"Accept\": \"*/*\",\n                    \"Host\": \"localhost:8080\"\n                },\n                \"cookies\": {},\n                \"browserProxyRequest\": false,\n                \"loggedDate\": 1467402464520,\n                \"bodyAsBase64\": \"\",\n                \"body\": \"\",\n                \"loggedDateString\": \"2016-07-01T19:47:44Z\"\n            },\n            \"requestPattern\": {\n                \"url\": \"/almostmatch\",\n                \"method\": \"GET\"\n            },\n            \"matchResult\": {\n                \"distance\": 0.06944444444444445\n            }\n        }\n    ]\n}\n</code></pre> <p>As a convenience you can also find the top 3 near misses for every unmatched request:</p> Java<pre><code>List&lt;NearMiss&gt; nearMisses = WireMock.findNearMissesForAllUnmatched();\n</code></pre> <p>To do the same via the HTTP API, issue a <code>GET</code> to <code>/__admin/requests/unmatched/near-misses</code>, which will produce output of the same form as for the query for near misses by request.</p>"},{"location":"v4/","title":"WireMock v4","text":"<p>Documentation / v4</p> <p>WireMock Cloud</p> <p>To create publicly hosted mock APIs without anything to install, learn more about WireMock Cloud.</p>"},{"location":"v4/#v4-beta","title":"v4 Beta","text":"<p>Version 4 of WireMock is currently in beta.  It is under active development and we recommend you try it out.  We would love to hear your feedback over on the community slack - https://slack.wiremock.org/</p> <p>We have given these releases a beta label due to the fact that as we move forwards with the <code>4.x</code> release there will be breaking changes.  These are the current updates to the <code>4.x</code> release:</p> <ul> <li>Java 17 is now the baseline java version</li> <li>Jetty 12 is shipped by default so there is no longer a specific jetty 12 release of <code>4.x</code> and Jetty 11 is no longer supported</li> </ul>"},{"location":"v4/#breaking-changes-and-how-to-migrate","title":"Breaking changes and how to migrate","text":""},{"location":"v4/#multiple-content-type-headers","title":"Multiple Content-Type headers","text":"<p>In v3 using Jetty 11, if you configured a stub with multiple <code>Content-Type</code> headers, Jetty 11 stripped out all but the last.</p> <p>In v4.x WireMock will return all the <code>Content-Type</code> headers. This may break some clients which do not know what to do if an HTTP response has multiple <code>Content-Type</code> headers.</p> <p>Solution: only configure a single <code>Content-Type</code> header on a stub.</p>"},{"location":"v4/#removed-transitive-dependencies","title":"Removed transitive dependencies","text":"<p>v4 no longer has transitive dependencies on the following libraries:</p> <ul> <li>org.eclipse.jetty:jetty-webapp (package org.eclipse.jetty.webapp) - Jetty 12 equivalent is org.eclipse.jetty.ee10:jetty-ee10-webapp</li> <li>org.eclipse.jetty.ee10:jetty-ee10-webapp (package org.eclipse.jetty.ee10.webapp)</li> <li>org.eclipse.jetty:jetty-alpn-client (package org.eclipse.jetty.alpn.client)</li> <li>org.eclipse.jetty:jetty-alpn-java-client (package org.eclipse.jetty.alpn.java.client)</li> <li>org.eclipse.jetty:jetty-client (package org.eclipse.jetty.client)</li> <li>org.eclipse.jetty:jetty-ee (package org.eclipse.jetty.ee)</li> <li>org.eclipse.jetty:jetty-proxy (package org.eclipse.jetty.proxy)</li> <li>org.eclipse.jetty:jetty-xml (package org.eclipse.jetty.xml)</li> </ul> <p>If your code depends on classes in these packages you will need to bring the dependencies in directly.</p> <p>The following transitive dependencies have been replaced and may require changes to package names:</p> <ul> <li>org.eclipse.jetty:jetty-servlet -&gt; org.eclipse.jetty.ee10:jetty-ee10-servlet</li> <li>org.eclipse.jetty:jetty-servlets -&gt; org.eclipse.jetty.ee10:jetty-ee10-servlets</li> <li>org.eclipse.jetty.http2:http2-common -&gt; org.eclipse.jetty.http2:jetty-http2-common</li> <li>org.eclipse.jetty.http2:http2-hpack -&gt; org.eclipse.jetty.http2:jetty-http2-hpack</li> <li>org.eclipse.jetty.http2:http2-server -&gt; org.eclipse.jetty.http2:jetty-http2-server</li> </ul>"}]}